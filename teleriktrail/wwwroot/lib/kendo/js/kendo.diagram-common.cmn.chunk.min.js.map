{"version":3,"sources":["raw-js/kendo.diagram-common.cmn.chunk.js"],"names":["global","factory","exports","module","require","define","amd","globalThis","self","kendo","_globals","DiagramCommonCmnChunk","DrawingCmnChunk","CommonCmnChunk","this","kendo_drawing_cmn_chunk_js","kendo_common_cmn_chunk_js","WIDTH","HEIGHT","X","Y","TRANSPARENT","START$1","END$1","MarkerType","DEG_TO_RAD","Math","PI","EPSILON","CHANGE$1","Cursors","arrow","grip","cross","add","move","select","south","east","west","north","rowresize","colresize","HIT_TEST_DISTANCE","AUTO","TOP","RIGHT","LEFT","BOTTOM","DRAG_START","DRAG","DRAG_END","ITEMROTATE","ITEMBOUNDSCHANGE","MOUSE_ENTER","MOUSE_LEAVE","ZOOM_START","ZOOM_END","PAN","ROTATED","SOURCE","TARGET","HANDLE_NAMES","ConnectionEditing","CASCADING","MAXINT","SELECT$1","NONE","MAX_VALUE","Number","MIN_VALUE","TRANSFORMED","isNearZero","value","abs","isDefined","obj","defined","isFunction$1","isUndefined","isObject","Object","has","key","hasOwnProperty","call","isString$1","prototype","toString","isNumber","isNaN","parseFloat","isFinite","isEmpty","Array","isArray","length","simpleExtend","destination","source","name","initArray","size","array","i","randomInteger","lower","upper","random","floor","parseInt","DFT","el","func","childNodes","item","findRadian","start","end","sngXComp","x","sngYComp","y","atan","sign","num","findAngle","center","forEach","arr","iterator","thisRef","getAny","predicate","remove","what","ax","indexOf","splice","contains","includes","inArray","grep$1","filter","fold","list","acc","context","initial","undefined","Error","find","bind","first","constraint","insert","element","position","all","result","clear","bisort","a","b","sortfunc","points","push","sort","m","n","addRange","range","noop$1","STRING","FUNCTION","preventDefault$2","_defaultPrevented","isDefaultPrevented","Observable","constructor","options","events","_events","destroy","unbind","event","handlers","one","eventNames","handlersIsFunction","original","handler","idx","eventName","args","apply","String","from","curName","unshift","trigger","eventArgs","e","sender","preventDefault","slice","_setEvents","Utils$1","freeze","__proto__","deserializePoints","s","v","split","getMatrixAngle","d","atan2","getMatrixScaling","sqrt","c","grep","isBoolean","isFunction","isString","isType","type","noop","serializePoints","res","p","join","Easing","easeInOut","pos","cos","Ticker","adapters","target","tick","interval","duration","lastTime","timerDelegate","intervalId","caller","onTimerEvent","addAdapter","onComplete","removeHandler","h","onStep","seekTo","to","seekFromTo","max","min","Date","getTime","window","setInterval","stop","clearInterval","play","origin","initState","reverse","propagate","update","now","timePassed","movement","randomId","chars","charAt","round","HashTable","_buckets","_stringsMap","Map","_stringsCounter","_createGetBucket","get","_bucketExists","set","containsKey","hashId","_hash","hashes","_hashes","len","hash","bucket","clone","ht","_hashString","_objectHashId","id","_hashId","Dictionary","dictionary","super","_hashTable","k","entry","forEachValue","forEachKey","keys","Geometry","_distanceToLineSquared","d2","pt1","pt2","vx","vy","dot","distanceToLine","distanceToPolyline","minimum","p1","p2","Polar","r","angle","Point","P","plus","minus","offset","times","normalize","lengthSquared","middleOf","q","toPolar","useDegrees","factor","halfpi","isOnLine","temp","r1","Rect","inflate","r2","o1","u1","union","height","width","parse","str","xy","point","dx","dy","x1","y1","x2","y2","top","right","bottom","left","topLeft","topRight","bottomLeft","bottomRight","equals","rect","rotatedBounds","rotatedPoints","tl","tr","br","bl","rotate","delimiter","scale","scaleX","scaleY","staicPoint","adornerCenter","thisCenter","delta","scaled","zoom","overlaps","rectBottomRight","toRect","empty","fromPoints","RectAlign","container","align","content","alignment","alignValues","toLowerCase","_singleAlign","_align","_left","_center","_right","stretch","_stretch","_top","middle","_middle","_bottom","alignCalc","Queue","_tail","_head","enqueue","next","dequeue","current","OBJECT","deepExtendOne","property","propValue","propType","propInit","destProp","deepExtend","sources","LayoutDefaultOptions","subtype","roots","animate","limitToView","friction","nodeDistance","iterations","horizontalSeparation","verticalSeparation","underneathVerticalTopOffset","underneathHorizontalOffset","underneathVerticalSeparation","grid","offsetX","offsetY","componentSpacingX","componentSpacingY","layerSeparation","layeredIterations","startRadialAngle","endRadialAngle","radialSeparation","radialFirstLevelSeparation","keepComponentsInOneRadialLayout","ignoreContainers","layoutContainerChildren","ignoreInvisible","animateTransitions","LayoutBase","defaultOptions","gridLayoutComponents","components","calcBounds","bounds","maxWidth","startX","resultLinkSet","resultNodeSet","component","pop","moveToOffset","nodes","links","boundingRect","currentHeight","currentWidth","j","deltaX","deltaY","node","nodeBounds","link","newPoints","pt","currentHorizontalOffset","transferOptions","LayoutState","diagram","graphOrNodes","nodeMap","linkMap","capture","diagramOrGraphOrNodes","shape","conn","associatedShape","visual","associatedConnection","shapes","connections","Node","outgoing","incoming","weight","data","isVirtual","shortForm","isIsolated","isLinkedTo","getComplement","getChildren","children","getParents","parents","copy","balance","owner","adjacentTo","removeLink","hasLinkTo","degree","incidentWith","getLinksWith","getNeighbors","neighbors","Link","connection","sourceFound","targetFound","getCommonNode","isBridging","v1","v2","getNodes","changeSource","changeTarget","changesNodes","w","oldSource","oldTarget","directTo","createReverseEdge","reversed","Graph","idOrDiagram","_nodeMap","_root","_hasCachedRelationships","componentIndex","cacheRelationships","forceRebuild","assignLevels","startNode","visited","level","child","root","found","getConnectedComponents","setItemIndices","componentId","_collectConnectedNodes","addNodeAndOutgoings","setIds","nodeIndex","nextId","index","getSpanningTree","tree","map","rootClone","remaining","_addNode","levelCount","ni","cn","newLink","addLink","treeLevels","takeRandomNode","excludedNodes","incidenceLessThan","pool","isHealthy","hasNode","sourceOrLink","addExistingLink","foundSource","getNode","addNode","foundTarget","removeAllLinks","hasLink","t","linkOrId","nodeOrId","_removeNode","removeNode","areConnected","n1","n2","layoutRect","newNode","newLinks","saveMapping","save","nOriginal","nCopy","linkOriginal","linkCopy","linearize","addIds","Utils","depthFirstTraversal","action","foundNode","_dftIterator","breadthFirstTraversal","queue","_stronglyConnectedComponents","excludeSingleItems","indices","lowLinks","connected","stack","findCycles","isAcyclic","isSubGraph","other","otherArray","thisArray","makeAcyclic","oneNode","rev","N","intensityCatalog","flowIntensity","catalogEqualIntensity","intensity","sourceStack","targetStack","targets","li","targetLink","si","sourceLink","ri","ril","u","concat","vertexOrder","kk","reversedEdges","Predefined","EightGraph","Mindmap","ThreeGraph","BinaryTree","levels","createBalancedTree","Linear","Tree","siblingsCount","Forest","trees","createBalancedForest","Workflow","Grid","g","previous","graphString","previousLink","graph","parts","part","lin","_addShape","kendoDiagram","shapeDefaults","radius","fill","undoable","addShape","_addConnection","connect","createDiagramFromGraph","doLayout","randomSize","clientWidth","clientHeight","opt","color","gli","sourceShape","targetShape","SpringLayout","layoutGraph","shi","news","counter","lastAdded","parent","treeCount","createRandomConnectedGraph","nodeCount","maxIncidence","isTree","poolNode","randomAdditions","randomDiagram","shapeCount","layout","DiagramToHyperTreeAdapter","convert","finalNodeSet","initialTemperature","temperature","guessBounds","_expectedBounds","step","refineStage","_repulsion","_attraction","_shake","rho","alpha","sin","_InverseSquareForce","force","deltax","deltay","wn","hn","wm","hm","pow","_SquareForce","distance","squareSize","area","ceil","shapeMap","edges","edgeMap","finalNodes","finalLinks","ignoredConnections","ignoredShapes","hyperMap","hyperTree","finalGraph","_renormalizeShapes","_renormalizeConnections","l","mapConnection","mapShape","getEdge","listToRoot","containerGraph","parentContainer","firstNonIgnorableContainer","isContainer","isIgnorableItem","isContainerConnection","isDescendantOf","scope","containers","isCollapsed","_isVisible","_isTop","isShapeMapped","leastCommonAncestor","al","xa","xb","visible","_isCollapsed","sourceConnector","sink","targetConnector","sourceNode","sinkNode","areConnectedAlready","newEdge","intersectLine","start1","end1","start2","end2","isSegment","tangensdiff","Intersect","lines","segments","rectWithLine","rects","rect1","rect2","intersect","reverseAngle","MatrixVector","f","fromMatrix","Matrix","applyRect","fromSVGMatrix","vm","fromMatrixVector","fromList","translation","unit","rotation","scaling","nums","trim","substr","PathDefiner","Set","resource","kv","toArray","Size","Empty","Rotation","toMatrix","invert","create","values","ZERO","Scale","Translation","toMatrixVector","Length","CompositeTransform","translate","transform","render","_transform","_renderTransform","rotateMatrix","scaleMatrix","translatePoint","diffNumericOptions","fields","elementOptions","hasChanges","field","Element","_originSize","drawingContainer","redraw","drawingElement","matrix","M","_hover","_diffNumericOptions","_measure","_measured","box","_boundingBox","R","startPoint","_originWidth","_originHeight","rawBBox","sizeOptionsOrDefault","normalizeDrawingOptions","drawingOptions","getColor","C","toHex","createSegment","S","toDrawingRect","getSpacing","defaultSpacing","spacing","drawRoundedPolygon","path","prev","curr","cornerRadius","len1","hypot","len2","cosPhi","phi","acos","ds","tan","dsClamped","moveTo","lineTo","sweep","arcTo","close","fitToSize","strokeWidth","bb","bbox","targetH","sx","sy","inflatePolygon","out","bLen","outDir","defaultOptions$n","stroke","VisualBase","opacity","_fill","_stroke","show","hover","_setFill","_evalStrokeOptions","strokeOptions","dashType","_evalFillOptions","fillOptions","gradient","GradientClass","L","defaultOptions$m","MarkerBase","anchor","createElement","_transformToPath","transformCopy","defaultArrowOptions","ArrowMarker","positionMarker","_linePoints","transform$1","xDiff","yDiff","lineAngle","endPoint","targetSegment","controlOut","nextSegment","controlIn","prevSegment","Canvas$1","_translate","viewBox","_viewBox","surface","G","clippedBBox","setSize","draw","append","insertBefore","clearHtml","firstChild","removeChild","removeChildren$1","AutoSizeableMixin","_setScale","originWidth","originHeight","_setTranslate","_initSize","autoSize","_updateSize","Circle","_initCircle","circleOptions","_circle","setRadius","defaultOptions$l","CircleMarker","Rectangle","_initPath","_setPosition","_drawPath","drawPolygon","MultiPathShape","defaultOptions$k","shapesOffsetRatio","Collate","shapesOffset","halfWidth","halfHeight","OnPageConnector","centerX","defaultOptions$j","slantRatio","DataInputOutput","slant","defaultOptions$i","ellipseRxRatio","ellipseRyRatio","Database","rx","ellipseRY","cy","ry","defaultOptions$h","ellipseRadiusXRatio","ellipseRadiusYRatio","DataStorage","ellipseRX","leftCx","arc","Decision","inflated","defaultOptions$g","arcRadiusXRatio","arcRadiusYRatio","Delay","arcRadiusX","arcRadiusY","defaultOptions$f","ellipseRatio","DirectAccessStorage","cx","defaultOptions$e","sideCutRatio","Display","arcStartX","cut","cp1XRatio","cp2XRatio","docDefaultOptions","waveRatio","multyDocsDefaultOptions","docsXRatio","docsYRatio","drawDocument","amplitude","curveTo","Document","halfAmplitude","MultipleDocuments","docOffsetX","docOffsetY","path1","path2","Terminator","Extract","Group","_childrenChange","_remove","removeAt","toFront","visuals","toBack","_reorderChildren","toIndex","group","drawingChildren","fixedPosition","boundingBox","childBoundingBox","_includeInBBox","Image","_initImage","src","_rect","I","sizeOptions","o","defaultOptions$d","leftLineOffsetRatio","topLineOffsetRatio","InternalStorage","leftLineX","topLineOffset","MarkerPathMixin","_getPath","paths","_normalizeMarkerOptions","startCap","endCap","_removeMarker","marker","_markers","_createMarkers","_createMarker","markerType","FilledCircle","ArrowStart","ArrowEnd","_positionMarker","_capMap","_redrawMarker","pathChange","pathOptions","cap","pathCapType","optionsCap","created","_redrawMarkers","defaultOptions$c","topSlantRatio","ManualInputOutput","defaultOptions$b","baseShrinkRatio","ManualOperation","baseShrink","Merge","LogicalOr","centerY","defaultOptions$a","bottomEdgeYRatio","OffPageConnector","topY","leftY","rightY","bottomY","bottomMiddleX","bottomMiddleY","Path","_createElements","_setData","multipath","elements","Polyline","_updatePath","_pointsDiffer","currentPoints","differ","defaultOptions$9","sideLineOffsetRatio","PredefinedProcess","sideLineOffset","rightLineX","defaultOptions$8","horizontalInsetRatio","Preparation","xOffset","Process","defaultOptions$7","Sort","SummingJunction","SQRT2","textColor","defaultOptions$6","fontSize","fontFamily","lineSpacing","textWrap","padding","relativePadding","TextBlock","textElements","alignable","_font","_initText","T","text","font","fontOptions","fontStyle","fontWeight","sizeChanged","textOptions","Box","pad","unpad","parseAlign","justifyContent","alignContent","MultiLineTextBlock","arguments","shapeSize","contentSpacing","getContentSpacing","_textLines","line","textElement","reflow","style","measureText$1","words","currentLine","word","testPart","substring","testLine","LayeredLayout","_initRuntimeProperties","layer","downstreamLinkCount","upstreamLinkCount","uBaryCenter","dBaryCenter","upstreamPriority","downstreamPriority","gridPosition","_prepare","layerMap","layerCount","targetLayer","shift","sortedNodes","o2","o1layer","o2layer","minLayer","layers","linksTo","layerVal","_dummify","_optimizeCrossings","_swapPairs","arrangeNodes","_moveThingsAround","_dedummify","setMinDist","_n","minDist","layerIndex","isInteger","minDistances","getMinDist","dist","i1","i2","placeLeftToRight","leftClasses","leftPos","classNodes","placeLeft","POSITIVE_INFINITY","rightSibling","nodeLeftClass","D","upNodes","downNodes","neighbor","intDiv","placeRightToLeft","rightClasses","rightPos","placeRight","NEGATIVE_INFINITY","leftSibling","nodeRightClass","_getLeftWing","leftWing","computeClasses","_getRightWing","rightWing","wingPair","currentWing","wing","ndsinl","_nodesInLink","vnode","wings","classIndex","_isVerticalLayout","_isHorizontalLayout","_isIncreasingLayout","_gridPositionComparer","gNode","dest","down","up","currentNode","currDown","downNode","order","placed","sequenceStart","ll","layer2","virtualStartIndex","_firstVirtualNode","virtualStart","sequence","_sequencer","virtualEnd","nextVirtualNode","virtualEndIndex","adjustDirections","fromLayerIndex","layerIncrement","maximumHeight","ctx","nn","node2","prevBridge","prevBridgeTarget","nextBridge","nextBridgeTarget","getNeighborOnLayer","clayer","j1","j2","dir","_sequenceSingle","combineSequences","leftHeap","pair","_positionDescendingComparer","rightHeap","_positionAscendingComparer","leftRes","rightRes","leftClass","_getComposite","rightClass","it","layoutLayer","gridPos","iconsidered","considered","sorted","n1Priority","n2Priority","nodeGridPos","nodeBaryCenter","calcBaryCenter","nodePriority","moveRight","moveLeft","calcDownData","calcUpData","priority","rightNode","rightNodePriority","leftNode","leftNodePriority","mapVirtualNode","nodeToLinkMap","linkToNodeMap","addLinkBetweenLayers","upLayer","downLayer","oLayer","dLayer","oPos","dPos","depthOfDumminess","dedum","prevLink","moves","iter","optimizeLayerCrossings","sum","total","presorted","n1BaryCenter","n2BaryCenter","compareByIndex","compareValue","inode","maxIterations","downwards","secondPass","hasSwapped","calcCrossings","memCrossings","crossBefore","countLinksCrossingBetweenTwoLayers","node1","node1GridPos","node2GridPos","crossAfter","revert","ulayer","dlayer","link1","link2","n11","n12","n21","n22","l1","l2","crossings","n11gp","n12gp","numerator","denominator","TreeLayoutProcessor","treeGraph","layoutSwitch","layoutLeft","setChildrenDirection","setChildrenLayout","TreeDirection","measure","arrange","layoutRight","layoutUp","layoutDown","treeDirection","layoutRadialTree","previousRoot","startAngle","endAngle","maxDepth","calculateAngularWidth","radialLayout","Angle","tipOverTree","startFromLevel","diameter","aw","sectorAngle","sortChildren","basevalue","pl","nl","normalizeAngle","count","col","deltaTheta","deltaThetaHalf","parentSector","fraction","childNode","cp","childAngleFraction","setPolarLocation","BoundingRectangle","direction","includeStart","rootDirection","rootLayout","childrenLayout","givenSize","shapeWidth","shapeHeight","AngleToParent","SectorAngle","pp","childrenwidth","selfLocation","single","male","female","leftcount","tipOverTreeStartLevel","TreeLayout","adapter","layoutComponents","getTree","getTreeForRoot","AdornerBase","_adorners","refresh","ConnectionEditUndoUnit","undoSource","undoTarget","_undoSource","_undoTarget","_redoSource","_redoTarget","title","undo","_updateConnector","updateModel","redo","isAutoConnector","connector","closestConnector","connectors","resCtr","minimumDistance","distanceTo","indicesOfItems","filterShapeDataItem","dataItem","FlowchartShapeType","documentConnectors","shapeVisual","getPosition","triangleConnectors","RotateUnit","adorner","undoRotates","redoRotates","redoAngle","_angle","_innerBounds","_initialize","defaultOptions$5","Connector","toJSON","shapeId","tempStr","getConnector","DefaultConnectors","extra","defaults","minWidth","minHeight","editable","tools","compile","template","_options","TemplateService","register","userImplementation","getTemplate","getSupportedFeatures","os","ua","agentRxs","wp","fire","android","iphone","ipad","playbook","windows","tizen","sailfish","osRxs","ios","flat","agent","match","navigator","device","testRegex","detectOS","userAgent","support","mobileOS","regexes","dflt","regex","test","extend$1","assign","addClass","className","classList","convertToHtml","html","div","document","innerHTML","prepend","originElement","defaultOptions$4","cursor","selectable","serializable","enable","DiagramElement","isSelected","_template","_getCursor","serialize","json","_content","contentOptions","_contentVisual","_updateContentVisual","_createContentVisual","Type","_hitTest","elementTemplate","_canSelect","Shape","updateOptionsFromModel","createShapeVisual","updateBounds","_createConnectors","_setOptionsFromModel","model","modelOptions","redrawVisual","_isEditable","_redrawVisual","syncChanges","updateShapeModel","_rotate","_alignContent","contentVisual","containerRect","aligner","contentBounds","contentRect","alignedBounds","currentConnectors","connectorDefaults","_transformedBounds","pan","_pan","_rotatedBounds","_bounds","_setBounds","_triggerBoundsChange","_layouting","refreshConnections","cloneDataItem","selected","deselected","_selectedItems","_internalSelection","_selectionChanged","undoRedoService","_resizingAdorner","sc","deltaAngle","newPosition","_rotationOffset","_connectorsAdorner","con","cons","ctr","nameOrPoint","toLocaleLowerCase","side","fnName","_transformPoint","shapeOptions","boundsChange","_visualOptions","_updateConnectors","modelToView","_showConnectors","rotatedPoint","visualOptions","visualTemplate","translateToOrigin","ConnectionEditAdorner","handles","_ts","toolService","sp","sourcePoint","tp","targetPoint","spVisual","epVisual","handle","_initialSource","_initialTarget","_connectionManipulation","ts","hoveredItem","_hoveredConnector","_c","radiusX","radiusY","sourcePointDistance","targetPointDistance","sourceHandle","targetHandle","modelToLayer","ConnectorVisual","relative","_visualBounds","ConnectorsAdorner","_refreshHandler","_visible","_clearVisual","_cachedTouchTarget","_keepCachedTouchTarget","visualChildren","childrenCount","canDrag","drag","TransformUnit","undoStates","redoStates","refreshBounds","defaultOptions$3","ResizingAdorner","_manipulating","shapeStates","_initSelection","_createHandles","_internalChange","_rotatedHandler","_resizable","resize","_handleOptions","handlesCount","hit","handleBounds","_getHandleBounds","items","_startAngle","_rotates","_positions","initialRotates","initialStates","handleOptions","_sp","_cp","_lp","visibleHandles","currentAngle","dragging","newBounds","staticPoint","dtl","dbr","changed","_truncateAngle","_rotating","shouldSnap","thr","_truncateDistance","isDragHandle","hitToOppositeSide","_displaceBounds","newCenter","oldBounds","cancel","states","_truncatePositionToGuides","ruler","truncatePositionToGuides","_truncateSizeToGuides","truncateSizeToGuides","snap","snapOptions","snapAngle","snapSize","_diffStates","_syncShapeChanges","rotationThumb","thumb","_rotationThumbBounds","defaultOptions$2","Selector","_ep","_adorn","visualBounds","ConnectionRouterBase","LinearConnectionRouter","hitTest","getBounds","allPoints","CascadingRouter","SAME_SIDE_DISTANCE_RATIO","_connectorSides","axis","boundsPoint","secondarySign","routePoints","_connectorPoints","_floatingPoints","route","_resolvedSourceConnector","_resolvedTargetConnector","_connectorSide","shapeBounds","sides","sideDistance","minSide","_sameSideDistance","sourceConnectorSide","targetConnectorSide","sameSideDistance","pointX","pointY","cascadeStartHorizontal","_startHorizontal","shiftX","shiftY","sourceSide","horizontal","PolylineRouter","ConnectionEditTool","tryActivate","_p","meta","isActive","ctrlKey","nativeEvent","selectSingle","connectionHandle","handleName","_syncConnectionChanges","getCursor","ConnectionTool","_createConnection","_removeHover","activeConnection","cachedTouchTarget","EmptyTool","noMeta","altKey","shiftKey","PointerTool","eventMap","queryEventMap","applyEventMap","replace","elementOffset$1","TapCapture","domElement","_pressHandler","_press","_releaseHandler","_release","addEventListener","captureNext","cancelCapture","removeEventListener","PaneDimension","forcedEnabled","scrollSize","makeVirtual","virtual","_virtualMin","_virtualMax","virtualSize","outOfBounds","forceEnabled","getSize","getTotal","rescale","silent","scaledTotal","minScale","centerOffset","enabled","PaneDimensions","forcedMinScale","maxScale","newScale","centerCoordinates","fitScale","PaneAxis","dimension","movable","dragMove","dragDelta","resistance","translateAxis","Pane","elastic","dimensions","userEvents","gesturestart","gesture","press","closestAnchor","closest","matches","gesturechange","previousGesture","previousCenter","scaleDelta","coordinates","scaleWith","tagName","touch","skip","Movable","transformOrigin","_saveCoordinates","by","scaleTo","moveAxis","newCoordinates","animationFrame","callback","requestAnimationFrame","Animation","_tickProxy","_tick","_started","done","onEnd","onCancel","Transition","startDate","location","_easeProxy","ease","easeOutExpo","elementEventHandlers","WeakMap","ID","Symbol","on","useCapture","eventHandler","eventFilter","attachedHandler","closestMatchingTarget","currentTarget","defineProperty","guid","eventHandlers","Boolean","addEventListeners","off","handlerId","delete","removeEventListeners","preventDefault$1","PRESS","HOLD","SELECT","START","MOVE","END","CANCEL","TAP","DOUBLETAP","RELEASE","GESTURECHANGE","GESTUREEND","GESTURETAP","THRESHOLD","api","mouse","pointer","DEFAULT_MIN_HOLD","DEFAULT_THRESHOLD","getTouches","touches","originalEvent","pointerId","TouchAxis","invalidZeroEvents","_updateLocationData","startLocation","velocity","timeStamp","timeDelta","initialDelta","client","screen","Touch","touchInfo","threshold","initialTouch","pressEvent","_clicks","supportDoubleTap","_moved","_finished","_holdTimeout","setTimeout","_hold","minHold","_trigger","_tap","_clickTimeout","preventMove","_shouldNotMove","_withinIgnoreThreshold","UserEvents","dispose","_start","endTime","clearTimeout","activeTouches","activeTouchIndex","isMoved","startTime","notify","xDelta","yDelta","withEachUpEvent","downEvents","_maxTouches","multiTouch","allowSelection","captureUpIfMoved","stopPropagation","pressed","_surfaceMoveHandler","_move","_surfaceEndHandler","_end","_elementStartHandler","touchAction","preventDragEvent","_elementDragStartHandler","_elementSelectHandler","_select","surfaceElement","preventIfMovingProxy","preventIfMoving","_isMoved","_destroyed","_disposeAll","_isMultiTouch","touch1","touch2","touchDelta","_apiCall","_maxTouchesReached","which","eventTouches","eventTouch","_eachTouch","methodName","dict","matchingTouch","hasPointerCapture","setPointerCapture","pageX","pageY","clientX","clientY","defaultThreshold","extend","CHANGE","SCROLL","ZoomSnapBack","tapCapture","DragInertia","transition","_moveTo","paneAxis","_snapBack","velocityMultiplier","snapBack","AnimatedScroller","_to","_updateCoordinates","setCoordinates","setCallback","ScrollBar","elementSize","scrollMovable","alwaysVisible","appendChild","paneSize","sizeRatio","display","visibility","hide","defaultScrollerOptions","pullOffset","visibleScrollHints","useNative","mousewheelScrolling","avoidScrolling","pullToRefresh","messages","pullTemplate","releaseTemplate","refreshTemplate","Scroller","_initOptions","hasScrolling","hasNativeScrolling","_native","scrollHeader","scrollElement","fixedContainer","overflow","wrapper","wrapInner","inner","velocityX","velocityY","horizontalSwipe","verticalSwipe","pane","zoomSnapBack","animatedScroller","scrollTo","scrollTop","scrollLeft","_wheelScrollHandler","_wheelScroll","pulled","_initAxis","_wheelEnd","_wheel","_wheelY","_initPullToRefresh","_wheelTimeout","wheelDeltaY","wheelDelta","detail","VERTICAL_AXIS","scrollHeight","scrollWidth","_resize","contentResized","setOptions","reset","_scale","zoomOut","disable","animatedScrollTo","pullHandled","_dragEnd","_paneChange","scrollBar","macOS","_a","ScrollerTool","canvas","_mobileOS","scroller","scrollable","scroll","movableCanvas","virtualScroll","pannable","macCmd","metaKey","hoveredAdorner","scrollPos","_storePan","SelectionTool","multiple","deselect","selector","selectArea","testKey","charCodeAt","toUpperCase","ConnectionEditUnit","redoSource","redoTarget","defaultOptions$1","fromConnector","toConnector","Connection","_initRouter","_sourcePoint","_targetPoint","_setSource","_setTarget","definers","dataMap","_dataMap","fromX","fromY","toX","toY","filterConnectionDataItem","updateConnectionModel","shapeSource","defaultConnector","_removeFromSourceConnector","_clearSourceConnector","_setFromOptions","addCompositeItem","fromPoint","sourceDefiner","_sourceDefiner","shapeTarget","_removeFromTargetConnector","_clearTargetConnector","_setToOptions","toPoint","targetDefiner","_targetDefiner","instance","getShapeById","connectorName","setNewTarget","inactiveItem","_inactiveShapeItems","getByUid","uid","_deferredConnectionUpdates","onActivate","hasVisual","hasTemplate","templateOptions","templateResult","endIdx","startIdx","alignToPath","midIdx","selection","_router","pts","definition","_resolveConnectors","_refreshPath","sourceConnectors","targetConnectors","_resolveAutoConnectors","minNonConflict","minNonConflictSource","minNonConflictTarget","minSource","minTarget","sourceIdx","targetIdx","_testRoutePoints","router","passRoute","exclude","_getRouteExclude","_shapesQuadTree","hitTestRect","_isPointInsideShape","boundsX","boundsY","ToolService","activeTool","_updateHoveredItem","_activateTool","_updateCursor","focus","suspendTracking","updateHovered","resumeTracking","keyDown","toRemove","_triggerRemove","_syncChanges","_destroyToolBar","_discardNewConnection","selectAll","paste","wheel","z","zoomRate","zoomOptions","zoomMin","zoomMax","setTool","tool","addToSelection","newConnection","disabledShape","isNew","selectedConnections","_hitTestItems","_hitTestElements","shapeHit","connectionHit","hitTestShapeConnectors","mainLayer","AddConnectionUnit","AddShapeUnit","CompositeUnit","units","undoUnit","DeleteConnectionUnit","DeleteShapeUnit","PositionAdapter","layoutState","froms","tos","subjects","LayoutUndoUnit","initialState","finalState","_initialState","_finalState","setState","state","ticker","ToBackUnit","initialIndices","_toIndex","ToFrontUnit","UndoRedoService","capacity","begin","composite","commit","execute","_restart","InactiveItem","callbacks","Promise","resolve","activate","InactiveItemsCollection","QuadRoot","_add","_quadNode","_testRect","QuadNode","inBounds","nodeRect","nodeBottomRight","overlapsBounds","inserted","_initChildren","childIdx","shapeIdx","ShapesQuadTree","ROOT_SIZE","boundsChangeHandler","_boundsChange","initRoots","rootMap","rootSize","sectors","getSectors","inRoot","bottomX","xIdx","yIdx","copyDefaultOptions","mainOptions","theme","dataSource","draggable","autoBind","tooltip","format","connectionDefaults","domEvents","splitDiagramElements","outerHeight","includeMargins","heightValue","offsetHeight","getComputedStyle","marginTop","marginBottom","$","A","B","E","F","H","J","K","O","Q","Infinity","curK","rangeIntegerScale","U","V","W","Z","_","__meta__","category","description","depends","hidden","chunk","a0","a1","drawingRect","a2","a3","a4","a5","a6","a7","a8","a9","aA","aB","initialPosition","finalPosition","finalPos","aC","aD","aE","aF","aG","aH","aI","aJ","aK","aL","aM","aN","aO","aP","aQ","aR","aS","aT","userOptions","themeOptions","_clipboard","_connectionsDataMap","_domEvent","_meta","_eventPositions","createToolBar","destroyToolBar","_initTheme","_initElements","_extendLayoutOptions","_initDefaults","_interactionDefaults","_initCanvas","adornerLayer","_createHandlers","pauseMouseHandlers","_createShape","setAttribute","userShapeDefaults","mobile","canvasContainer","viewPort","viewport","Canvas","_wheelHandler","_keydownHandler","_keydown","browser","mobilesafari","_userEvents","fastTap","tap","_dragStart","_drag","_gestureStart","_gestureChange","gestureend","_gestureEnd","doubleTap","_doubleTap","_mouseoverHandler","_mouseover","_mouseoutHandler","_mouseout","_mouseMoveHandler","_mouseMove","_mouseDownHandler","_mouseDown","_mouseUpHandler","_mouseUp","_initResizeObserver","observer","ResizeObserver","entries","_resizeObserver","observe","_destroyResizeObserver","disconnect","_pauseMouseHandlers","focused","ctrlPressed","keyCode","mwDelta","documentToModel","initialCenter","_gesture","_initialCenter","documentToView","_zoom","updateZoom","_getValidZoom","zoomedPoint","_panTransform","_updateAdorners","pointPosition","toolBar","_kendoNode","srcElement","_createOptionElements","shapesLength","_createShapes","_createConnections","_findConnectionTarget","destroyScroller","_destroyGlobalToolBar","ownerDocument","activeElement","offsets","documentElement","scrollContainer","parentNode","preventScroll","load","addConnection","added","removed","_parseBounds","_suspendModelRefresh","_removeItem","_resumeModelRefresh","_shouldRefresh","_suspended","_addConnections","_addConnectionDataItem","_validateConnector","_addDataItems","parentShape","_addDataItemByUid","resolvedOptions","_getDiagramItems","_fixOrdering","bringIntoView","_zoomMainLayer","newPan","alignShapes","val","raw","hideTooltip","_getPan","paddingLeft","paddingRight","elementWidth","paddingTop","paddingBottom","elementHeight","_copyOffset","copied","mapping","_updateCopiedConnection","sourceConnection","di","_containerOffset","containerOffset","getBoundingClientRect","doc","defaultView","scrollX","scrollY","elementOffset","viewToDocument","viewToModel","_transformWithMatrix","_matrixInvert","_matrix","_layerMatrix","layerToModel","_layerMatrixInvert","viewPoint","modelToDocument","_redrawConnections","getShapeByModelId","shapeResult","getShapeByModelUid","_transformMainLayer","_finishPan","NaN","_storeViewMatrix","_storeLayerMatrix","canvasTransform","shapePos","conPos","_addItem","_toolBarClick","_normalizePointZoom","undone","redone","adorners","_refresh","removedConnections","_removeShapeDataItem","_removeShape","_removeConnectionDataItem","_removeConnection","_removeShapeConnections","exportDOMVisual","scrollOffset","viewRect","clipPath","fromRect","wrap","clipWrap","clip","exportVisual","aU","aV","aW","aX","aa","none","arrowStart","filledCircle","arrowEnd","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","am","an","ao","ap","aq","ar","as","at","au","av","ay","az","mean","deviation","log"],"mappings":"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","file":"kendo.diagram-common.cmn.chunk.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('kendo.drawing.cmn.chunk.js'), require('kendo.common.cmn.chunk.js')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'kendo.drawing.cmn.chunk', 'kendo.common.cmn.chunk'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.kendo = global.kendo || {}, global.kendo._globals = global.kendo._globals || {}, global.kendo._globals.DiagramCommonCmnChunk = {}), global.kendo._globals.DrawingCmnChunk, global.kendo._globals.CommonCmnChunk));\n})(this, (function (exports, kendo_drawing_cmn_chunk_js, kendo_common_cmn_chunk_js) {\n    const __meta__ = {\n        id: \"diagram-common.cmn.chunk\",\n        name: \"DiagramCommonCmnChunk\",\n        category: \"web\",\n        description: \"A reusable outputed chunk of code\",\n        depends: ['drawing.cmn.chunk', 'common.cmn.chunk'],\n        hidden: true,\n        chunk: true,\n        \n    };\n\n    const WIDTH = 'width';\n    const HEIGHT = 'height';\n    const X = 'x';\n    const Y = 'y';\n    const FULL_CIRCLE_ANGLE = 360;\n    const TRANSPARENT = 'transparent';\n    const START$1 = 'start';\n    const END$1 = 'end';\n    /**\n     * @deprecated Use `MarkerType` instead.\n     */\n    const Markers = {\n        none: 'none',\n        arrowStart: 'ArrowStart',\n        filledCircle: 'FilledCircle',\n        arrowEnd: 'ArrowEnd'\n    };\n    var MarkerType;\n    (function (MarkerType) {\n        MarkerType[\"None\"] = \"none\";\n        MarkerType[\"ArrowStart\"] = \"ArrowStart\";\n        MarkerType[\"FilledCircle\"] = \"FilledCircle\";\n        MarkerType[\"ArrowEnd\"] = \"ArrowEnd\";\n    })(MarkerType || (MarkerType = {}));\n    ;\n    const DEG_TO_RAD = Math.PI / 180;\n    const EPSILON = 1e-06;\n    const CHANGE$1 = 'change';\n    const Cursors = {\n        arrow: 'default',\n        grip: 'pointer',\n        cross: 'pointer',\n        add: 'pointer',\n        move: 'move',\n        select: 'pointer',\n        south: 's-resize',\n        east: 'e-resize',\n        west: 'w-resize',\n        north: 'n-resize',\n        rowresize: 'row-resize',\n        colresize: 'col-resize'\n    };\n    const HIT_TEST_DISTANCE = 10, AUTO = 'Auto', TOP = 'Top', RIGHT = 'Right', LEFT = 'Left', BOTTOM = 'Bottom', DEFAULT_SNAP_SIZE = 10, DEFAULT_SNAP_ANGLE = 10, DRAG_START = 'dragStart', DRAG = 'drag', DRAG_END = 'dragEnd', ITEMROTATE = 'itemRotate', ITEMBOUNDSCHANGE = 'itemBoundsChange', MIN_SNAP_SIZE = 5, MIN_SNAP_ANGLE = 5, MOUSE_ENTER = 'mouseEnter', MOUSE_LEAVE = 'mouseLeave', ZOOM_START = 'zoomStart', ZOOM_END = 'zoomEnd', SCROLL_MIN = -20000, SCROLL_MAX = 20000, FRICTION$1 = 0.90, FRICTION_MOBILE = 0.93, VELOCITY_MULTIPLIER$1 = 5, PAN = 'pan', ROTATED = 'rotated', SOURCE = 'source', TARGET = 'target', HANDLE_NAMES = {\n        '-1': SOURCE,\n        '1': TARGET\n    };\n    const ConnectionEditing = 'Connection Editing';\n    const NS = '.kendoDiagram', CASCADING = 'cascading', CLICK = 'click', ERROR = 'error', MAXINT = 9007199254740992, SELECT$1 = 'select', NONE = 'none', DEFAULT_CANVAS_WIDTH = 600, DEFAULT_CANVAS_HEIGHT = 600, DEFAULT_SHAPE_TYPE = 'rectangle', DEFAULT_SHAPE_WIDTH = 100, DEFAULT_SHAPE_HEIGHT = 100, DEFAULT_SHAPE_MINWIDTH = 20, DEFAULT_SHAPE_MINHEIGHT = 20, DEFAULT_SHAPE_POSITION = 0, DEFAULT_CONNECTION_BACKGROUND = 'Yellow', MAX_VALUE = Number.MAX_VALUE, MIN_VALUE = -Number.MAX_VALUE, ABSOLUTE = 'absolute', TRANSFORMED = 'transformed', MOUSEWHEEL_NS = 'DOMMouseScroll' + NS + ' mousewheel' + NS, MOBILE_ZOOM_RATE = 0.05, MOBILE_PAN_DISTANCE = 5, CONNECTION_CONTENT_OFFSET = 5;\n\n    const isNearZero = (value) => Math.abs(value) < EPSILON;\n    const isDefined = (obj) => typeof obj !== 'undefined';\n    const defined = isDefined;\n    const isFunction$1 = (obj) => typeof obj === 'function';\n    const isUndefined = (obj) => typeof obj === 'undefined' || obj === null;\n    /**\n     * Returns whether the given object is an object or a value.\n     */\n    const isObject = (obj) => obj === Object(obj);\n    /**\n     * Returns whether the object has a property with the given name.\n     */\n    const has = (obj, key) => Object.hasOwnProperty.call(obj, key);\n    /**\n     * Returns whether the given object is a string.\n     */\n    const isString$1 = (obj) => {\n        return Object.prototype.toString.call(obj) === '[object String]';\n    };\n    const isBoolean = (obj) => {\n        return Object.prototype.toString.call(obj) === '[object Boolean]';\n    };\n    const isType = (obj, type) => {\n        return Object.prototype.toString.call(obj) === '[object ' + type + ']';\n    };\n    /**\n     * Returns whether the given object is a number.\n     */\n    const isNumber = (obj) => !isNaN(parseFloat(obj)) && isFinite(obj);\n    /**\n     * Return whether the given object (array or dictionary).\n     */\n    const isEmpty = (obj) => {\n        if (obj === null) {\n            return true;\n        }\n        if (Array.isArray(obj) || isString$1(obj)) {\n            return obj.length === 0;\n        }\n        for (const key in obj) {\n            if (has(obj, key)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    const simpleExtend = (destination, source) => {\n        if (!isObject(source)) {\n            return;\n        }\n        for (const name in source) {\n            if (name) {\n                destination[name] = source[name];\n            }\n        }\n    };\n    /**\n     * Returns an array of the specified size and with each entry set to the given value.\n     *\n     * @param size\n     * @param value\n     * @returns {Array}\n     */\n    const initArray = (size, value) => {\n        const array = [];\n        for (let i = 0; i < size; ++i) {\n            array[i] = value;\n        }\n        return array;\n    };\n    const serializePoints = (points) => {\n        const res = [];\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            res.push(p.x + ';' + p.y);\n        }\n        return res.join(';');\n    };\n    const deserializePoints = (s) => {\n        const v = s.split(';');\n        const points = [];\n        if (v.length % 2 !== 0) {\n            throw new Error('Not an array of points.');\n        }\n        for (let i = 0; i < v.length; i += 2) {\n            points.push({\n                x: parseInt(v[i], 10),\n                y: parseInt(v[i + 1], 10)\n            });\n        }\n        return points;\n    };\n    /**\n     * Returns an integer within the given bounds.\n     *\n     * @param lower The inclusive lower bound.\n     * @param upper The exclusive upper bound.\n     * @returns {number}\n     */\n    const randomInteger = (lower, upper) => {\n        const random = Math.floor(Math.random() * upper) + lower;\n        return parseInt(random.toString(), 10);\n    };\n    /*\n     Depth-first traversal of the given node.\n     */\n    const DFT = (el, func) => {\n        func(el);\n        if (el.childNodes) {\n            for (let i = 0; i < el.childNodes.length; i++) {\n                const item = el.childNodes[i];\n                DFT(item, func);\n            }\n        }\n    };\n    /*\n     Returns the angle in degrees for the given matrix\n     */\n    const getMatrixAngle = (m) => {\n        if (m === null || m.d === 0) {\n            return 0;\n        }\n        return Math.atan2(m.b, m.d) * 180 / Math.PI;\n    };\n    /*\n     Returns the scaling factors for the given matrix.\n     */\n    const getMatrixScaling = (m) => {\n        const sX = Math.sqrt(m.a * m.a + m.c * m.c);\n        const sY = Math.sqrt(m.b * m.b + m.d * m.d);\n        return [sX, sY];\n    };\n    const findRadian = (start, end) => {\n        if (start === end) {\n            return 0;\n        }\n        const sngXComp = end.x - start.x;\n        const sngYComp = start.y - end.y;\n        const atan = Math.atan(sngXComp / sngYComp);\n        if (sngYComp >= 0) {\n            return sngXComp < 0 ? atan + (2 * Math.PI) : atan;\n        }\n        return atan + Math.PI;\n    };\n    const sign = (num) => {\n        return num ? num < 0 ? -1 : 1 : 0;\n    };\n    const findAngle = (center, end) => {\n        return findRadian(center, end) * 180 / Math.PI;\n    };\n    const forEach = (arr, iterator, thisRef) => {\n        for (let i = 0; i < arr.length; i++) {\n            iterator.call(thisRef, arr[i], i, arr);\n        }\n    };\n    const getAny = (arr, predicate) => {\n        for (let i = 0; i < arr.length; ++i) {\n            if (predicate(arr[i])) {\n                return arr[i];\n            }\n        }\n        return null;\n    };\n    const remove = (arr, what) => {\n        let ax = arr.indexOf(what);\n        while (ax !== -1) {\n            arr.splice(ax, 1);\n            ax = arr.indexOf(what);\n        }\n        return arr;\n    };\n    const contains = (arr, obj) => {\n        return (arr || []).includes(obj);\n    };\n    const indexOf = (arr, what) => {\n        return arr.indexOf(what);\n    };\n    const inArray = (what, arr) => {\n        return arr.indexOf(what);\n    };\n    const grep$1 = (arr, predicate) => arr.filter(predicate);\n    const fold = (list, iterator, acc, context) => {\n        let initial = acc !== undefined;\n        for (let i = 0; i < list.length; i++) {\n            const value = list[i];\n            if (!initial) {\n                acc = value;\n                initial = true;\n            }\n            else {\n                acc = iterator.call(context, acc, value, i, list);\n            }\n        }\n        if (!initial) {\n            throw new Error('Reduce of empty array with no initial value');\n        }\n        return acc;\n    };\n    const find = (arr, iterator, context) => {\n        return arr.find(iterator.bind(context)) || undefined;\n    };\n    const first = (arr, constraint, context) => {\n        if (arr.length === 0) {\n            return null;\n        }\n        if (isUndefined(constraint)) {\n            return arr[0];\n        }\n        return find(arr, constraint, context);\n    };\n    /**\n     * Inserts the given element at the specified position and returns the result.\n     */\n    const insert = (arr, element, position) => {\n        arr.splice(position, 0, element);\n        return arr;\n    };\n    const all = (arr, iterator, context) => {\n        let result = true;\n        let value;\n        for (let i = 0; i < arr.length; i++) {\n            value = arr[i];\n            result = result && iterator.call(context, value, i, arr);\n            if (!result) {\n                break;\n            }\n        }\n        return result;\n    };\n    const clear = (arr) => {\n        arr.splice(0, arr.length);\n    };\n    const bisort = (a, b, sortfunc) => {\n        if (isUndefined(a)) {\n            throw new Error('First array is not specified.');\n        }\n        if (isUndefined(b)) {\n            throw new Error('Second array is not specified.');\n        }\n        if (a.length !== b.length) {\n            throw new Error('The two arrays should have equal length');\n        }\n        const points = [];\n        for (let i = 0; i < a.length; i++) {\n            points.push({ x: a[i], y: b[i] });\n        }\n        if (isUndefined(sortfunc)) {\n            points.sort((m, n) => m.x - n.x);\n        }\n        else {\n            points.sort((m, n) => sortfunc(m.x, n.x));\n        }\n        clear(a);\n        clear(b);\n        for (let i = 0; i < points.length; i++) {\n            a.push(points[i].x);\n            b.push(points[i].y);\n        }\n    };\n    const addRange = (arr, range) => {\n        arr.push(...range);\n    };\n    const noop$1 = () => { };\n\n    const STRING = 'string';\n    const FUNCTION = 'function';\n    const preventDefault$2 = function () {\n        this._defaultPrevented = true;\n    };\n    const isDefaultPrevented = function () {\n        return this._defaultPrevented === true;\n    };\n    /** @hidden */\n    class Observable {\n        /**\n         * Creates a new Observable instance.\n         * Initializes the options, events array, and internal event handlers storage.\n         */\n        constructor() {\n            this.options = {};\n            this.events = [];\n            this._events = {};\n        }\n        /**\n         * Destroys the observable instance and removes all event handlers.\n         * This method should be called when the observable is no longer needed to prevent memory leaks.\n         */\n        destroy() {\n            this.unbind();\n        }\n        /**\n         * Binds event handlers to one or more events.\n         * @param event The event name(s) to bind to, or an object mapping event names to handlers\n         * @param handlers The event handler(s) to bind. Can be a function or an object mapping event names to handlers\n         * @param one If true, the handler will be executed only once and then automatically unbound\n         * @returns The Observable instance for method chaining\n         */\n        bind(event, handlers, one) {\n            if (!handlers && isObject(event) && !Array.isArray(event)) {\n                for (const name in event) {\n                    if (event[name]) {\n                        this.bind(name, event[name]);\n                    }\n                }\n                return this;\n            }\n            const eventNames = typeof event === STRING ? [event] : event, handlersIsFunction = typeof handlers === FUNCTION;\n            let original, handler;\n            for (let idx = 0, length = eventNames.length; idx < length; idx++) {\n                const eventName = eventNames[idx];\n                handler = handlersIsFunction ? handlers : handlers[eventName];\n                if (handler) {\n                    if (one) {\n                        original = handler;\n                        handler = (...args) => {\n                            this.unbind(eventName, handler);\n                            original.apply(this, args);\n                        };\n                        handler.original = original;\n                    }\n                    this._events[eventName] = this._events[eventName] || [];\n                    this._events[eventName].push(handler);\n                }\n            }\n            return this;\n        }\n        /**\n         * Binds event handlers that will be executed only once.\n         * After execution, the handlers are automatically unbound.\n         * @param eventNames The event name(s) to bind to\n         * @param handlers The event handler(s) to bind\n         * @returns The Observable instance for method chaining\n         */\n        one(eventNames, handlers) {\n            return this.bind(eventNames, handlers, true);\n        }\n        /**\n         * Binds event handlers to be executed first (prepends to the handlers list).\n         * These handlers will be called before any previously bound handlers for the same event.\n         * @param eventName The event name(s) to bind to\n         * @param handlers The event handler(s) to bind\n         * @returns The Observable instance for method chaining\n         */\n        first(eventName, handlers) {\n            const eventNames = typeof eventName === STRING ? [String(eventName)] : Array.from(eventName), handlersIsFunction = typeof handlers === FUNCTION;\n            let handler;\n            for (let idx = 0, length = eventNames.length; idx < length; idx++) {\n                const curName = eventNames[idx];\n                handler = handlersIsFunction ? handlers : handlers[curName];\n                if (handler) {\n                    this._events[curName] = this._events[curName] || [];\n                    this._events[curName].unshift(handler);\n                }\n            }\n            return this;\n        }\n        /**\n         * Triggers an event, calling all bound handlers for that event.\n         * @param eventName The name of the event to trigger\n         * @param eventArgs Optional event arguments to pass to the handlers\n         * @returns True if any handler called preventDefault(), false otherwise\n         */\n        trigger(eventName, eventArgs) {\n            let events = this._events[eventName];\n            if (events) {\n                const e = eventArgs || {};\n                e.sender = this;\n                e._defaultPrevented = false;\n                e.preventDefault = preventDefault$2;\n                e.isDefaultPrevented = isDefaultPrevented;\n                events = events.slice();\n                for (let idx = 0, length = events.length; idx < length; idx++) {\n                    events[idx].call(this, e);\n                }\n                return e._defaultPrevented === true;\n            }\n            return false;\n        }\n        /**\n         * Removes event handlers from events.\n         * @param eventName The event name to unbind from. If undefined, all events are unbound\n         * @param handler The specific handler to remove. If undefined, all handlers for the event are removed\n         * @returns The Observable instance for method chaining\n         */\n        unbind(eventName, handler) {\n            const events = this._events[eventName];\n            if (eventName === undefined) {\n                this._events = {};\n            }\n            else if (events) {\n                if (handler) {\n                    for (let idx = events.length - 1; idx >= 0; idx--) {\n                        if (events[idx] === handler || events[idx].original === handler) {\n                            events.splice(idx, 1);\n                        }\n                    }\n                }\n                else {\n                    this._events[eventName] = [];\n                }\n            }\n            return this;\n        }\n        /** @hidden */\n        _setEvents(options) {\n            const length = (this.events || []).length;\n            for (let idx = 0; idx < length; idx++) {\n                const name = this.events[idx];\n                if (this.options[name] && options[name]) {\n                    this.unbind(name, this.options[name]);\n                    if (this._events && this._events[name]) {\n                        delete this._events[name];\n                    }\n                }\n            }\n            this.bind(this.events, options);\n        }\n    }\n\n    var Utils$1 = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        DFT: DFT,\n        Observable: Observable,\n        addRange: addRange,\n        all: all,\n        bisort: bisort,\n        clear: clear,\n        contains: contains,\n        defined: defined,\n        deserializePoints: deserializePoints,\n        find: find,\n        findAngle: findAngle,\n        findRadian: findRadian,\n        first: first,\n        fold: fold,\n        forEach: forEach,\n        getAny: getAny,\n        getMatrixAngle: getMatrixAngle,\n        getMatrixScaling: getMatrixScaling,\n        grep: grep$1,\n        has: has,\n        inArray: inArray,\n        indexOf: indexOf,\n        initArray: initArray,\n        insert: insert,\n        isBoolean: isBoolean,\n        isDefined: isDefined,\n        isEmpty: isEmpty,\n        isFunction: isFunction$1,\n        isNearZero: isNearZero,\n        isNumber: isNumber,\n        isObject: isObject,\n        isString: isString$1,\n        isType: isType,\n        isUndefined: isUndefined,\n        noop: noop$1,\n        randomInteger: randomInteger,\n        remove: remove,\n        serializePoints: serializePoints,\n        sign: sign,\n        simpleExtend: simpleExtend\n    });\n\n    /**\n     * The Range defines an array of equally separated numbers.\n     *\n     * @param start The start-value of the Range.\n     * @param stop The end-value of the Range.\n     * @param step The separation between the values (default:1).\n     * @returns {Array}\n     */\n    function Range(start, stop, step) {\n        if (typeof start == 'undefined' || typeof stop == 'undefined') {\n            return [];\n        }\n        if (step && sign(stop - start) !== sign(step)) {\n            throw new Error('The sign of the increment should allow to reach the stop-value.');\n        }\n        step = step || 1;\n        start = start || 0;\n        stop = stop || start;\n        if ((stop - start) / step === Infinity) {\n            throw new Error('Infinite range defined.');\n        }\n        const range = [];\n        let i = -1, j;\n        function rangeIntegerScale(x) {\n            let curK = 1;\n            while (x * curK % 1) {\n                curK *= 10;\n            }\n            return curK;\n        }\n        const k = rangeIntegerScale(Math.abs(step));\n        start *= k;\n        stop *= k;\n        step *= k;\n        if (start > stop && step > 0) {\n            step = -step;\n        }\n        if (step < 0) {\n            while ((j = start + step * ++i) >= stop) {\n                range.push(j / k);\n            }\n        }\n        else {\n            while ((j = start + step * ++i) <= stop) {\n                range.push(j / k);\n            }\n        }\n        return range;\n    }\n    ;\n\n    const Easing = {\n        easeInOut(pos) {\n            return ((-Math.cos(pos * Math.PI) / 2) + 0.5);\n        }\n    };\n    /**\n     * An animation ticker driving an adapter which sets a particular\n     * property in function of the tick.\n     *\n     * @type {*}\n     */\n    class Ticker {\n        constructor() {\n            this.adapters = [];\n            this.target = 0;\n            this.tick = 0;\n            this.interval = 20;\n            this.duration = 800;\n            this.lastTime = null;\n            this.handlers = [];\n            this.timerDelegate = () => { };\n            this.intervalId = null;\n            this.caller = null;\n            this.timerDelegate = () => {\n                this.onTimerEvent();\n            };\n        }\n        ;\n        addAdapter(a) {\n            this.adapters.push(a);\n        }\n        ;\n        onComplete(handler) {\n            this.handlers.push(handler);\n        }\n        ;\n        removeHandler(handler) {\n            this.handlers = this.handlers.filter((h) => {\n                return h !== handler;\n            });\n        }\n        ;\n        trigger() {\n            if (this.handlers) {\n                forEach(this.handlers, (h) => {\n                    return h.call(this.caller !== null ? this.caller : this);\n                });\n            }\n        }\n        ;\n        onStep() {\n        }\n        ;\n        seekTo(to) {\n            this.seekFromTo(this.tick, to);\n        }\n        ;\n        seekFromTo(from, to) {\n            this.target = Math.max(0, Math.min(1, to));\n            this.tick = Math.max(0, Math.min(1, from));\n            this.lastTime = new Date().getTime();\n            if (!this.intervalId) {\n                this.intervalId = window.setInterval(this.timerDelegate, this.interval);\n            }\n        }\n        ;\n        stop() {\n            if (this.intervalId) {\n                window.clearInterval(this.intervalId);\n                this.intervalId = null;\n                // this.trigger.call(this);\n                this.trigger();\n                // this.next();\n            }\n        }\n        ;\n        play(origin) {\n            if (this.adapters.length === 0) {\n                return;\n            }\n            if (origin !== null) {\n                this.caller = origin;\n            }\n            this.initState();\n            this.seekFromTo(0, 1);\n        }\n        ;\n        reverse() {\n            this.seekFromTo(1, 0);\n        }\n        ;\n        initState() {\n            if (this.adapters.length === 0) {\n                return;\n            }\n            for (let i = 0; i < this.adapters.length; i++) {\n                this.adapters[i].initState();\n            }\n        }\n        ;\n        propagate() {\n            const value = Easing.easeInOut(this.tick);\n            for (let i = 0; i < this.adapters.length; i++) {\n                this.adapters[i].update(value);\n            }\n        }\n        ;\n        onTimerEvent() {\n            const now = new Date().getTime();\n            const timePassed = now - this.lastTime;\n            this.lastTime = now;\n            const movement = (timePassed / this.duration) * (this.tick < this.target ? 1 : -1);\n            if (Math.abs(movement) >= Math.abs(this.tick - this.target)) {\n                this.tick = this.target;\n            }\n            else {\n                this.tick += movement;\n            }\n            try {\n                this.propagate();\n            }\n            finally {\n                this.onStep.call(this);\n                if (this.target === this.tick) {\n                    this.stop();\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a random identifier which can be used as an ID of objects, eventually augmented with a prefix.\n     *\n     * @returns {string}\n     */\n    function randomId(length) {\n        if (isUndefined(length)) {\n            length = 10;\n        }\n        // old version return Math.floor((1 + Math.random()) * 0x1000000).toString(16).substring(1);\n        let result = '';\n        const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n        for (let i = length; i > 0; --i) {\n            result += chars.charAt(Math.round(Math.random() * (chars.length - 1)));\n        }\n        return result;\n    }\n\n    /**\n     * Represents a collection of key-value pairs that are organized based on the hash code of the key.\n     * _buckets[hashId] = {key: key, value:...}\n     * Important: do not use the standard Array access method, use the get/set methods instead.\n     * See http://en.wikipedia.org/wiki/Hash_table\n     */\n    class HashTable {\n        constructor() {\n            this._buckets = {};\n            this.length = 0;\n            this._stringsMap = new Map();\n            this._stringsCounter = 0;\n        }\n        /**\n         * Adds the literal object with the given key (of the form {key: key,....}).\n         */\n        add(key, value) {\n            const obj = this._createGetBucket(key);\n            if (isDefined(value)) {\n                obj.value = value;\n            }\n            return obj;\n        }\n        /**\n         * Gets the literal object with the given key.\n         */\n        get(key) {\n            if (this._bucketExists(key)) {\n                return this._createGetBucket(key);\n            }\n            return null;\n        }\n        /**\n         * Set the key-value pair.\n         *\n         * @param key The key of the entry.\n         * @param value The value to set. If the key already exists the value will be overwritten.\n         */\n        set(key, value) {\n            this.add(key, value);\n        }\n        /**\n         * Determines whether the HashTable contains a specific key.\n         */\n        containsKey(key) {\n            return this._bucketExists(key);\n        }\n        /**\n         * Removes the element with the specified key from the hashtable.\n         * Returns the removed bucket.\n         */\n        remove(key) {\n            if (this._bucketExists(key)) {\n                const hashId = this._hash(key);\n                delete this._buckets[hashId];\n                this.length--;\n                return key;\n            }\n        }\n        /**\n         * Foreach with an iterator working on the key-value pairs.\n         *\n         * @param func\n         */\n        forEach(func) {\n            const hashes = this._hashes();\n            for (let i = 0, len = hashes.length; i < len; i++) {\n                const hash = hashes[i];\n                const bucket = this._buckets[hash];\n                if (isUndefined(bucket)) {\n                    continue;\n                }\n                func(bucket);\n            }\n        }\n        /**\n         * Returns a (shallow) clone of the current HashTable.\n         *\n         * @returns {HashTable}\n         */\n        clone() {\n            const ht = new HashTable();\n            const hashes = this._hashes();\n            for (let i = 0, len = hashes.length; i < len; i++) {\n                const hash = hashes[i];\n                const bucket = this._buckets[hash];\n                if (isUndefined(bucket)) {\n                    continue;\n                }\n                ht.add(bucket.key, bucket.value);\n            }\n            return ht;\n        }\n        /**\n         * Returns the hashes of the buckets.\n         *\n         * @returns {Array}\n         * @private\n         */\n        _hashes() {\n            const hashes = [];\n            for (const hash in this._buckets) {\n                if (Object.prototype.hasOwnProperty.call(this._buckets, hash)) {\n                    hashes.push(hash);\n                }\n            }\n            return hashes;\n        }\n        _bucketExists(key) {\n            const hashId = this._hash(key);\n            return isDefined(this._buckets[hashId]);\n        }\n        /**\n         * Returns-adds the createGetBucket with the given key. If not present it will\n         * be created and returned.\n         * A createGetBucket is a literal object of the form {key: key, ...}.\n         */\n        _createGetBucket(key) {\n            const hashId = this._hash(key);\n            let bucket = this._buckets[hashId];\n            if (isUndefined(bucket)) {\n                bucket = { key: key };\n                this._buckets[hashId] = bucket;\n                this.length++;\n            }\n            return bucket;\n        }\n        /**\n         * Hashing of the given key.\n         */\n        _hash(key) {\n            if (isString$1(key) || isNumber(key)) {\n                return this._hashString(String(key));\n            }\n            if (isObject(key)) {\n                return this._objectHashId(key);\n            }\n            throw new Error('Unsupported key type.');\n        }\n        /**\n         * Hashing of a string.\n         */\n        _hashString(s) {\n            let result = 0;\n            if (s.length === 0) {\n                return result;\n            }\n            if (this._stringsMap.has(s)) {\n                return this._stringsMap.get(s);\n            }\n            this._stringsCounter++;\n            this._stringsMap.set(s, this._stringsCounter);\n            result = this._stringsCounter;\n            return result;\n        }\n        /**\n         * Returns the unique identifier for an object. This is automatically assigned and add on the object.\n         */\n        _objectHashId(key) {\n            let id = key._hashId;\n            if (isUndefined(id)) {\n                id = randomId();\n                key._hashId = id;\n            }\n            return id;\n        }\n    }\n\n    /**\n     * Represents a collection of key-value pairs.\n     * Important: do not use the standard Array access method, use the get/Set methods instead.\n     */\n    class Dictionary extends Observable {\n        /**\n         * Initializes a new instance of the Dictionary class.\n         *\n         * @param dictionary Loads the content of the given dictionary into this new one.\n         */\n        constructor(dictionary) {\n            super();\n            this._hashTable = new HashTable();\n            this.length = 0;\n            if (isDefined(dictionary)) {\n                if (Array.isArray(dictionary)) {\n                    for (let i = 0; i < dictionary.length; i++) {\n                        this.add(dictionary[i]);\n                    }\n                }\n                else {\n                    dictionary.forEach(function (k, v) {\n                        this.add(k, v);\n                    }, this);\n                }\n            }\n        }\n        /**\n         * Adds a key-value to the dictionary.\n         * If the key already exists this will assign the given value to the existing entry.\n         */\n        add(key, value) {\n            let entry = this._hashTable.get(key);\n            if (!entry) {\n                entry = this._hashTable.add(key);\n                this.length++;\n                this.trigger('changed');\n            }\n            entry.value = value;\n        }\n        /**\n         * Set the key-value pair.\n         *\n         * @param key The key of the entry.\n         * @param value The value to set. If the key already exists the value will be overwritten.\n         */\n        set(key, value) {\n            this.add(key, value);\n        }\n        /**\n         * Gets the value associated with the given key in the dictionary.\n         */\n        get(key) {\n            const entry = this._hashTable.get(key);\n            if (entry) {\n                return entry.value;\n            }\n            throw new Error('Cannot find key ' + key);\n        }\n        /**\n         * Returns whether the dictionary contains the given key.\n         */\n        containsKey(key) {\n            return this._hashTable.containsKey(key);\n        }\n        /**\n         * Removes the element with the specified key from the dictionary.\n         */\n        remove(key) {\n            if (this.containsKey(key)) {\n                this.trigger('changed');\n                this.length--;\n                return this._hashTable.remove(key);\n            }\n        }\n        /**\n         * The functional gets the key and value as parameters.\n         */\n        forEach(func, thisRef) {\n            this._hashTable.forEach(function (entry) {\n                func.call(thisRef, entry.key, entry.value);\n            });\n        }\n        /**\n         * Same as forEach except that only the value is passed to the functional.\n         */\n        forEachValue(func, thisRef) {\n            this._hashTable.forEach(function (entry) {\n                func.call(thisRef, entry.value);\n            });\n        }\n        /**\n         * Calls a defined callback function for each key in the dictionary.\n         */\n        forEachKey(func, thisRef) {\n            this._hashTable.forEach(function (entry) {\n                func.call(thisRef, entry.key);\n            });\n        }\n        /**\n         * Gets an array with all keys in the dictionary.\n         */\n        keys() {\n            const keys = [];\n            this.forEachKey(function (key) {\n                keys.push(key);\n            });\n            return keys;\n        }\n    }\n\n    const Geometry = {\n        /**\n         * Returns the squared distance to the line defined by the two given Points.\n         *\n         * @param p An arbitrary Point.\n         * @param a An endpoint of the line or segment.\n         * @param b The complementary endpoint of the line or segment.\n         */\n        _distanceToLineSquared: function (p, a, b) {\n            function d2(pt1, pt2) {\n                return (pt1.x - pt2.x) * (pt1.x - pt2.x) + (pt1.y - pt2.y) * (pt1.y - pt2.y);\n            }\n            if (a === b) { // returns the distance of p to a\n                return d2(p, a);\n            }\n            const vx = b.x - a.x, vy = b.y - a.y;\n            let dot = (p.x - a.x) * vx + (p.y - a.y) * vy;\n            if (dot < 0) {\n                return d2(a, p); // sits on side of a\n            }\n            dot = (b.x - p.x) * vx + (b.y - p.y) * vy;\n            if (dot < 0) {\n                return d2(b, p); // sits on side of b\n            }\n            // regular case, use crossproduct to get the sine out\n            dot = (b.x - p.x) * vy - (b.y - p.y) * vx;\n            return dot * dot / (vx * vx + vy * vy);\n        },\n        /**\n         * Returns the distance to the line defined by the two given Points.\n         *\n         * @param p An arbitrary Point.\n         * @param a An endpoint of the line or segment.\n         * @param b The complementary endpoint of the line or segment.\n         */\n        distanceToLine: function (p, a, b) {\n            return Math.sqrt(this._distanceToLineSquared(p, a, b));\n        },\n        /**\n         * Returns the distance of the given points to the polyline defined by the points.\n         *\n         * @param p An arbitrary point.\n         * @param points The points defining the polyline.\n         * @returns {Number}\n         */\n        distanceToPolyline: function (p, points) {\n            let minimum = Number.MAX_VALUE;\n            if (isUndefined(points) || points.length === 0) {\n                return Number.MAX_VALUE;\n            }\n            for (let s = 0; s < points.length - 1; s++) {\n                const p1 = points[s];\n                const p2 = points[s + 1];\n                const d = this._distanceToLineSquared(p, p1, p2);\n                if (d < minimum) {\n                    minimum = d;\n                }\n            }\n            return Math.sqrt(minimum);\n        }\n    };\n\n    class Polar {\n        constructor(r, a) {\n            this.r = r;\n            this.angle = a;\n        }\n    }\n\n    const HITTESTAREA = 3;\n    /**\n     * Represents a 2D point with x and y coordinates.\n     * Extends the Kendo Drawing geometry Point class with additional utility methods.\n     */\n    class Point extends kendo_drawing_cmn_chunk_js.P {\n        /**\n         * Creates a new Point instance.\n         * @param x The x-coordinate of the point (defaults to 0)\n         * @param y The y-coordinate of the point (defaults to 0)\n         */\n        constructor(x, y) {\n            super(x, y);\n        }\n        /**\n         * Creates a copy of this point.\n         * @returns A new Point instance with the same coordinates\n         */\n        clone() {\n            return new Point(this.x, this.y);\n        }\n        /**\n         * Adds another point to this point.\n         * @param p The point to add\n         * @returns A new Point representing the sum of the two points\n         */\n        plus(p) {\n            return new Point(this.x + p.x, this.y + p.y);\n        }\n        /**\n         * Subtracts another point from this point.\n         * @param p The point to subtract\n         * @returns A new Point representing the difference\n         */\n        minus(p) {\n            return new Point(this.x - p.x, this.y - p.y);\n        }\n        /**\n         * Creates a new point offset by the specified value in both x and y directions.\n         * @param value The offset value to subtract from both coordinates\n         * @returns A new Point offset by the specified amount\n         */\n        offset(value) {\n            return new Point(this.x - value, this.y - value);\n        }\n        /**\n         * Multiplies this point by a scalar value.\n         * @param s The scalar multiplier\n         * @returns A new Point with coordinates multiplied by the scalar\n         */\n        times(s) {\n            return new Point(this.x * s, this.y * s);\n        }\n        /**\n         * Returns a normalized version of this point (unit vector).\n         * @returns A new Point with length 1 in the same direction, or origin if length is 0\n         */\n        normalize() {\n            if (this.length() === 0) {\n                return new Point();\n            }\n            return this.times(1 / this.length());\n        }\n        /**\n         * Calculates the length (magnitude) of this point vector.\n         * @returns The distance from origin to this point\n         */\n        length() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        }\n        /**\n         * Returns a string representation of this point.\n         * @returns A string in the format \"(x,y)\"\n         */\n        toString() {\n            return '(' + this.x + ',' + this.y + ')';\n        }\n        /**\n         * Calculates the squared length of this point vector.\n         * More efficient than length() when only comparing distances.\n         * @returns The squared distance from origin to this point\n         */\n        lengthSquared() {\n            return (this.x * this.x + this.y * this.y);\n        }\n        /**\n         * Calculates the midpoint between two points.\n         * @param p The first point\n         * @param q The second point\n         * @returns A new Point representing the midpoint between p and q\n         */\n        middleOf(p, q) {\n            return new Point(q.x - p.x, q.y - p.y).times(0.5).plus(p);\n        }\n        /**\n         * Converts this point to polar coordinates.\n         * @param useDegrees Whether to return angle in degrees (true) or radians (false)\n         * @returns A Polar object with radius and angle\n         */\n        toPolar(useDegrees) {\n            let factor = 1;\n            if (useDegrees) {\n                factor = 180 / Math.PI;\n            }\n            const a = Math.atan2(Math.abs(this.y), Math.abs(this.x));\n            const halfpi = Math.PI / 2;\n            const len = this.length();\n            if (this.x === 0) {\n                // note that the angle goes down and not the usual mathematical convention\n                if (this.y === 0) {\n                    return new Polar(0, 0);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * halfpi);\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * 3 * halfpi);\n                }\n            }\n            else if (this.x > 0) {\n                if (this.y === 0) {\n                    return new Polar(len, 0);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * a);\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * (4 * halfpi - a));\n                }\n            }\n            else {\n                if (this.y === 0) {\n                    return new Polar(len, 2 * halfpi);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * (2 * halfpi - a));\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * (2 * halfpi + a));\n                }\n            }\n        }\n        /**\n         * Determines if this point lies on the line segment between two other points.\n         * @param from The starting point of the line segment\n         * @param to The ending point of the line segment\n         * @returns True if this point is on the line segment, false otherwise\n         */\n        isOnLine(from, to) {\n            if (from.x > to.x) { // from must be the leftmost point\n                const temp = to;\n                to = from;\n                from = temp;\n            }\n            const r1 = new Rect(from.x, from.y).inflate(HITTESTAREA, HITTESTAREA), r2 = new Rect(to.x, to.y).inflate(HITTESTAREA, HITTESTAREA);\n            let o1, u1;\n            if (r1.union(r2).contains(this)) {\n                if (from.x === to.x || from.y === to.y) {\n                    return true;\n                }\n                else if (from.y < to.y) {\n                    o1 = r1.x + (((r2.x - r1.x) * (this.y - (r1.y + r1.height))) / ((r2.y + r2.height) - (r1.y + r1.height)));\n                    u1 = (r1.x + r1.width) + ((((r2.x + r2.width) - (r1.x + r1.width)) * (this.y - r1.y)) / (r2.y - r1.y));\n                }\n                else {\n                    o1 = r1.x + (((r2.x - r1.x) * (this.y - r1.y)) / (r2.y - r1.y));\n                    u1 = (r1.x + r1.width) + ((((r2.x + r2.width) - (r1.x + r1.width)) * (this.y - (r1.y + r1.height))) / ((r2.y + r2.height) - (r1.y + r1.height)));\n                }\n                return (this.x > o1 && this.x < u1);\n            }\n            return false;\n        }\n        /**\n         * Parses a point from a string representation.\n         * @param str The string to parse, expected format: \"(x,y)\"\n         * @returns A new Point if parsing succeeds, undefined otherwise\n         */\n        parse(str) {\n            const tempStr = str.slice(1, str.length - 1), xy = tempStr.split(','), x = parseInt(xy[0], 10), y = parseInt(xy[1], 10);\n            if (!isNaN(x) && !isNaN(y)) {\n                return new Point(x, y);\n            }\n        }\n    }\n    /**\n     * Represents a rectangle with position and dimensions.\n     * Provides methods for geometric operations and transformations.\n     */\n    class Rect {\n        /**\n         * Creates a new Rect instance.\n         * @param x The x-coordinate of the top-left corner (defaults to 0)\n         * @param y The y-coordinate of the top-left corner (defaults to 0)\n         * @param width The width of the rectangle (defaults to 0)\n         * @param height The height of the rectangle (defaults to 0)\n         */\n        constructor(x, y, width, height) {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.width = width || 0;\n            this.height = height || 0;\n        }\n        /**\n         * Determines if a point is contained within this rectangle.\n         * @param point The point to test\n         * @returns True if the point is inside the rectangle, false otherwise\n         */\n        contains(point) {\n            return ((point.x >= this.x) && (point.x <= (this.x + this.width)) && (point.y >= this.y) && (point.y <= (this.y + this.height)));\n        }\n        /**\n         * Inflates the rectangle by the specified amounts.\n         * @param dx The amount to inflate horizontally\n         * @param dy The amount to inflate vertically (defaults to dx if not provided)\n         * @returns This rectangle instance for chaining\n         */\n        inflate(dx, dy) {\n            if (dy === undefined) {\n                dy = dx;\n            }\n            this.x -= dx;\n            this.y -= dy;\n            this.width += 2 * dx + 1;\n            this.height += 2 * dy + 1;\n            return this;\n        }\n        /**\n         * Moves the rectangle by the specified offset.\n         * @param dx The horizontal offset (or a Point object)\n         * @param dy The vertical offset (ignored if dx is a Point)\n         * @returns This rectangle instance for chaining\n         */\n        offset(dx, dy) {\n            let x = dx, y = dy;\n            if (dx instanceof Point) {\n                x = dx.x;\n                y = dx.y;\n            }\n            this.x += x;\n            this.y += y;\n            return this;\n        }\n        /**\n         * Creates a new rectangle that is the union of this rectangle and another.\n         * @param r The rectangle to union with\n         * @returns A new Rect representing the union of both rectangles\n         */\n        union(r) {\n            const x1 = Math.min(this.x, r.x);\n            const y1 = Math.min(this.y, r.y);\n            const x2 = Math.max((this.x + this.width), (r.x + r.width));\n            const y2 = Math.max((this.y + this.height), (r.y + r.height));\n            return new Rect(x1, y1, x2 - x1, y2 - y1);\n        }\n        /**\n         * Gets the center point of the rectangle.\n         * @returns A Point representing the center of the rectangle\n         */\n        center() {\n            return new Point(this.x + this.width / 2, this.y + this.height / 2);\n        }\n        /**\n         * Gets the top center point of the rectangle.\n         * @returns A Point at the top center edge\n         */\n        top() {\n            return new Point(this.x + this.width / 2, this.y);\n        }\n        /**\n         * Gets the right center point of the rectangle.\n         * @returns A Point at the right center edge\n         */\n        right() {\n            return new Point(this.x + this.width, this.y + this.height / 2);\n        }\n        /**\n         * Gets the bottom center point of the rectangle.\n         * @returns A Point at the bottom center edge\n         */\n        bottom() {\n            return new Point(this.x + this.width / 2, this.y + this.height);\n        }\n        /**\n         * Gets the left center point of the rectangle.\n         * @returns A Point at the left center edge\n         */\n        left() {\n            return new Point(this.x, this.y + this.height / 2);\n        }\n        /**\n         * Gets the top-left corner point of the rectangle.\n         * @returns A Point at the top-left corner\n         */\n        topLeft() {\n            return new Point(this.x, this.y);\n        }\n        /**\n         * Gets the top-right corner point of the rectangle.\n         * @returns A Point at the top-right corner\n         */\n        topRight() {\n            return new Point(this.x + this.width, this.y);\n        }\n        /**\n         * Gets the bottom-left corner point of the rectangle.\n         * @returns A Point at the bottom-left corner\n         */\n        bottomLeft() {\n            return new Point(this.x, this.y + this.height);\n        }\n        /**\n         * Gets the bottom-right corner point of the rectangle.\n         * @returns A Point at the bottom-right corner\n         */\n        bottomRight() {\n            return new Point(this.x + this.width, this.y + this.height);\n        }\n        /**\n         * Creates a copy of this rectangle.\n         * @returns A new Rect with the same position and dimensions\n         */\n        clone() {\n            return new Rect(this.x, this.y, this.width, this.height);\n        }\n        /**\n         * Determines if this rectangle is empty (zero width and height).\n         * @returns True if the rectangle has no area, false otherwise\n         */\n        isEmpty() {\n            return !this.width && !this.height;\n        }\n        /**\n         * Determines if this rectangle is equal to another rectangle.\n         * @param rect The rectangle to compare with\n         * @returns True if both rectangles have the same position and dimensions\n         */\n        equals(rect) {\n            return this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;\n        }\n        /**\n         * Calculates the bounding rectangle after rotating this rectangle by a given angle.\n         * @param angle The rotation angle in radians\n         * @returns A new Rect representing the axis-aligned bounding box of the rotated rectangle\n         */\n        rotatedBounds(angle) {\n            const rect = this.clone(), points = this.rotatedPoints(angle), tl = points[0], tr = points[1], br = points[2], bl = points[3];\n            rect.x = Math.min(br.x, tl.x, tr.x, bl.x);\n            rect.y = Math.min(br.y, tl.y, tr.y, bl.y);\n            rect.width = Math.max(br.x, tl.x, tr.x, bl.x) - rect.x;\n            rect.height = Math.max(br.y, tl.y, tr.y, bl.y) - rect.y;\n            return rect;\n        }\n        /**\n         * Gets the four corner points of this rectangle after rotation.\n         * @param angle The rotation angle in radians\n         * @returns An array of four Points representing the rotated corners [topLeft, topRight, bottomRight, bottomLeft]\n         */\n        rotatedPoints(angle) {\n            const c = this.center(), br = this.bottomRight().rotate(angle, c), tl = this.topLeft().rotate(angle, c), tr = this.topRight().rotate(angle, c), bl = this.bottomLeft().rotate(angle, c);\n            return [tl, tr, br, bl];\n        }\n        /**\n         * Returns a string representation of this rectangle.\n         * @param delimiter The delimiter to use between values (defaults to space)\n         * @returns A string in the format \"x y width height\" (or with custom delimiter)\n         */\n        toString(delimiter) {\n            delimiter = delimiter || ' ';\n            return this.x + delimiter + this.y + delimiter + this.width + delimiter + this.height;\n        }\n        /**\n         * Scales this rectangle while maintaining a static reference point.\n         * @param scaleX The horizontal scale factor\n         * @param scaleY The vertical scale factor\n         * @param staicPoint The static point that should remain fixed during scaling\n         * @param adornerCenter The center point of the adorner\n         * @param angle The rotation angle to apply during scaling\n         */\n        scale(scaleX, scaleY, staicPoint, adornerCenter, angle) {\n            let tl = this.topLeft();\n            const thisCenter = this.center();\n            tl.rotate(angle, thisCenter).rotate(angle, adornerCenter);\n            const delta = staicPoint.minus(tl);\n            const scaled = new Point(delta.x * scaleX, delta.y * scaleY);\n            const position = delta.minus(scaled);\n            tl = tl.plus(position);\n            tl.rotate(angle, adornerCenter).rotate(angle, thisCenter);\n            this.x = tl.x;\n            this.y = tl.y;\n            this.width *= scaleX;\n            this.height *= scaleY;\n        }\n        /**\n         * Scales this rectangle by a zoom factor.\n         * @param zoom The zoom factor to apply\n         * @returns This rectangle instance for chaining\n         */\n        zoom(zoom) {\n            this.x *= zoom;\n            this.y *= zoom;\n            this.width *= zoom;\n            this.height *= zoom;\n            return this;\n        }\n        /**\n         * Determines if this rectangle overlaps with another rectangle.\n         * @param rect The rectangle to check for overlap\n         * @returns True if the rectangles overlap, false otherwise\n         */\n        overlaps(rect) {\n            const bottomRight = this.bottomRight();\n            const rectBottomRight = rect.bottomRight();\n            const overlaps = !(bottomRight.x < rect.x || bottomRight.y < rect.y ||\n                rectBottomRight.x < this.x || rectBottomRight.y < this.y);\n            return overlaps;\n        }\n        /**\n         * Converts an object to a Rect instance.\n         * @param rect The object to convert (if not already a Rect)\n         * @returns A Rect instance\n         */\n        static toRect(rect) {\n            if (!(rect instanceof Rect)) {\n                rect = new Rect(rect.x, rect.y, rect.width, rect.height);\n            }\n            return rect;\n        }\n        /**\n         * Creates an empty rectangle (zero position and dimensions).\n         * @returns A new empty Rect instance\n         */\n        static empty() {\n            return new Rect(0, 0, 0, 0);\n        }\n        /**\n         * Creates a rectangle from two points.\n         * @param p The first point\n         * @param q The second point\n         * @returns A new Rect with the two points as opposite corners\n         * @throws Error if any coordinate values are NaN\n         */\n        static fromPoints(p, q) {\n            if (isNaN(p.x) || isNaN(p.y) || isNaN(q.x) || isNaN(q.y)) {\n                throw new Error('Some values are NaN.');\n            }\n            return new Rect(Math.min(p.x, q.x), Math.min(p.y, q.y), Math.abs(p.x - q.x), Math.abs(p.y - q.y));\n        }\n    }\n    /**\n     * Aligns two rectangles, where one is the container and the other is content.\n     */\n    class RectAlign {\n        constructor(container) {\n            this.container = Rect.toRect(container);\n        }\n        align(content, alignment) {\n            const alignValues = alignment.toLowerCase().split(' ');\n            for (let i = 0; i < alignValues.length; i++) {\n                content = this._singleAlign(content, alignValues[i]);\n            }\n            return content;\n        }\n        _singleAlign(content, alignment) {\n            if (isFunction$1(this[alignment])) {\n                return this[alignment](content);\n            }\n            else {\n                return content;\n            }\n        }\n        left(content) {\n            return this._align(content, this._left);\n        }\n        center(content) {\n            return this._align(content, this._center);\n        }\n        right(content) {\n            return this._align(content, this._right);\n        }\n        stretch(content) {\n            return this._align(content, this._stretch);\n        }\n        top(content) {\n            return this._align(content, this._top);\n        }\n        middle(content) {\n            return this._align(content, this._middle);\n        }\n        bottom(content) {\n            return this._align(content, this._bottom);\n        }\n        _left(container, content) {\n            content.x = container.x;\n        }\n        _center(container, content) {\n            content.x = ((container.width - content.width) / 2) || 0;\n        }\n        _right(container, content) {\n            content.x = container.width - content.width;\n        }\n        _top(container, content) {\n            content.y = container.y;\n        }\n        _middle(container, content) {\n            content.y = ((container.height - content.height) / 2) || 0;\n        }\n        _bottom(container, content) {\n            content.y = container.height - content.height;\n        }\n        _stretch(container, content) {\n            content.x = 0;\n            content.y = 0;\n            content.height = container.height;\n            content.width = container.width;\n        }\n        _align(content, alignCalc) {\n            content = Rect.toRect(content);\n            alignCalc(this.container, content);\n            return content;\n        }\n    }\n\n    class Queue {\n        constructor() {\n            this._tail = null;\n            this._head = null;\n            this.length = 0;\n        }\n        /**\n         * Enqueues an object to the end of the queue.\n         */\n        enqueue(value) {\n            const entry = { value: value, next: null };\n            if (!this._head) {\n                this._head = entry;\n                this._tail = this._head;\n            }\n            else {\n                this._tail.next = entry;\n                this._tail = this._tail.next;\n            }\n            this.length++;\n        }\n        /**\n         * Removes and returns the object at top of the queue.\n         */\n        dequeue() {\n            if (this.length < 1) {\n                throw new Error('The queue is empty.');\n            }\n            const value = this._head.value;\n            this._head = this._head.next;\n            this.length--;\n            return value;\n        }\n        contains(item) {\n            let current = this._head;\n            while (current) {\n                if (current.value === item) {\n                    return true;\n                }\n                current = current.next;\n            }\n            return false;\n        }\n    }\n\n    const OBJECT = 'object';\n    const UNDEFINED = 'undefined';\n    const isFunction = (obj) => typeof obj === 'function';\n    function deepExtendOne(destination, source) {\n        for (const property in source) {\n            if (property === '__proto__' || property === 'constructor') {\n                continue;\n            }\n            const propValue = source[property];\n            const propType = typeof propValue;\n            let propInit;\n            if (propType === OBJECT && propValue !== null) {\n                propInit = propValue.constructor;\n            }\n            else {\n                propInit = null;\n            }\n            if (propInit && propInit !== Array) {\n                if (propValue instanceof Date) {\n                    destination[property] = new Date(propValue.getTime());\n                }\n                else if (isFunction(propValue.clone)) {\n                    destination[property] = propValue.clone();\n                }\n                else {\n                    const destProp = destination[property];\n                    if (typeof (destProp) === OBJECT) {\n                        destination[property] = destProp || {};\n                    }\n                    else {\n                        destination[property] = {};\n                    }\n                    deepExtendOne(destination[property], propValue);\n                }\n            }\n            else if (propType !== UNDEFINED) {\n                destination[property] = propValue;\n            }\n        }\n        return destination;\n    }\n    function deepExtend(destination, ...sources) {\n        const length = sources.length;\n        for (let i = 0; i < length; i++) {\n            deepExtendOne(destination, sources[i]);\n        }\n        return destination;\n    }\n\n    const LayoutDefaultOptions = {\n        type: 'Tree',\n        subtype: 'Down',\n        roots: null,\n        animate: false,\n        // -------------------------------------------------------------------\n        /**\n         * Force-directed option: whether the motion of the nodes should be limited by the boundaries of the diagram surface.\n         */\n        limitToView: false,\n        /**\n         * Force-directed option: the amount of friction applied to the motion of the nodes.\n         */\n        friction: 0.9,\n        /**\n         * Force-directed option: the optimal distance between nodes (minimum energy).\n         */\n        nodeDistance: 50,\n        /**\n         * Force-directed option: the number of time things are being calculated.\n         */\n        iterations: 300,\n        // -------------------------------------------------------------------\n        /**\n         * Tree option: the separation in one direction (depends on the subtype what direction this is).\n         */\n        horizontalSeparation: 90,\n        /**\n         * Tree option: the separation in the complementary direction (depends on the subtype what direction this is).\n         */\n        verticalSeparation: 50,\n        // -------------------------------------------------------------------\n        /**\n         * Tip-over tree option: children-to-parent vertical distance.\n         */\n        underneathVerticalTopOffset: 15,\n        /**\n         * Tip-over tree option: children-to-parent horizontal distance.\n         */\n        underneathHorizontalOffset: 15,\n        /**\n         * Tip-over tree option: leaf-to-next-branch vertical distance.\n         */\n        underneathVerticalSeparation: 15,\n        // -------------------------------------------------------------------\n        /**\n         * Settings object to organize the different components of the diagram in a grid layout structure\n         */\n        grid: {\n            /**\n             * The width of the grid in which components are arranged. Beyond this width a component will be on the next row.\n             */\n            width: 1500,\n            /**\n             * The left offset of the grid.\n             */\n            offsetX: 50,\n            /**\n             * The top offset of the grid.\n             */\n            offsetY: 50,\n            /**\n             * The horizontal padding within a cell of the grid where a single component resides.\n             */\n            componentSpacingX: 20,\n            /**\n             * The vertical padding within a cell of the grid where a single component resides.\n             */\n            componentSpacingY: 20\n        },\n        // -------------------------------------------------------------------\n        /**\n         * Layered option: the separation height/width between the layers.\n         */\n        layerSeparation: 50,\n        /**\n         * Layered option: how many rounds of shifting and fine-tuning.\n         */\n        layeredIterations: 2,\n        /**\n         * Tree-radial option: the angle at which the layout starts.\n         */\n        startRadialAngle: 0,\n        /**\n         * Tree-radial option: the angle at which the layout starts.\n         */\n        endRadialAngle: 360,\n        /**\n         * Tree-radial option: the separation between levels.\n         */\n        radialSeparation: 150,\n        /**\n         * Tree-radial option: the separation between the root and the first level.\n         */\n        radialFirstLevelSeparation: 200,\n        /**\n         * Tree-radial option: whether a virtual roots bing the components in one radial layout.\n         */\n        keepComponentsInOneRadialLayout: false,\n        // -------------------------------------------------------------------\n        // TODO: ensure to change this to false when containers are around\n        ignoreContainers: true,\n        layoutContainerChildren: false,\n        ignoreInvisible: true,\n        animateTransitions: false\n    };\n    /**\n     * Base class for layout algorithms.\n     *\n     * @type {*}\n     */\n    class LayoutBase {\n        constructor() {\n            this.defaultOptions = { ...LayoutDefaultOptions, grid: { ...LayoutDefaultOptions.grid } };\n        }\n        /**\n         * Organizes the components in a grid.\n         * Returns the final set of nodes (not the Graph).\n         *\n         * @param components\n         */\n        gridLayoutComponents(components) {\n            if (!components) {\n                throw new Error('No components supplied.');\n            }\n            // calculate and cache the bounds of the components\n            forEach(components, function (c) {\n                c.calcBounds();\n            });\n            // order by decreasing width\n            components.sort(function (a, b) {\n                return b.bounds.width - a.bounds.width;\n            });\n            const maxWidth = this.options.grid.width, offsetX = this.options.grid.componentSpacingX, offsetY = this.options.grid.componentSpacingY, startX = this.options.grid.offsetX, startY = this.options.grid.offsetY, resultLinkSet = [], resultNodeSet = [];\n            let height = 0, x = startX, y = startY;\n            while (components.length > 0) {\n                if (x >= maxWidth) {\n                    // start a new row\n                    x = startX;\n                    y += height + offsetY;\n                    // reset the row height\n                    height = 0;\n                }\n                const component = components.pop();\n                this.moveToOffset(component, new Point(x, y));\n                for (let i = 0; i < component.nodes.length; i++) {\n                    resultNodeSet.push(component.nodes[i]); // to be returned in the end\n                }\n                for (let i = 0; i < component.links.length; i++) {\n                    resultLinkSet.push(component.links[i]);\n                }\n                const boundingRect = component.bounds;\n                let currentHeight = boundingRect.height;\n                if (currentHeight <= 0 || isNaN(currentHeight)) {\n                    currentHeight = 0;\n                }\n                let currentWidth = boundingRect.width;\n                if (currentWidth <= 0 || isNaN(currentWidth)) {\n                    currentWidth = 0;\n                }\n                if (currentHeight >= height) {\n                    height = currentHeight;\n                }\n                x += currentWidth + offsetX;\n            }\n            return {\n                nodes: resultNodeSet,\n                links: resultLinkSet\n            };\n        }\n        moveToOffset(component, p) {\n            let i, j;\n            const bounds = component.bounds, deltaX = p.x - bounds.x, deltaY = p.y - bounds.y;\n            for (i = 0; i < component.nodes.length; i++) {\n                const node = component.nodes[i];\n                let nodeBounds = node.bounds();\n                if (nodeBounds.width === 0 && nodeBounds.height === 0 && nodeBounds.x === 0 && nodeBounds.y === 0) {\n                    nodeBounds = new Rect(0, 0, 0, 0);\n                }\n                nodeBounds.x += deltaX;\n                nodeBounds.y += deltaY;\n                node.bounds(nodeBounds);\n            }\n            for (i = 0; i < component.links.length; i++) {\n                const link = component.links[i];\n                if (link.points) {\n                    const newPoints = [];\n                    const points = link.points;\n                    for (j = 0; j < points.length; j++) {\n                        const pt = points[j];\n                        pt.x += deltaX;\n                        pt.y += deltaY;\n                        newPoints.push(pt);\n                    }\n                    link.points = newPoints;\n                }\n            }\n            this.currentHorizontalOffset += bounds.width + this.options.grid.offsetX;\n            return new Point(deltaX, deltaY);\n        }\n        transferOptions(options) {\n            // Size options lead to stackoverflow and need special handling\n            this.options = deepExtend({}, this.defaultOptions);\n            if (isUndefined(options)) {\n                return;\n            }\n            this.options = deepExtend(this.options, options || {});\n        }\n    }\n\n    /**\n     * Captures the state of a diagram; node positions, link points and so on.\n     *\n     * @type {*}\n     */\n    class LayoutState {\n        constructor(diagram, graphOrNodes) {\n            if (isUndefined(diagram)) {\n                throw new Error('No diagram given');\n            }\n            this.diagram = diagram;\n            this.nodeMap = new Dictionary();\n            this.linkMap = new Dictionary();\n            this.capture(graphOrNodes ? graphOrNodes : diagram);\n        }\n        /**\n         * Will capture either\n         * - the state of the shapes and the intermediate points of the connections in the diagram\n         * - the bounds of the nodes contained in the Graph together with the intermediate points of the links in the Graph\n         * - the bounds of the nodes in the Array<Node>\n         * - the links points and node bounds in the literal object\n         *\n         * @param diagramOrGraphOrNodes\n         */\n        capture(diagramOrGraphOrNodes) {\n            let node, nodes, shape, i, conn, link, links;\n            if (diagramOrGraphOrNodes && diagramOrGraphOrNodes.type === 'Graph') {\n                for (i = 0; i < diagramOrGraphOrNodes.nodes.length; i++) {\n                    node = diagramOrGraphOrNodes.nodes[i];\n                    shape = node.associatedShape;\n                    // shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n                    this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                }\n                for (i = 0; i < diagramOrGraphOrNodes.links.length; i++) {\n                    link = diagramOrGraphOrNodes.links[i];\n                    conn = link.associatedConnection;\n                    this.linkMap.set(conn.visual.id, link.points());\n                }\n            }\n            else if (diagramOrGraphOrNodes instanceof Array) {\n                nodes = diagramOrGraphOrNodes;\n                for (i = 0; i < nodes.length; i++) {\n                    node = nodes[i];\n                    shape = node.associatedShape;\n                    if (shape) {\n                        this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                    }\n                }\n            }\n            else if (Object.prototype.hasOwnProperty.call(diagramOrGraphOrNodes, 'links') && Object.prototype.hasOwnProperty.call(diagramOrGraphOrNodes, 'nodes')) {\n                nodes = diagramOrGraphOrNodes.nodes;\n                links = diagramOrGraphOrNodes.links;\n                for (i = 0; i < nodes.length; i++) {\n                    node = nodes[i];\n                    shape = node.associatedShape;\n                    if (shape) {\n                        this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                    }\n                }\n                for (i = 0; i < links.length; i++) {\n                    link = links[i];\n                    conn = link.associatedConnection;\n                    if (conn) {\n                        this.linkMap.set(conn.visual.id, link.points);\n                    }\n                }\n            }\n            else { // capture the diagram\n                const shapes = this.diagram.shapes;\n                const connections = this.diagram.connections;\n                for (i = 0; i < shapes.length; i++) {\n                    shape = shapes[i];\n                    this.nodeMap.set(shape.visual.id, shape.bounds());\n                }\n                for (i = 0; i < connections.length; i++) {\n                    conn = connections[i];\n                    this.linkMap.set(conn.visual.id, conn.points());\n                }\n            }\n        }\n    }\n\n    /**\n     * Defines the node (vertex) of a Graph.\n     */\n    class Node {\n        constructor(id, shape) {\n            /**\n             * Holds all the links incident with the current node.\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.links = [];\n            /**\n             * Holds the links from the current one to another Node .\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.outgoing = [];\n            /**\n             * Holds the links from another Node to the current one.\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.incoming = [];\n            /**\n             * Holds the weight of this Node.\n             */\n            this.weight = 1;\n            /**\n             * The payload of the node.\n             *\n             * @type {null}\n             */\n            this.data = null;\n            this.type = 'Node';\n            /**\n             * Whether this is an injected node during the analysis or layout process.\n             *\n             * @type {boolean}\n             */\n            this.isVirtual = false;\n            if (isDefined(id)) {\n                this.id = id;\n            }\n            else {\n                this.id = randomId();\n            }\n            if (isDefined(shape)) {\n                this.associatedShape = shape;\n                // transfer the shape's bounds to the runtime props\n                const b = shape.bounds();\n                this.width = b.width;\n                this.height = b.height;\n                this.x = b.x;\n                this.y = b.y;\n            }\n            else {\n                this.associatedShape = null;\n            }\n            this.shortForm = 'Node \\'' + this.id + '\\'';\n        }\n        /**\n         * Returns whether this node has no links attached.\n         */\n        isIsolated() {\n            return isEmpty(this.links);\n        }\n        /**\n         * Gets or sets the bounding rectangle of this node.\n         * This should be considered as runtime data, the property is not hotlinked to a SVG item.\n         */\n        bounds(r) {\n            if (!isDefined(r)) {\n                return new Rect(this.x, this.y, this.width, this.height);\n            }\n            this.x = r.x;\n            this.y = r.y;\n            this.width = r.width;\n            this.height = r.height;\n        }\n        /**\n         * Returns whether there is at least one link with the given (complementary) node. This can be either an\n         * incoming or outgoing link.\n         */\n        isLinkedTo(node) {\n            return getAny(this.links, (link) => {\n                return link.getComplement(this) === node;\n            });\n        }\n        /**\n         * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n         *\n         * @returns {Array}\n         */\n        getChildren() {\n            if (this.outgoing.length === 0) {\n                return [];\n            }\n            const children = [];\n            for (let i = 0, len = this.outgoing.length; i < len; i++) {\n                const link = this.outgoing[i];\n                children.push(link.getComplement(this));\n            }\n            return children;\n        }\n        /**\n         * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n         *\n         * @returns {Array}\n         */\n        getParents() {\n            if (this.incoming.length === 0) {\n                return [];\n            }\n            const parents = [];\n            for (let i = 0, len = this.incoming.length; i < len; i++) {\n                const link = this.incoming[i];\n                parents.push(link.getComplement(this));\n            }\n            return parents;\n        }\n        /**\n         * Returns a clone of the Node. Note that the identifier is not cloned since it's a different Node instance.\n         *\n         * @returns {Node}\n         */\n        clone() {\n            const copy = new Node();\n            if (isDefined(this.weight)) {\n                copy.weight = this.weight;\n            }\n            if (isDefined(this.balance)) {\n                copy.balance = this.balance;\n            }\n            if (isDefined(this.owner)) {\n                copy.owner = this.owner;\n            }\n            copy.associatedShape = this.associatedShape;\n            copy.x = this.x;\n            copy.y = this.y;\n            copy.width = this.width;\n            copy.height = this.height;\n            return copy;\n        }\n        /**\n         * Returns whether there is a link from the current node to the given node.\n         */\n        adjacentTo(node) {\n            return this.isLinkedTo(node) !== null;\n        }\n        /**\n         * Removes the given link from the link collection this node owns.\n         *\n         * @param link\n         */\n        removeLink(link) {\n            if (link.source === this) {\n                remove(this.links, link);\n                remove(this.outgoing, link);\n                link.source = null;\n            }\n            if (link.target === this) {\n                remove(this.links, link);\n                remove(this.incoming, link);\n                link.target = null;\n            }\n        }\n        /**\n         * Returns whether there is a (outgoing) link from the current node to the given one.\n         */\n        hasLinkTo(node) {\n            return getAny(this.outgoing, function (link) {\n                return link.target === node;\n            });\n        }\n        /**\n         * Returns the degree of this node, i.e. the sum of incoming and outgoing links.\n         */\n        degree() {\n            return this.links.length;\n        }\n        /**\n         * Returns whether this node is either the source or the target of the given link.\n         */\n        incidentWith(link) {\n            return contains(this.links, link);\n        }\n        /**\n         * Returns the links between this node and the given one.\n         */\n        getLinksWith(node) {\n            return all(this.links, function (link) {\n                return link.getComplement(this) === node;\n            }, this);\n        }\n        /**\n         * Returns the nodes (either parent or child) which are linked to the current one.\n         */\n        getNeighbors() {\n            const neighbors = [];\n            forEach(this.incoming, function (e) {\n                neighbors.push(e.getComplement(this));\n            }, this);\n            forEach(this.outgoing, function (e) {\n                neighbors.push(e.getComplement(this));\n            }, this);\n            return neighbors;\n        }\n    }\n    /**\n     * Defines a directed link (edge, connection) of a Graph.\n     */\n    class Link {\n        constructor(source, target, id, connection) {\n            if (isUndefined(source)) {\n                throw new Error('The source of the new link is not set.');\n            }\n            if (isUndefined(target)) {\n                throw new Error('The target of the new link is not set.');\n            }\n            let sourceFound, targetFound;\n            if (isString$1(source)) {\n                sourceFound = new Node(source);\n            }\n            else {\n                sourceFound = source;\n            }\n            if (isString$1(target)) {\n                targetFound = new Node(target);\n            }\n            else {\n                targetFound = target;\n            }\n            this.source = sourceFound;\n            this.target = targetFound;\n            this.source.links.push(this);\n            this.target.links.push(this);\n            this.source.outgoing.push(this);\n            this.target.incoming.push(this);\n            if (isDefined(id)) {\n                this.id = id;\n            }\n            else {\n                this.id = randomId();\n            }\n            if (isDefined(connection)) {\n                this.associatedConnection = connection;\n            }\n            else {\n                this.associatedConnection = null;\n            }\n            this.type = 'Link';\n            this.shortForm = 'Link \\'' + this.source.id + '->' + this.target.id + '\\'';\n        }\n        /**\n         * Returns the complementary node of the given one, if any.\n         */\n        getComplement(node) {\n            if (this.source !== node && this.target !== node) {\n                throw new Error('The given node is not incident with this link.');\n            }\n            return this.source === node ? this.target : this.source;\n        }\n        /**\n         * Returns the overlap of the current link with the given one, if any.\n         */\n        getCommonNode(link) {\n            if (this.source === link.source || this.source === link.target) {\n                return this.source;\n            }\n            if (this.target === link.source || this.target === link.target) {\n                return this.target;\n            }\n            return null;\n        }\n        /**\n         * Returns whether the current link is bridging the given nodes.\n         */\n        isBridging(v1, v2) {\n            return this.source === v1 && this.target === v2 || this.source === v2 && this.target === v1;\n        }\n        /**\n         * Returns the source and target of this link as a tuple.\n         */\n        getNodes() {\n            return [this.source, this.target];\n        }\n        /**\n         * Returns whether the given node is either the source or the target of the current link.\n         */\n        incidentWith(node) {\n            return this.source === node || this.target === node;\n        }\n        /**\n         * Returns whether the given link is a continuation of the current one. This can be both\n         * via an incoming or outgoing link.\n         */\n        adjacentTo(link) {\n            return contains(this.source.links, link) || contains(this.target.links, link);\n        }\n        /**\n         * Changes the source-node of this link.\n         */\n        changeSource(node) {\n            remove(this.source.links, this);\n            remove(this.source.outgoing, this);\n            node.links.push(this);\n            node.outgoing.push(this);\n            this.source = node;\n        }\n        /**\n         * Changes the target-node of this link.\n         *\n         * @param node\n         */\n        changeTarget(node) {\n            remove(this.target.links, this);\n            remove(this.target.incoming, this);\n            node.links.push(this);\n            node.incoming.push(this);\n            this.target = node;\n        }\n        /**\n         * Changes both the source and the target nodes of this link.\n         */\n        changesNodes(v, w) {\n            if (this.source === v) {\n                this.changeSource(w);\n            }\n            else if (this.target === v) {\n                this.changeTarget(w);\n            }\n        }\n        /**\n         * Reverses the direction of this link.\n         */\n        reverse() {\n            const oldSource = this.source;\n            const oldTarget = this.target;\n            this.source = oldTarget;\n            remove(oldSource.outgoing, this);\n            this.source.outgoing.push(this);\n            this.target = oldSource;\n            remove(oldTarget.incoming, this);\n            this.target.incoming.push(this);\n            return this;\n        }\n        /**\n         * Ensures that the given target defines the endpoint of this link.\n         */\n        directTo(target) {\n            if (this.source !== target && this.target !== target) {\n                throw new Error('The given node is not incident with this link.');\n            }\n            if (this.target !== target) {\n                this.reverse();\n            }\n        }\n        /**\n         * Returns a reversed clone of this link.\n         */\n        createReverseEdge() {\n            const r = this.clone();\n            r.reverse();\n            r.reversed = true;\n            return r;\n        }\n        /**\n         * Returns a clone of this link.\n         */\n        clone() {\n            const clone = new Link(this.source, this.target);\n            return clone;\n        }\n    }\n    /* --------------Graph structure---------------------------------*/\n    /**\n     * Defines a directed graph structure.\n     * Note that the incidence structure resides in the nodes through the incoming and outgoing links collection, rahter than\n     * inside the Graph.\n     */\n    class Graph {\n        constructor(idOrDiagram) {\n            /**\n             * The links or edge collection of this Graph.\n             *\n             * @type {Array}\n             */\n            this.links = [];\n            /**\n             * The node or vertex collection of this Graph.\n             *\n             * @type {Array}\n             */\n            this.nodes = [];\n            this._nodeMap = new Dictionary();\n            /**\n             * The optional reference to the Diagram on which this Graph is based.\n             *\n             * @type {null}\n             */\n            this.diagram = null;\n            /**\n             * The root of this Graph. If not set explicitly the first Node with zero incoming links will be taken.\n             *\n             * @type {null}\n             * @private\n             */\n            this._root = null;\n            /**\n             * The bounds of this graph if the nodes have spatial extension defined.\n             *\n             * @type {Rect}\n             */\n            this.bounds = new Rect();\n            // keeps track whether the children & parents have been created\n            this._hasCachedRelationships = false;\n            this.type = 'Graph';\n            this.componentIndex = 0;\n            if (isDefined(idOrDiagram)) {\n                if (isString$1(idOrDiagram)) {\n                    this.id = idOrDiagram;\n                }\n                else {\n                    this.diagram = idOrDiagram;\n                    this.id = idOrDiagram.id;\n                }\n            }\n            else {\n                this.id = randomId();\n            }\n        }\n        /**\n         * Caches the relational information of parents and children in the 'parents' and 'children'\n         * properties.\n         *\n         * @param forceRebuild If set to true the relational info will be rebuild even if already present.\n         */\n        cacheRelationships(forceRebuild) {\n            if (isUndefined(forceRebuild)) {\n                forceRebuild = false;\n            }\n            if (this._hasCachedRelationships && !forceRebuild) {\n                return;\n            }\n            for (let i = 0, len = this.nodes.length; i < len; i++) {\n                const node = this.nodes[i];\n                node.children = this.getChildren(node);\n                node.parents = this.getParents(node);\n            }\n            this._hasCachedRelationships = true;\n        }\n        /**\n         * Assigns tree-levels to the nodes assuming this is a tree graph.\n         * If not connected or not a tree the process will succeed but\n         * will have little meaning.\n         *\n         * @param startNode The node from where the level numbering starts, usually the root of the tree.\n         * @param visited The collection of visited nodes.\n         * @param offset The offset or starting counter of the level info.\n         */\n        assignLevels(startNode, offset, visited) {\n            if (!startNode) {\n                throw new Error('Start node not specified.');\n            }\n            if (isUndefined(offset)) {\n                offset = 0;\n            }\n            // if not done before, cache the parents and children\n            this.cacheRelationships();\n            if (isUndefined(visited)) {\n                visited = new Dictionary();\n                forEach(this.nodes, function (n) {\n                    visited.add(n, false);\n                });\n            }\n            visited.set(startNode, true);\n            startNode.level = offset;\n            const children = startNode.children;\n            for (let i = 0, len = children.length; i < len; i++) {\n                const child = children[i];\n                if (!child || visited.get(child)) {\n                    continue;\n                }\n                this.assignLevels(child, offset + 1, visited);\n            }\n        }\n        /**\n         * Gets or set the root of this graph.\n         * If not set explicitly the first Node with zero incoming links will be taken.\n         *\n         * @param value\n         * @returns {*}\n         */\n        root(value) {\n            if (isUndefined(value)) {\n                if (!this._root) {\n                    // TODO: better to use the longest path for the most probable root?\n                    const found = first(this.nodes, function (n) {\n                        return n.incoming.length === 0;\n                    });\n                    if (found) {\n                        return found;\n                    }\n                    return first(this.nodes);\n                }\n                else {\n                    return this._root;\n                }\n            }\n            else {\n                this._root = value;\n            }\n        }\n        /**\n         * Returns the connected components of this graph.\n         * Note that the returned graphs are made up of the nodes and links of this graph, i.e. a pointer to the items of this graph.\n         * If you alter the items of the components you'll alter the original graph and vice versa.\n         *\n         * @returns {Array}\n         */\n        getConnectedComponents() {\n            this.componentIndex = 0;\n            this.setItemIndices();\n            const componentId = initArray(this.nodes.length, -1);\n            for (let v = 0; v < this.nodes.length; v++) {\n                if (componentId[v] === -1) {\n                    this._collectConnectedNodes(componentId, v);\n                    this.componentIndex++;\n                }\n            }\n            const components = [];\n            let i;\n            for (i = 0; i < this.componentIndex; ++i) {\n                components[i] = new Graph();\n            }\n            for (i = 0; i < componentId.length; ++i) {\n                const graph = components[componentId[i]];\n                graph.addNodeAndOutgoings(this.nodes[i]);\n            }\n            // sorting the components in decreasing order of node count\n            components.sort(function (a, b) {\n                return b.nodes.length - a.nodes.length;\n            });\n            return components;\n        }\n        _collectConnectedNodes(setIds, nodeIndex) {\n            setIds[nodeIndex] = this.componentIndex; // part of the current component\n            const node = this.nodes[nodeIndex];\n            forEach(node.links, function (link) {\n                const next = link.getComplement(node);\n                const nextId = next.index;\n                if (setIds[nextId] === -1) {\n                    this._collectConnectedNodes(setIds, nextId);\n                }\n            }, this);\n        }\n        /**\n         * Calculates the bounds of this Graph if the Nodes have spatial dimensions defined.\n         *\n         * @returns {Rect}\n         */\n        calcBounds() {\n            if (this.isEmpty()) {\n                this.bounds = new Rect();\n                return this.bounds;\n            }\n            let b = null;\n            for (let i = 0, len = this.nodes.length; i < len; i++) {\n                const node = this.nodes[i];\n                if (!b) {\n                    b = node.bounds();\n                }\n                else {\n                    b = b.union(node.bounds());\n                }\n            }\n            this.bounds = b;\n            return this.bounds;\n        }\n        /**\n         * Creates a spanning tree for the current graph.\n         * Important: this will not return a spanning forest if the graph is disconnected.\n         * Prim's algorithm  finds a minimum-cost spanning tree of an edge-weighted, connected, undirected graph;\n         * see http://en.wikipedia.org/wiki/Prim%27s_algorithm .\n         *\n         * @param root The root of the spanning tree.\n         * @returns {Graph}\n         */\n        getSpanningTree(root) {\n            const tree = new Graph();\n            const map = new Dictionary();\n            let source, target;\n            const rootClone = root.clone();\n            tree.root(rootClone);\n            rootClone.level = 0;\n            rootClone.id = root.id;\n            map.add(root, tree.root());\n            root.level = 0;\n            const visited = [];\n            const remaining = [];\n            tree._addNode(tree.root());\n            visited.push(root);\n            remaining.push(root);\n            let levelCount = 1;\n            while (remaining.length > 0) {\n                const next = remaining.pop();\n                for (let ni = 0; ni < next.links.length; ni++) {\n                    const link = next.links[ni];\n                    const cn = link.getComplement(next);\n                    if (contains(visited, cn)) {\n                        continue;\n                    }\n                    cn.level = next.level + 1;\n                    if (levelCount < cn.level + 1) {\n                        levelCount = cn.level + 1;\n                    }\n                    if (!contains(remaining, cn)) {\n                        remaining.push(cn);\n                    }\n                    if (!contains(visited, cn)) {\n                        visited.push(cn);\n                    }\n                    if (map.containsKey(next)) {\n                        source = map.get(next);\n                    }\n                    else {\n                        source = next.clone();\n                        source.level = next.level;\n                        source.id = next.id;\n                        map.add(next, source);\n                    }\n                    if (map.containsKey(cn)) {\n                        target = map.get(cn);\n                    }\n                    else {\n                        target = cn.clone();\n                        target.level = cn.level;\n                        target.id = cn.id;\n                        map.add(cn, target);\n                    }\n                    const newLink = new Link(source, target);\n                    tree.addLink(newLink);\n                }\n            }\n            const treeLevels = [];\n            for (let i = 0; i < levelCount; i++) {\n                treeLevels.push([]);\n            }\n            forEach(tree.nodes, function (node) {\n                treeLevels[node.level].push(node);\n            });\n            tree.treeLevels = treeLevels;\n            tree.cacheRelationships();\n            return tree;\n        }\n        /**\n         * Returns a random node in this graph.\n         *\n         * @param excludedNodes The collection of nodes which should not be considered.\n         * @param incidenceLessThan The maximum degree or incidence the random node should have.\n         * @returns {*}\n         */\n        takeRandomNode(excludedNodes, incidenceLessThan) {\n            if (isUndefined(excludedNodes)) {\n                excludedNodes = [];\n            }\n            if (isUndefined(incidenceLessThan)) {\n                incidenceLessThan = 4;\n            }\n            if (this.nodes.length === 0) {\n                return null;\n            }\n            if (this.nodes.length === 1) {\n                return contains(excludedNodes, this.nodes[0]) ? null : this.nodes[0];\n            }\n            const pool = this.nodes.filter(function (node) {\n                return !contains(excludedNodes, node) && node.degree() <= incidenceLessThan;\n            });\n            if (isEmpty(pool)) {\n                return null;\n            }\n            return pool[randomInteger(0, pool.length)];\n        }\n        /**\n         * Returns whether this is an empty graph.\n         */\n        isEmpty() {\n            return isEmpty(this.nodes);\n        }\n        /**\n         * Checks whether the endpoints of the links are all in the nodes collection.\n         */\n        isHealthy() {\n            return all(this.links, function (link) {\n                return contains(this.nodes, link.source) && contains(this.nodes, link.target);\n            }, this);\n        }\n        /**\n         * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n         *\n         * @returns {Array}\n         */\n        getParents(n) {\n            if (!this.hasNode(n)) {\n                throw new Error('The given node is not part of this graph.');\n            }\n            return n.getParents();\n        }\n        /**\n         * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n         *\n         * @returns {Array}\n         */\n        getChildren(n) {\n            if (!this.hasNode(n)) {\n                throw new Error('The given node is not part of this graph.');\n            }\n            return n.getChildren();\n        }\n        /**\n         * Adds a new link to the graph between the given nodes.\n         */\n        addLink(sourceOrLink, target, owner) {\n            if (isUndefined(sourceOrLink)) {\n                throw new Error('The source of the link is not defined.');\n            }\n            if (isUndefined(target)) {\n                // can only be undefined if the first one is a Link\n                if (isDefined(sourceOrLink.type) && sourceOrLink.type === 'Link') {\n                    this.addExistingLink(sourceOrLink);\n                    return;\n                }\n                else {\n                    throw new Error('The target of the link is not defined.');\n                }\n            }\n            let foundSource = this.getNode(sourceOrLink);\n            if (isUndefined(foundSource)) {\n                foundSource = this.addNode(sourceOrLink);\n            }\n            let foundTarget = this.getNode(target);\n            if (isUndefined(foundTarget)) {\n                foundTarget = this.addNode(target);\n            }\n            const newLink = new Link(foundSource, foundTarget);\n            if (isDefined(owner)) {\n                newLink.owner = owner;\n            }\n            /* newLink.source.outgoing.push(newLink);\n                newLink.source.links.push(newLink);\n                newLink.target.incoming.push(newLink);\n                newLink.target.links.push(newLink);*/\n            this.links.push(newLink);\n            return newLink;\n        }\n        /**\n         * Removes all the links in this graph.\n         */\n        removeAllLinks() {\n            while (this.links.length > 0) {\n                const link = this.links[0];\n                this.removeLink(link);\n            }\n        }\n        /**\n         * Adds the given link to the current graph.\n         */\n        addExistingLink(link) {\n            if (this.hasLink(link)) {\n                return;\n            }\n            this.links.push(link);\n            if (this.hasNode(link.source.id)) {\n                // priority to the existing node with the id even if other props are different\n                const s = this.getNode(link.source.id);\n                link.changeSource(s);\n            }\n            else {\n                this.addNode(link.source);\n            }\n            if (this.hasNode(link.target.id)) {\n                const t = this.getNode(link.target.id);\n                link.changeTarget(t);\n            }\n            else {\n                this.addNode(link.target);\n            }\n            /*  if (!link.source.outgoing.contains(link)) {\n                link.source.outgoing.push(link);\n                }\n                if (!link.source.links.contains(link)) {\n                link.source.links.push(link);\n                }\n                if (!link.target.incoming.contains(link)) {\n                link.target.incoming.push(link);\n                }\n                if (!link.target.links.contains(link)) {\n                link.target.links.push(link);\n                }*/\n        }\n        /**\n         * Returns whether the given identifier or Link is part of this graph.\n         *\n         * @param linkOrId An identifier or a Link object.\n         * @returns {*}\n         */\n        hasLink(linkOrId) {\n            if (isString$1(linkOrId)) {\n                return getAny(this.links, function (link) {\n                    return link.id === linkOrId;\n                });\n            }\n            if (linkOrId.type === 'Link') {\n                return contains(this.links, linkOrId);\n            }\n            throw new Error('The given object is neither an identifier nor a Link.');\n        }\n        /**\n         * Gets the node with the specified Id or null if not part of this graph.\n         */\n        getNode(nodeOrId) {\n            const id = nodeOrId.id || nodeOrId;\n            if (this._nodeMap.containsKey(id)) {\n                return this._nodeMap.get(id);\n            }\n        }\n        /**\n         * Returns whether the given node or node Id is part of this graph.\n         */\n        hasNode(nodeOrId) {\n            const id = nodeOrId.id || nodeOrId;\n            return this._nodeMap.containsKey(id);\n        }\n        _addNode(node) {\n            this.nodes.push(node);\n            this._nodeMap.add(node.id, node);\n        }\n        _removeNode(node) {\n            remove(this.nodes, node);\n            this._nodeMap.remove(node.id);\n        }\n        /**\n         * Removes the given node from this graph.\n         * The node can be specified as an object or as an identifier (string).\n         */\n        removeNode(nodeOrId) {\n            let n = nodeOrId;\n            if (isString$1(nodeOrId)) {\n                n = this.getNode(nodeOrId);\n            }\n            if (isDefined(n)) {\n                const links = n.links;\n                n.links = [];\n                for (let i = 0, len = links.length; i < len; i++) {\n                    const link = links[i];\n                    this.removeLink(link);\n                }\n                this._removeNode(n);\n            }\n            else {\n                throw new Error('The identifier should be a Node or the Id (string) of a node.');\n            }\n        }\n        /**\n         * Returns whether the given nodes are connected with a least one link independently of the direction.\n         */\n        areConnected(n1, n2) {\n            return getAny(this.links, function (link) {\n                return link.source === n1 && link.target === n2 || link.source === n2 && link.target === n1;\n            });\n        }\n        /**\n         * Removes the given link from this graph.\n         */\n        removeLink(link) {\n            /*    if (!this.links.contains(link)) {\n                throw \"The given link is not part of the Graph.\";\n                }\n                */\n            remove(this.links, link);\n            remove(link.source.outgoing, link);\n            remove(link.source.links, link);\n            remove(link.target.incoming, link);\n            remove(link.target.links, link);\n        }\n        /**\n         * Adds a new node to this graph, if not already present.\n         * The node can be an existing Node or the identifier of a new node.\n         * No error is thrown if the node is already there and the existing one is returned.\n         */\n        addNode(nodeOrId, layoutRect, owner) {\n            let newNode = null;\n            if (!isDefined(nodeOrId)) {\n                throw new Error('No Node or identifier for a new Node is given.');\n            }\n            if (isString$1(nodeOrId)) {\n                if (this.hasNode(nodeOrId)) {\n                    return this.getNode(nodeOrId);\n                }\n                newNode = new Node(nodeOrId);\n            }\n            else {\n                if (this.hasNode(nodeOrId)) {\n                    return this.getNode(nodeOrId);\n                }\n                // todo: ensure that the param is a Node?\n                newNode = nodeOrId;\n            }\n            if (isDefined(layoutRect)) {\n                newNode.bounds(layoutRect);\n            }\n            if (isDefined(owner)) {\n                newNode.owner = owner;\n            }\n            this._addNode(newNode);\n            return newNode;\n        }\n        /**\n         * Adds the given Node and its outgoing links.\n         */\n        addNodeAndOutgoings(node) {\n            if (!this.hasNode(node)) {\n                this._addNode(node);\n            }\n            const newLinks = node.outgoing;\n            node.outgoing = [];\n            forEach(newLinks, function (link) {\n                this.addExistingLink(link);\n            }, this);\n        }\n        /**\n         * Sets the 'index' property on the links and nodes of this graph.\n         */\n        setItemIndices() {\n            let i;\n            for (i = 0; i < this.nodes.length; ++i) {\n                this.nodes[i].index = i;\n            }\n            for (i = 0; i < this.links.length; ++i) {\n                this.links[i].index = i;\n            }\n        }\n        /**\n         * Returns a clone of this graph.\n         */\n        clone(saveMapping) {\n            const copy = new Graph();\n            const save = isDefined(saveMapping) && saveMapping === true;\n            if (save) {\n                copy.nodeMap = new Dictionary();\n                copy.linkMap = new Dictionary();\n            }\n            // we need a map even if the saveMapping is not set\n            const map = new Dictionary();\n            forEach(this.nodes, function (nOriginal) {\n                const nCopy = nOriginal.clone();\n                map.set(nOriginal, nCopy);\n                copy._addNode(nCopy);\n                if (save) {\n                    copy.nodeMap.set(nCopy, nOriginal);\n                }\n            });\n            forEach(this.links, function (linkOriginal) {\n                if (map.containsKey(linkOriginal.source) && map.containsKey(linkOriginal.target)) {\n                    const linkCopy = copy.addLink(map.get(linkOriginal.source), map.get(linkOriginal.target));\n                    if (save) {\n                        copy.linkMap.set(linkCopy, linkOriginal);\n                    }\n                }\n            });\n            return copy;\n        }\n        /**\n         * The parsing allows a quick way to create graphs.\n         *  - [\"n1->n2\", \"n2->n3\"]: creates the three nodes and adds the links\n         *  - [\"n1->n2\", {id: \"QSDF\"}, \"n2->n3\"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n         */\n        linearize(addIds) {\n            return Graph.Utils.linearize(this, addIds);\n        }\n        /**\n         * Performs a depth-first traversal starting at the given node.\n         *\n         * @param startNode a node or id of a node in this graph\n         * @param action\n         */\n        depthFirstTraversal(startNode, action) {\n            if (isUndefined(startNode)) {\n                throw new Error('You need to supply a starting node.');\n            }\n            if (isUndefined(action)) {\n                throw new Error('You need to supply an action.');\n            }\n            if (!this.hasNode(startNode)) {\n                throw new Error('The given start-node is not part of this graph');\n            }\n            const foundNode = this.getNode(startNode); // case the given one is an Id\n            const visited = [];\n            this._dftIterator(foundNode, action, visited);\n        }\n        _dftIterator(node, action, visited) {\n            action(node);\n            visited.push(node);\n            const children = node.getChildren();\n            for (let i = 0, len = children.length; i < len; i++) {\n                const child = children[i];\n                if (contains(visited, child)) {\n                    continue;\n                }\n                this._dftIterator(child, action, visited);\n            }\n        }\n        /**\n         * Performs a breadth-first traversal starting at the given node.\n         *\n         * @param startNode a node or id of a node in this graph\n         * @param action\n         */\n        breadthFirstTraversal(startNode, action) {\n            if (isUndefined(startNode)) {\n                throw new Error('You need to supply a starting node.');\n            }\n            if (isUndefined(action)) {\n                throw new Error('You need to supply an action.');\n            }\n            if (!this.hasNode(startNode)) {\n                throw new Error('The given start-node is not part of this graph');\n            }\n            const foundNode = this.getNode(startNode); // case the given one is an Id\n            const queue = new Queue();\n            const visited = [];\n            queue.enqueue(foundNode);\n            while (queue.length > 0) {\n                const node = queue.dequeue();\n                action(node);\n                visited.push(node);\n                const children = node.getChildren();\n                for (let i = 0, len = children.length; i < len; i++) {\n                    const child = children[i];\n                    if (contains(visited, child) || queue.contains(child)) {\n                        continue;\n                    }\n                    queue.enqueue(child);\n                }\n            }\n        }\n        /**\n         * This is the classic Tarjan algorithm for strongly connected components.\n         * See e.g. http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm\n         *\n         * @param excludeSingleItems Whether isolated nodes should be excluded from the analysis.\n         * @param node The start node from which the analysis starts.\n         * @param indices  Numbers the nodes consecutively in the order in which they are discovered.\n         * @param lowLinks The smallest index of any node known to be reachable from the node, including the node itself\n         * @param connected The current component.\n         * @param stack The bookkeeping stack of things to visit.\n         * @param index The counter of visited nodes used to assign the indices.\n         * @private\n         */\n        _stronglyConnectedComponents(excludeSingleItems, node, indices, lowLinks, connected, stack, index) {\n            indices.add(node, index);\n            lowLinks.add(node, index);\n            index++;\n            stack.push(node);\n            const children = node.getChildren();\n            let next;\n            for (let i = 0, len = children.length; i < len; i++) {\n                next = children[i];\n                if (!indices.containsKey(next)) {\n                    this._stronglyConnectedComponents(excludeSingleItems, next, indices, lowLinks, connected, stack, index);\n                    lowLinks.add(node, Math.min(lowLinks.get(node), lowLinks.get(next)));\n                }\n                else if (contains(stack, next)) {\n                    lowLinks.add(node, Math.min(lowLinks.get(node), indices.get(next)));\n                }\n            }\n            // If v is a root node, pop the stack and generate a strong component\n            if (lowLinks.get(node) === indices.get(node)) {\n                const component = [];\n                do {\n                    next = stack.pop();\n                    component.push(next);\n                } while (next !== node);\n                if (!excludeSingleItems || (component.length > 1)) {\n                    connected.push(component);\n                }\n            }\n        }\n        /**\n         * Returns the cycles found in this graph.\n         * The returned arrays consist of the nodes which are strongly coupled.\n         *\n         * @param excludeSingleItems Whether isolated nodes should be excluded.\n         * @returns {Array} The array of cycles found.\n         */\n        findCycles(excludeSingleItems) {\n            if (isUndefined(excludeSingleItems)) {\n                excludeSingleItems = true;\n            }\n            const indices = new Dictionary();\n            const lowLinks = new Dictionary();\n            const connected = [];\n            const stack = [];\n            for (let i = 0, len = this.nodes.length; i < len; i++) {\n                const node = this.nodes[i];\n                if (indices.containsKey(node)) {\n                    continue;\n                }\n                this._stronglyConnectedComponents(excludeSingleItems, node, indices, lowLinks, connected, stack, 0);\n            }\n            return connected;\n        }\n        /**\n         * Returns whether this graph is acyclic.\n         *\n         * @returns {*}\n         */\n        isAcyclic() {\n            return isEmpty(this.findCycles());\n        }\n        /**\n         * Returns whether the given graph is a subgraph of this one.\n         *\n         * @param other Another graph instance.\n         */\n        isSubGraph(other) {\n            const otherArray = other.linearize();\n            const thisArray = this.linearize();\n            return all(otherArray, function (s) {\n                return contains(thisArray, s);\n            });\n        }\n        /**\n         *  Makes an acyclic graph from the current (connected) one.\n         * * @returns {Array} The reversed links.\n         */\n        makeAcyclic() {\n            // if empty or almost empty\n            if (this.isEmpty() || this.nodes.length <= 1 || this.links.length <= 1) {\n                return [];\n            }\n            // singular case of just two nodes\n            if (this.nodes.length === 2) {\n                const result = [];\n                if (this.links.length > 1) {\n                    const oneLink = this.links[0];\n                    const oneNode = oneLink.source;\n                    for (let i = 0, len = this.links.length; i < len; i++) {\n                        const link = this.links[i];\n                        if (link.source === oneNode) {\n                            continue;\n                        }\n                        const rev = link.reverse();\n                        result.push(rev);\n                    }\n                }\n                return result;\n            }\n            const copy = this.clone(true); // copy.nodeMap tells you the mapping\n            const N = this.nodes.length;\n            const intensityCatalog = new Dictionary();\n            /**\n             * If there are both incoming and outgoing links this will return the flow intensity (out-in).\n             * Otherwise the node acts as a flow source with N specifying the (equal) intensity.\n             *\n             * @param node\n             * @returns {number}\n             */\n            const flowIntensity = function (node) {\n                if (node.outgoing.length === 0) {\n                    return (2 - N);\n                }\n                else if (node.incoming.length === 0) {\n                    return (N - 2);\n                }\n                else {\n                    return node.outgoing.length - node.incoming.length;\n                }\n            };\n            /**\n             * Collects the nodes with the same intensity.\n             *\n             * @param node\n             * @param intensityCatalog\n             */\n            const catalogEqualIntensity = function (node) {\n                const intensity = flowIntensity(node);\n                if (!intensityCatalog.containsKey(intensity)) {\n                    intensityCatalog.set(intensity, []);\n                }\n                intensityCatalog.get(intensity).push(node);\n            };\n            forEach(copy.nodes, function (v) {\n                catalogEqualIntensity(v);\n            });\n            let sourceStack = [];\n            const targetStack = [];\n            while (copy.nodes.length > 0) {\n                let source, target, intensity;\n                if (intensityCatalog.containsKey(2 - N)) {\n                    const targets = intensityCatalog.get(2 - N); // nodes without outgoings\n                    while (targets.length > 0) {\n                        target = targets.pop();\n                        for (let li = 0; li < target.links.length; li++) {\n                            const targetLink = target.links[li];\n                            source = targetLink.getComplement(target);\n                            intensity = flowIntensity(source);\n                            remove(intensityCatalog.get(intensity), source);\n                            source.removeLink(targetLink);\n                            catalogEqualIntensity(source);\n                        }\n                        copy._removeNode(target);\n                        targetStack.unshift(target);\n                    }\n                }\n                // move sources to sourceStack\n                if (intensityCatalog.containsKey(N - 2)) {\n                    const sources = intensityCatalog.get(N - 2); // nodes without incomings\n                    while (sources.length > 0) {\n                        source = sources.pop();\n                        for (let si = 0; si < source.links.length; si++) {\n                            const sourceLink = source.links[si];\n                            target = sourceLink.getComplement(source);\n                            intensity = flowIntensity(target);\n                            remove(intensityCatalog.get(intensity), target);\n                            target.removeLink(sourceLink);\n                            catalogEqualIntensity(target);\n                        }\n                        sourceStack.push(source);\n                        copy._removeNode(source);\n                    }\n                }\n                if (copy.nodes.length > 0) {\n                    for (let k = N - 3; k > 2 - N; k--) {\n                        if (intensityCatalog.containsKey(k) &&\n                            intensityCatalog.get(k).length > 0) {\n                            const maxdiff = intensityCatalog.get(k);\n                            const v = maxdiff.pop();\n                            for (let ri = 0; ri < v.links.length; ri++) {\n                                const ril = v.links[ri];\n                                const u = ril.getComplement(v);\n                                intensity = flowIntensity(u);\n                                remove(intensityCatalog.get(intensity), u);\n                                u.removeLink(ril);\n                                catalogEqualIntensity(u);\n                            }\n                            sourceStack.push(v);\n                            copy._removeNode(v);\n                            break;\n                        }\n                    }\n                }\n            }\n            sourceStack = sourceStack.concat(targetStack);\n            const vertexOrder = new Dictionary();\n            for (let kk = 0; kk < this.nodes.length; kk++) {\n                vertexOrder.set(copy.nodeMap.get(sourceStack[kk]), kk);\n            }\n            const reversedEdges = [];\n            forEach(this.links, function (link) {\n                if (vertexOrder.get(link.source) > vertexOrder.get(link.target)) {\n                    link.reverse();\n                    reversedEdges.push(link);\n                }\n            });\n            return reversedEdges;\n        }\n    }\n    /**\n     * A collection of predefined graphs for demo and testing purposes.\n     */\n    Graph.Predefined = {\n        /**\n         * Eight-shapes graph all connected in a cycle.\n         *\n         * @returns {*}\n         * @constructor\n         */\n        EightGraph() {\n            return Graph.Utils.parse(['1->2', '2->3', '3->4', '4->1', '3->5', '5->6', '6->7', '7->3']);\n        },\n        /**\n         * Creates a typical mindmap diagram.\n         *\n         * @returns {*}\n         * @constructor\n         */\n        Mindmap() {\n            return Graph.Utils.parse(['0->1', '0->2', '0->3', '0->4', '0->5', '1->6', '1->7', '7->8', '2->9', '9->10', '9->11', '3->12',\n                '12->13', '13->14', '4->15', '4->16', '15->17', '15->18', '18->19', '18->20', '14->21', '14->22', '5->23', '23->24', '23->25', '6->26']);\n        },\n        /**\n         * Three nodes connected in a cycle.\n         *\n         * @returns {*}\n         * @constructor\n         */\n        ThreeGraph() {\n            return Graph.Utils.parse(['1->2', '2->3', '3->1']);\n        },\n        /**\n         * A tree with each node having two children.\n         *\n         * @param levels How many levels the binary tree should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        BinaryTree(levels) {\n            if (isUndefined(levels)) {\n                levels = 5;\n            }\n            return Graph.Utils.createBalancedTree(levels, 2);\n        },\n        /**\n         * A linear graph (discrete line segment).\n         *\n         * @param length How many segments (the node count is hence (length+1)).\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Linear(length) {\n            if (isUndefined(length)) {\n                length = 10;\n            }\n            return Graph.Utils.createBalancedTree(length, 1);\n        },\n        /**\n         * A standard tree-graph with the specified levels and children (siblings) count.\n         * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n         * - NodeCount = (1-s^(N+1))/(1-s)]\n         * - LinkCount = s.(1-s^N)/(1-s)\n         *\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Tree(levels, siblingsCount) {\n            return Graph.Utils.createBalancedTree(levels, siblingsCount);\n        },\n        /**\n         * Creates a forest.\n         * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n         * - NodeCount = t.(1-s^(N+1))/(1-s)]\n         * - LinkCount = t.s.(1-s^N)/(1-s)\n         *\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @param trees The amount of trees the forest should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Forest(levels, siblingsCount, trees) {\n            return Graph.Utils.createBalancedForest(levels, siblingsCount, trees);\n        },\n        /**\n         * A workflow-like graph with cycles.\n         *\n         * @returns {*}\n         * @constructor\n         */\n        Workflow() {\n            return Graph.Utils.parse(['0->1', '1->2', '2->3', '1->4', '4->3', '3->5', '5->6', '6->3', '6->7', '5->4']);\n        },\n        /**\n         * A grid graph with the direction of the links avoiding cycles.\n         * Node count: (n+1).(m+1)\n         * Link count: n.(m+1) + m.(n+1)\n         *\n         * @param n Horizontal count of grid cells. If zero this will result in a linear graph.\n         * @param m Vertical count of grid cells. If zero this will result in a linear graph.\n         * @constructor\n         */\n        Grid(n, m) {\n            const g = new Graph();\n            if (n <= 0 && m <= 0) {\n                return g;\n            }\n            for (let i = 0; i < n + 1; i++) {\n                let previous = null;\n                for (let j = 0; j < m + 1; j++) {\n                    // using x-y coordinates to name the nodes\n                    const node = new Node(i.toString() + '.' + j.toString());\n                    g.addNode(node);\n                    if (previous) {\n                        g.addLink(previous, node);\n                    }\n                    if (i > 0) {\n                        const left = g.getNode((i - 1).toString() + '.' + j.toString());\n                        g.addLink(left, node);\n                    }\n                    previous = node;\n                }\n            }\n            return g;\n        }\n    };\n    /**\n     * Graph generation and other utilities.\n     */\n    Graph.Utils = {\n        /**\n         * The parsing allows a quick way to create graphs.\n         *  - [\"n1->n2\", \"n2->n3\"]: creates the three nodes and adds the links\n         *  - [\"n1->n2\", {id: \"id177\"}, \"n2->n3\"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n         */\n        parse(graphString) {\n            let previousLink;\n            const graph = new Graph(), parts = graphString.slice();\n            for (let i = 0, len = parts.length; i < len; i++) {\n                const part = parts[i];\n                if (isString$1(part)) { // link spec\n                    if (part.indexOf('->') < 0) {\n                        throw new Error('The link should be specified as \\'a->b\\'.');\n                    }\n                    const p = part.split('->');\n                    if (p.length !== 2) {\n                        throw new Error('The link should be specified as \\'a->b\\'.');\n                    }\n                    previousLink = new Link(p[0], p[1]);\n                    graph.addLink(previousLink);\n                }\n                if (isObject(part)) {\n                    if (!previousLink) {\n                        throw new Error('Specification found before Link definition.');\n                    }\n                    deepExtend(previousLink, part);\n                }\n            }\n            return graph;\n        },\n        /**\n         * Returns a linearized representation of the given Graph.\n         * See also the Graph.Utils.parse method for the inverse operation.\n         */\n        linearize(graph, addIds) {\n            if (isUndefined(graph)) {\n                throw new Error('Expected an instance of a Graph object in slot one.');\n            }\n            if (isUndefined(addIds)) {\n                addIds = false;\n            }\n            const lin = [];\n            for (let i = 0, len = graph.links.length; i < len; i++) {\n                const link = graph.links[i];\n                lin.push(link.source.id + '->' + link.target.id);\n                if (addIds) {\n                    lin.push({ id: link.id });\n                }\n            }\n            return lin;\n        },\n        /**\n         * The method used by the diagram creation to instantiate a shape.\n         *\n         * @param kendoDiagram The Kendo diagram where the diagram will be created.\n         * @param p The position at which to place the shape.\n         * @param shapeDefaults Optional Shape options.\n         * @param id Optional identifier of the shape.\n         * @returns {*}\n         * @private\n         */\n        _addShape(kendoDiagram, p, id, shapeDefaults) {\n            if (isUndefined(p)) {\n                p = new Point(0, 0);\n            }\n            if (isUndefined(id)) {\n                id = randomId();\n            }\n            shapeDefaults = deepExtend({\n                width: 20,\n                height: 20,\n                id: id,\n                radius: 10,\n                fill: '#778899',\n                data: 'circle',\n                undoable: false,\n                x: p.x,\n                y: p.y\n            }, shapeDefaults);\n            return kendoDiagram.addShape(shapeDefaults);\n        },\n        /**\n         * The method used by the diagram creation to instantiate a connection.\n         *\n         * @param diagram he Kendo diagram where the diagram will be created.\n         * @param from The source shape.\n         * @param to The target shape.\n         * @param options Optional Connection options.\n         * @returns {*}\n         * @private\n         */\n        _addConnection(diagram, from, to, options) {\n            return diagram.connect(from, to, options);\n        },\n        /**\n         * Creates a diagram from the given Graph.\n         *\n         * @param diagram The Kendo diagram where the diagram will be created.\n         * @param graph The graph structure defining the diagram.\n         */\n        createDiagramFromGraph(diagram, graph, doLayout, randomSize) {\n            if (isUndefined(diagram)) {\n                throw new Error('The diagram surface is undefined.');\n            }\n            if (isUndefined(graph)) {\n                throw new Error('No graph specification defined.');\n            }\n            if (isUndefined(doLayout)) {\n                doLayout = true;\n            }\n            if (isUndefined(randomSize)) {\n                randomSize = false;\n            }\n            const width = diagram.element.clientWidth || 200;\n            const height = diagram.element.clientHeight || 200;\n            const map = [];\n            let node, shape;\n            for (let i = 0, len = graph.nodes.length; i < len; i++) {\n                node = graph.nodes[i];\n                let p = node.position;\n                if (isUndefined(p)) {\n                    if (isDefined(node.x) && isDefined(node.y)) {\n                        p = new Point(node.x, node.y);\n                    }\n                    else {\n                        p = new Point(randomInteger(10, width - 20), randomInteger(10, height - 20));\n                    }\n                }\n                const opt = {};\n                if (node.id === '0') {\n                    /* deepExtend(opt,\n                       {\n                       fill: \"Orange\",\n                       data: 'circle',\n                       width: 100,\n                       height: 100,\n                       center: new Point(50, 50)\n                       });*/\n                }\n                else if (randomSize) {\n                    deepExtend(opt, {\n                        width: Math.random() * 150 + 20,\n                        height: Math.random() * 80 + 50,\n                        data: 'rectangle',\n                        fill: {\n                            color: '#778899'\n                        }\n                    });\n                }\n                shape = this._addShape(diagram, p, node.id, opt);\n                // shape.content(node.id);\n                const bounds = shape.bounds();\n                if (isDefined(bounds)) {\n                    node.x = bounds.x;\n                    node.y = bounds.y;\n                    node.width = bounds.width;\n                    node.height = bounds.height;\n                }\n                map[node.id] = shape;\n            }\n            for (let gli = 0; gli < graph.links.length; gli++) {\n                const link = graph.links[gli];\n                const sourceShape = map[link.source.id];\n                if (isUndefined(sourceShape)) {\n                    continue;\n                }\n                const targetShape = map[link.target.id];\n                if (isUndefined(targetShape)) {\n                    continue;\n                }\n                this._addConnection(diagram, sourceShape, targetShape, { id: link.id });\n            }\n            if (doLayout) {\n                const l = new SpringLayout(diagram);\n                l.layoutGraph(graph, { limitToView: false });\n                for (let shi = 0; shi < graph.nodes.length; shi++) {\n                    node = graph.nodes[shi];\n                    shape = map[node.id];\n                    shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n                }\n            }\n        },\n        /**\n         * Creates a balanced tree with the specified number of levels and siblings count.\n         * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n         * - NodeCount = (1-s^(N+1))/(1-s)]\n         * - LinkCount = s.(1-s^N)/(1-s)\n         *\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         */\n        createBalancedTree(levels, siblingsCount) {\n            if (isUndefined(levels)) {\n                levels = 3;\n            }\n            if (isUndefined(siblingsCount)) {\n                siblingsCount = 3;\n            }\n            const g = new Graph();\n            let news, counter = -1, lastAdded = [];\n            if (levels <= 0 || siblingsCount <= 0) {\n                return g;\n            }\n            const root = new Node((++counter).toString());\n            g.addNode(root);\n            g.root(root);\n            lastAdded.push(root);\n            for (let i = 0; i < levels; i++) {\n                news = [];\n                for (let j = 0; j < lastAdded.length; j++) {\n                    const parent = lastAdded[j];\n                    for (let k = 0; k < siblingsCount; k++) {\n                        const item = new Node((++counter).toString());\n                        g.addLink(parent, item);\n                        news.push(item);\n                    }\n                }\n                lastAdded = news;\n            }\n            return g;\n        },\n        /**\n         * Creates a balanced tree with the specified number of levels and siblings count.\n         * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n         * - NodeCount = t.(1-s^(N+1))/(1-s)]\n         * - LinkCount = t.s.(1-s^N)/(1-s)\n         *\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         * @param treeCount The number of trees the forest should have.\n         */\n        createBalancedForest(levels, siblingsCount, treeCount) {\n            if (isUndefined(levels)) {\n                levels = 3;\n            }\n            if (isUndefined(siblingsCount)) {\n                siblingsCount = 3;\n            }\n            if (isUndefined(treeCount)) {\n                treeCount = 5;\n            }\n            const g = new Graph();\n            let counter = -1, lastAdded = [], news;\n            if (levels <= 0 || siblingsCount <= 0 || treeCount <= 0) {\n                return g;\n            }\n            for (let t = 0; t < treeCount; t++) {\n                const root = new Node((++counter).toString());\n                g.addNode(root);\n                lastAdded = [root];\n                for (let i = 0; i < levels; i++) {\n                    news = [];\n                    for (let j = 0; j < lastAdded.length; j++) {\n                        const parent = lastAdded[j];\n                        for (let k = 0; k < siblingsCount; k++) {\n                            const item = new Node((++counter).toString());\n                            g.addLink(parent, item);\n                            news.push(item);\n                        }\n                    }\n                    lastAdded = news;\n                }\n            }\n            return g;\n        },\n        /**\n         * Creates a random graph (uniform distribution) with the specified amount of nodes.\n         *\n         * @param nodeCount The amount of nodes the random graph should have.\n         * @param maxIncidence The maximum allowed degree of the nodes.\n         * @param isTree Whether the return graph should be a tree (default: false).\n         * @returns {diagram.Graph}\n         */\n        createRandomConnectedGraph(nodeCount, maxIncidence, isTree) {\n            /* Swa's Mathematica export of random Bernoulli graphs\n               gr[n_,p_]:=Module[{g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->\"Name\",DirectedEdges->True]},\n               While[Not[ConnectedGraphQ[g]],g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->\"Name\",DirectedEdges->True]];g];\n               project[a_]:=(\"\\\"\"<>ToString[Part[#,1]]<>\"->\"<>ToString[Part[#,2]]<>\"\\\"\")&     @ a;\n               export[g_]:=project/@ EdgeList[g]\n               g = gr[12,.1]\n               export [g]\n               */\n            if (isUndefined(nodeCount)) {\n                nodeCount = 40;\n            }\n            if (isUndefined(maxIncidence)) {\n                maxIncidence = 4;\n            }\n            if (isUndefined(isTree)) {\n                isTree = false;\n            }\n            const g = new Graph();\n            let counter = -1;\n            if (nodeCount <= 0) {\n                return g;\n            }\n            const root = new Node((++counter).toString());\n            g.addNode(root);\n            if (nodeCount === 1) {\n                return g;\n            }\n            if (nodeCount > 1) {\n                // random tree\n                for (let i = 1; i < nodeCount; i++) {\n                    const poolNode = g.takeRandomNode([], maxIncidence);\n                    if (!poolNode) {\n                        // failed to find one so the graph will have less nodes than specified\n                        break;\n                    }\n                    const newNode = g.addNode(i.toString());\n                    g.addLink(poolNode, newNode);\n                }\n                if (!isTree && nodeCount > 1) {\n                    const randomAdditions = randomInteger(1, nodeCount);\n                    for (let ri = 0; ri < randomAdditions; ri++) {\n                        const n1 = g.takeRandomNode([], maxIncidence);\n                        const n2 = g.takeRandomNode([], maxIncidence);\n                        if (n1 && n2 && !g.areConnected(n1, n2)) {\n                            g.addLink(n1, n2);\n                        }\n                    }\n                }\n                return g;\n            }\n        },\n        /**\n         * Generates a random diagram.\n         *\n         * @param diagram The host diagram.\n         * @param shapeCount The number of shapes the random diagram should contain.\n         * @param maxIncidence The maximum degree the shapes can have.\n         * @param isTree Whether the generated diagram should be a tree\n         * @param layoutType The optional layout type to apply after the diagram is generated.\n         */\n        randomDiagram(diagram, shapeCount, maxIncidence, isTree, randomSize) {\n            const g = Graph.Utils.createRandomConnectedGraph(shapeCount, maxIncidence, isTree);\n            Graph.Utils.createDiagramFromGraph(diagram, g, false, randomSize);\n        }\n    };\n    /**\n     * The classic spring-embedder (aka force-directed, Fruchterman-Rheingold, barycentric) algorithm.\n     * http://en.wikipedia.org/wiki/Force-directed_graph_drawing\n     * - Chapter 12 of Tamassia et al. \"Handbook of graph drawing and visualization\".\n     * - Kobourov on preprint arXiv; http://arxiv.org/pdf/1201.3011.pdf\n     * - Fruchterman and Rheingold in SOFTWARE-PRACTICE AND EXPERIENCE, VOL. 21(1 1), 1129-1164 (NOVEMBER 1991)\n     *\n     * @type {*}\n     */\n    class SpringLayout extends LayoutBase {\n        constructor(diagram) {\n            super();\n            if (isUndefined(diagram)) {\n                throw new Error('Diagram is not specified.');\n            }\n            this.diagram = diagram;\n        }\n        layout(options) {\n            this.transferOptions(options);\n            const adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            const graph = adapter.convert(options);\n            if (graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            const components = graph.getConnectedComponents();\n            if (isEmpty(components)) {\n                return;\n            }\n            for (let i = 0; i < components.length; i++) {\n                const component = components[i];\n                this.layoutGraph(component, options);\n            }\n            const finalNodeSet = this.gridLayoutComponents(components);\n            return new LayoutState(this.diagram, finalNodeSet);\n        }\n        layoutGraph(graph, options) {\n            if (isDefined(options)) {\n                this.transferOptions(options);\n            }\n            this.graph = graph;\n            const initialTemperature = this.options.nodeDistance * 9;\n            this.temperature = initialTemperature;\n            const guessBounds = this._expectedBounds();\n            this.width = guessBounds.width;\n            this.height = guessBounds.height;\n            for (let step = 0; step < this.options.iterations; step++) {\n                this.refineStage = step >= this.options.iterations * 5 / 6;\n                this.tick();\n                // exponential cooldown\n                this.temperature = this.refineStage ?\n                    initialTemperature / 30 :\n                    initialTemperature * (1 - step / (2 * this.options.iterations));\n            }\n        }\n        /**\n         * Single iteration of the simulation.\n         */\n        tick() {\n            let i;\n            // collect the repulsive forces on each node\n            for (i = 0; i < this.graph.nodes.length; i++) {\n                this._repulsion(this.graph.nodes[i]);\n            }\n            // collect the attractive forces on each node\n            for (i = 0; i < this.graph.links.length; i++) {\n                this._attraction(this.graph.links[i]);\n            }\n            // update the positions\n            for (i = 0; i < this.graph.nodes.length; i++) {\n                const node = this.graph.nodes[i];\n                const offset = Math.sqrt(node.dx * node.dx + node.dy * node.dy);\n                if (offset === 0) {\n                    return;\n                }\n                node.x += Math.min(offset, this.temperature) * node.dx / offset;\n                node.y += Math.min(offset, this.temperature) * node.dy / offset;\n                if (this.options.limitToView) {\n                    node.x = Math.min(this.width, Math.max(node.width / 2, node.x));\n                    node.y = Math.min(this.height, Math.max(node.height / 2, node.y));\n                }\n            }\n        }\n        /**\n         * Shakes the node away from its current position to escape the deadlock.\n         *\n         * @param node A Node.\n         * @private\n         */\n        _shake(node) {\n            // just a simple polar neighborhood\n            const rho = Math.random() * this.options.nodeDistance / 4;\n            const alpha = Math.random() * 2 * Math.PI;\n            node.x += rho * Math.cos(alpha);\n            node.y -= rho * Math.sin(alpha);\n        }\n        /**\n         * The typical Coulomb-Newton force law F=k/r^2\n         *\n         * @remark This only works in dimensions less than three.\n         * @param d\n         * @param n A Node.\n         * @param m Another Node.\n         * @returns {number}\n         * @private\n         */\n        _InverseSquareForce(d, n, m) {\n            let force;\n            if (!this.refineStage) {\n                force = Math.pow(d, 2) / Math.pow(this.options.nodeDistance, 2);\n            }\n            else {\n                const deltax = n.x - m.x;\n                const deltay = n.y - m.y;\n                const wn = n.width / 2;\n                const hn = n.height / 2;\n                const wm = m.width / 2;\n                const hm = m.height / 2;\n                force = (Math.pow(deltax, 2) / Math.pow(wn + wm + this.options.nodeDistance, 2)) + (Math.pow(deltay, 2) / Math.pow(hn + hm + this.options.nodeDistance, 2));\n            }\n            return force * 4 / 3;\n        }\n        /**\n         * The typical Hooke force law F=kr^2\n         *\n         * @param d\n         * @param n\n         * @param m\n         * @returns {number}\n         * @private\n         */\n        _SquareForce(d, n, m) {\n            return 1 / this._InverseSquareForce(d, n, m);\n        }\n        _repulsion(n) {\n            n.dx = 0;\n            n.dy = 0;\n            forEach(this.graph.nodes, function (m) {\n                if (m === n) {\n                    return;\n                }\n                while (n.x === m.x && n.y === m.y) {\n                    this._shake(m);\n                }\n                const vx = n.x - m.x;\n                const vy = n.y - m.y;\n                const distance = Math.sqrt(vx * vx + vy * vy);\n                const r = this._SquareForce(distance, n, m) * 2;\n                n.dx += (vx / distance) * r;\n                n.dy += (vy / distance) * r;\n            }, this);\n        }\n        _attraction(link) {\n            const t = link.target;\n            const s = link.source;\n            if (s === t) {\n                // loops induce endless shakes\n                return;\n            }\n            while (s.x === t.x && s.y === t.y) {\n                this._shake(t);\n            }\n            const vx = s.x - t.x;\n            const vy = s.y - t.y;\n            const distance = Math.sqrt(vx * vx + vy * vy);\n            const a = this._InverseSquareForce(distance, s, t) * 5;\n            const dx = (vx / distance) * a;\n            const dy = (vy / distance) * a;\n            t.dx += dx;\n            t.dy += dy;\n            s.dx -= dx;\n            s.dy -= dy;\n        }\n        /**\n         * Calculates the expected bounds after layout.\n         *\n         * @returns {*}\n         * @private\n         */\n        _expectedBounds() {\n            const N = this.graph.nodes.length, /* golden ration optimal?*/ ratio = 1.5, multiplier = 4;\n            if (N === 0) {\n                return;\n            }\n            const size = fold(this.graph.nodes, function (s, node) {\n                const area = node.width * node.height;\n                if (area > 0) {\n                    s += Math.sqrt(area);\n                    return s;\n                }\n                return 0;\n            }, 0, this);\n            const av = size / N;\n            const squareSize = av * Math.ceil(Math.sqrt(N));\n            const width = squareSize * Math.sqrt(ratio);\n            const height = squareSize / Math.sqrt(ratio);\n            return { width: width * multiplier, height: height * multiplier };\n        }\n    }\n    /**\n     * Adapter between the diagram control and the graph representation. It converts shape and connections to nodes and edges taking into the containers and their collapsef state,\n     * the visibility of items and more. If the layoutContainerChildren is true a hypertree is constructed which holds the hierarchy of containers and many conditions are analyzed\n     * to investigate how the effective graph structure looks like and how the layout has to be performed.\n     *\n     * @type {*}\n     */\n    class DiagramToHyperTreeAdapter {\n        constructor(diagram) {\n            /**\n             * The mapping to/from the original nodes.\n             *\n             * @type {Dictionary}\n             */\n            this.nodeMap = new Dictionary();\n            /**\n             * Gets the mapping of a shape to a container in case the shape sits in a collapsed container.\n             *\n             * @type {Dictionary}\n             */\n            this.shapeMap = new Dictionary();\n            /**\n             * The nodes being mapped.\n             *\n             * @type {Dictionary}\n             */\n            this.nodes = [];\n            /**\n             * The connections being mapped.\n             *\n             * @type {Dictionary}\n             */\n            this.edges = [];\n            // the mapping from an edge to all the connections it represents, this can be both because of multiple connections between\n            // two shapes or because a container holds multiple connections to another shape or container.\n            this.edgeMap = new Dictionary();\n            /**\n             * The resulting set of Nodes when the analysis has finished.\n             *\n             * @type {Array}\n             */\n            this.finalNodes = [];\n            /**\n             * The resulting set of Links when the analysis has finished.\n             *\n             * @type {Array}\n             */\n            this.finalLinks = [];\n            /**\n             * The items being omitted because of multigraph edges.\n             *\n             * @type {Array}\n             */\n            this.ignoredConnections = [];\n            /**\n             * The items being omitted because of containers, visibility and other factors.\n             *\n             * @type {Array}\n             */\n            this.ignoredShapes = [];\n            /**\n             * The map from a node to the partition/hypernode in which it sits. This hyperMap is null if 'options.layoutContainerChildren' is false.\n             *\n             * @type {Dictionary}\n             */\n            this.hyperMap = new Dictionary();\n            /**\n             * The hypertree contains the hierarchy defined by the containers.\n             * It's in essence a Graph of Graphs with a tree structure defined by the hierarchy of containers.\n             *\n             * @type {HyperTree}\n             */\n            this.hyperTree = new Graph();\n            /**\n             * The resulting graph after conversion. Note that this does not supply the information contained in the\n             * ignored connection and shape collections.\n             *\n             * @type {null}\n             */\n            this.finalGraph = null;\n            this.diagram = diagram;\n        }\n        /**\n         * The hyperTree is used when the 'options.layoutContainerChildren' is true. It contains the hierarchy of containers whereby each node is a ContainerGraph.\n         * This type of node has a Container reference to the container which holds the Graph items. There are three possible situations during the conversion process:\n         * - Ignore the containers: the container are non-existent and only normal shapes are mapped. If a shape has a connection to a container it will be ignored as well\n         * since there is no node mapped for the container.\n         * - Do not ignore the containers and leave the content of the containers untouched: the top-level elements are being mapped and the children within a container are not altered.\n         * - Do not ignore the containers and organize the content of the containers as well: the hypertree is constructed and there is a partitioning of all nodes and connections into the hypertree.\n         * The only reason a connection or node is not being mapped might be due to the visibility, which includes the visibility change through a collapsed parent container.\n         *\n         * @param options\n         */\n        convert(options) {\n            if (isUndefined(this.diagram)) {\n                throw new Error('No diagram to convert.');\n            }\n            this.options = deepExtend({\n                ignoreInvisible: true,\n                ignoreContainers: true,\n                layoutContainerChildren: false\n            }, options || {});\n            this.clear();\n            // create the nodes which participate effectively in the graph analysis\n            this._renormalizeShapes();\n            // recreate the incoming and outgoing collections of each and every node\n            this._renormalizeConnections();\n            // export the resulting graph\n            this.finalNodes = new Dictionary(this.nodes);\n            this.finalLinks = new Dictionary(this.edges);\n            this.finalGraph = new Graph();\n            this.finalNodes.forEach(function (n) {\n                this.finalGraph.addNode(n);\n            }, this);\n            this.finalLinks.forEach(function (l) {\n                this.finalGraph.addExistingLink(l);\n            }, this);\n            return this.finalGraph;\n        }\n        /**\n         * Maps the specified connection to an edge of the graph deduced from the given diagram.\n         *\n         * @param connection\n         * @returns {*}\n         */\n        mapConnection(connection) {\n            return this.edgeMap.get(connection.id);\n        }\n        /**\n         * Maps the specified shape to a node of the graph deduced from the given diagram.\n         *\n         * @param shape\n         * @returns {*}\n         */\n        mapShape(shape) {\n            return this.nodeMap.get(shape.id);\n        }\n        /**\n         * Gets the edge, if any, between the given nodes.\n         *\n         * @param a\n         * @param b\n         */\n        getEdge(a, b) {\n            return first(a.links, function (link) {\n                return link.getComplement(a) === b;\n            });\n        }\n        /**\n         * Clears all the collections used by the conversion process.\n         */\n        clear() {\n            this.finalGraph = null;\n            this.hyperTree = (!this.options.ignoreContainers && this.options.layoutContainerChildren) ? new Graph() : null;\n            this.hyperMap = (!this.options.ignoreContainers && this.options.layoutContainerChildren) ? new Dictionary() : null;\n            this.nodeMap = new Dictionary();\n            this.shapeMap = new Dictionary();\n            this.nodes = [];\n            this.edges = [];\n            this.edgeMap = new Dictionary();\n            this.ignoredConnections = [];\n            this.ignoredShapes = [];\n            this.finalNodes = [];\n            this.finalLinks = [];\n        }\n        /**\n         * The path from a given ContainerGraph to the root (container).\n         *\n         * @param containerGraph\n         * @returns {Array}\n         */\n        listToRoot(containerGraph) {\n            const list = [];\n            let s = containerGraph.container;\n            if (!s) {\n                return list;\n            }\n            list.push(s);\n            while (s.parentContainer) {\n                s = s.parentContainer;\n                list.push(s);\n            }\n            list.reverse();\n            return list;\n        }\n        firstNonIgnorableContainer(shape) {\n            if (shape.isContainer && !this.isIgnorableItem(shape)) {\n                return shape;\n            }\n            return !shape.parentContainer ? null : this.firstNonIgnorableContainer(shape.parentContainer);\n        }\n        isContainerConnection(a, b) {\n            if (a.isContainer && this.isDescendantOf(a, b)) {\n                return true;\n            }\n            return b.isContainer && this.isDescendantOf(b, a);\n        }\n        /**\n         * Returns true if the given shape is a direct child or a nested container child of the given container.\n         * If the given container and shape are the same this will return false since a shape cannot be its own child.\n         *\n         * @param scope\n         * @param a\n         * @returns {boolean}\n         */\n        isDescendantOf(scope, a) {\n            if (!scope.isContainer) {\n                throw new Error('Expecting a container.');\n            }\n            if (scope === a) {\n                return false;\n            }\n            if (contains(scope.children, a)) {\n                return true;\n            }\n            const containers = [];\n            for (let i = 0, len = scope.children.length; i < len; i++) {\n                const c = scope.children[i];\n                if (c.isContainer && this.isDescendantOf(c, a)) {\n                    containers.push(c);\n                }\n            }\n            return containers.length > 0;\n        }\n        isIgnorableItem(shape) {\n            if (this.options.ignoreInvisible) {\n                if (shape.isCollapsed && this._isVisible(shape)) {\n                    return false;\n                }\n                if (!shape.isCollapsed && this._isVisible(shape)) {\n                    return false;\n                }\n                return true;\n            }\n            else {\n                return shape.isCollapsed && !this._isTop(shape);\n            }\n        }\n        /**\n         *  Determines whether the shape is or needs to be mapped to another shape. This occurs essentially when the shape sits in\n         *  a collapsed container hierarchy and an external connection needs a node endpoint. This node then corresponds to the mapped shape and is\n         *  necessarily a container in the parent hierarchy of the shape.\n         *\n         * @param shape\n         */\n        isShapeMapped(shape) {\n            return shape.isCollapsed && !this._isVisible(shape) && !this._isTop(shape);\n        }\n        leastCommonAncestor(a, b) {\n            if (!a) {\n                throw new Error('Parameter should not be null.');\n            }\n            if (!b) {\n                throw new Error('Parameter should not be null.');\n            }\n            if (!this.hyperTree) {\n                throw new Error('No hypertree available.');\n            }\n            const al = this.listToRoot(a);\n            const bl = this.listToRoot(b);\n            let found = null;\n            if (isEmpty(al) || isEmpty(bl)) {\n                return this.hyperTree.root().data;\n            }\n            let xa = al[0];\n            let xb = bl[0];\n            let i = 0;\n            while (xa === xb) {\n                found = al[i];\n                i++;\n                if (i >= al.length || i >= bl.length) {\n                    break;\n                }\n                xa = al[i];\n                xb = bl[i];\n            }\n            if (!found) {\n                return this.hyperTree.root().data;\n            }\n            else {\n                return this.hyperTree.nodes.filter(function (n) {\n                    return n.data.container === found;\n                });\n            }\n        }\n        /**\n         * Determines whether the specified item is a top-level shape or container.\n         *\n         * @param item\n         * @returns {boolean}\n         * @private\n         */\n        _isTop(item) {\n            return !item.parentContainer;\n        }\n        /**\n         * Determines iteratively (by walking up the container stack) whether the specified shape is visible.\n         * This does NOT tell whether the item is not visible due to an explicit Visibility change or due to a collapse state.\n         *\n         * @param shape\n         * @returns {*}\n         * @private\n         */\n        _isVisible(shape) {\n            if (!shape.visible()) {\n                return false;\n            }\n            return !shape.parentContainer ? shape.visible() : this._isVisible(shape.parentContainer);\n        }\n        _isCollapsed(shape) {\n            if (shape.isContainer && shape.isCollapsed) {\n                return true;\n            }\n            return shape.parentContainer && this._isCollapsed(shape.parentContainer);\n        }\n        /**\n         * First part of the graph creation; analyzing the shapes and containers and deciding whether they should be mapped to a Node.\n         *\n         * @private\n         */\n        _renormalizeShapes() {\n            // add the nodes, the adjacency structure will be reconstructed later on\n            if (this.options.ignoreContainers) {\n                for (let i = 0, len = this.diagram.shapes.length; i < len; i++) {\n                    const shape = this.diagram.shapes[i];\n                    // if not visible (and ignoring the invisible ones) or a container we skip\n                    if ((this.options.ignoreInvisible && !this._isVisible(shape)) || shape.isContainer) {\n                        this.ignoredShapes.push(shape);\n                        continue;\n                    }\n                    const node = new Node(shape.id, shape);\n                    node.isVirtual = false;\n                    // the mapping will always contain singletons and the hyperTree will be null\n                    this.nodeMap.add(shape.id, node);\n                    this.nodes.push(node);\n                }\n            }\n            else {\n                throw new Error('Containers are not supported yet, but stay tuned.');\n            }\n        }\n        /**\n         * Second part of the graph creation; analyzing the connections and deciding whether they should be mapped to an edge.\n         *\n         * @private\n         */\n        _renormalizeConnections() {\n            if (this.diagram.connections.length === 0) {\n                return;\n            }\n            for (let i = 0, len = this.diagram.connections.length; i < len; i++) {\n                const conn = this.diagram.connections[i];\n                if (this.isIgnorableItem(conn)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                let source = !conn.sourceConnector ? null : conn.sourceConnector.shape;\n                let sink = !conn.targetConnector ? null : conn.targetConnector.shape;\n                // no layout for floating connections\n                if (!source || !sink) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                if (contains(this.ignoredShapes, source) && !this.shapeMap.containsKey(source)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                if (contains(this.ignoredShapes, sink) && !this.shapeMap.containsKey(sink)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                // if the endpoint sits in a collapsed container we need the container rather than the shape itself\n                if (this.shapeMap.containsKey(source)) {\n                    source = this.shapeMap[source];\n                }\n                if (this.shapeMap.containsKey(sink)) {\n                    sink = this.shapeMap[sink];\n                }\n                const sourceNode = this.mapShape(source);\n                const sinkNode = this.mapShape(sink);\n                if ((sourceNode === sinkNode) || this.areConnectedAlready(sourceNode, sinkNode)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                if (sourceNode === null || sinkNode === null) {\n                    throw new Error('A shape was not mapped to a node.');\n                }\n                if (this.options.ignoreContainers) {\n                    // much like a floating connection here since at least one end is attached to a container\n                    if (sourceNode.isVirtual || sinkNode.isVirtual) {\n                        this.ignoredConnections.push(conn);\n                        continue;\n                    }\n                    const newEdge = new Link(sourceNode, sinkNode, conn.id, conn);\n                    this.edgeMap.add(conn.id, newEdge);\n                    this.edges.push(newEdge);\n                }\n                else {\n                    throw new Error('Containers are not supported yet, but stay tuned.');\n                }\n            }\n        }\n        areConnectedAlready(n, m) {\n            return getAny(this.edges, function (l) {\n                return l.source === n && l.target === m || l.source === m && l.target === n;\n            });\n        }\n    }\n\n    function intersectLine(start1, end1, start2, end2, isSegment) {\n        const tangensdiff = ((end1.x - start1.x) * (end2.y - start2.y)) - ((end1.y - start1.y) * (end2.x - start2.x));\n        if (isNearZero(tangensdiff)) {\n            // parallel lines\n            return;\n        }\n        const num1 = ((start1.y - start2.y) * (end2.x - start2.x)) - ((start1.x - start2.x) * (end2.y - start2.y));\n        const num2 = ((start1.y - start2.y) * (end1.x - start1.x)) - ((start1.x - start2.x) * (end1.y - start1.y));\n        const r = num1 / tangensdiff;\n        const s = num2 / tangensdiff;\n        if (isSegment && (r < 0 || r > 1 || s < 0 || s > 1)) {\n            // r < 0 => line 1 is below line 2\n            // r > 1 => line 1 is above line 2\n            // s < 0 => line 2 is below line 1\n            // s > 1 => line 2 is above line 1\n            return;\n        }\n        return new Point(start1.x + (r * (end1.x - start1.x)), start1.y + (r * (end1.y - start1.y)));\n    }\n    const Intersect = {\n        lines(start1, end1, start2, end2) {\n            return intersectLine(start1, end1, start2, end2);\n        },\n        segments(start1, end1, start2, end2) {\n            return intersectLine(start1, end1, start2, end2, true);\n        },\n        rectWithLine(rect, start, end) {\n            return Intersect.segments(start, end, rect.topLeft(), rect.topRight()) ||\n                Intersect.segments(start, end, rect.topRight(), rect.bottomRight()) ||\n                Intersect.segments(start, end, rect.bottomLeft(), rect.bottomRight()) ||\n                Intersect.segments(start, end, rect.topLeft(), rect.bottomLeft());\n        },\n        rects(rect1, rect2, angle) {\n            let tl = rect2.topLeft(), tr = rect2.topRight(), bl = rect2.bottomLeft(), br = rect2.bottomRight();\n            const center = rect2.center();\n            if (angle) {\n                tl = tl.rotate(angle, center);\n                tr = tr.rotate(angle, center);\n                bl = bl.rotate(angle, center);\n                br = br.rotate(angle, center);\n            }\n            let intersect = rect1.contains(tl) ||\n                rect1.contains(tr) ||\n                rect1.contains(bl) ||\n                rect1.contains(br) ||\n                Intersect.rectWithLine(rect1, tl, tr) ||\n                Intersect.rectWithLine(rect1, tl, bl) ||\n                Intersect.rectWithLine(rect1, tr, br) ||\n                Intersect.rectWithLine(rect1, bl, br);\n            if (!intersect) { // last possible case is rect1 to be completely within rect2\n                tl = rect1.topLeft();\n                tr = rect1.topRight();\n                bl = rect1.bottomLeft();\n                br = rect1.bottomRight();\n                if (angle) {\n                    const reverseAngle = 360 - angle;\n                    tl = tl.rotate(reverseAngle, center);\n                    tr = tr.rotate(reverseAngle, center);\n                    bl = bl.rotate(reverseAngle, center);\n                    br = br.rotate(reverseAngle, center);\n                }\n                intersect = rect2.contains(tl) ||\n                    rect2.contains(tr) ||\n                    rect2.contains(bl) ||\n                    rect2.contains(br);\n            }\n            return intersect;\n        }\n    };\n\n    const map = (arr, func) => arr.map(func);\n    /**\n     * SVG transformation represented as a vector.\n     */\n    class MatrixVector {\n        constructor(a, b, c, d, e, f) {\n            this.a = a || 0;\n            this.b = b || 0;\n            this.c = c || 0;\n            this.d = d || 0;\n            this.e = e || 0;\n            this.f = f || 0;\n        }\n        fromMatrix(m) {\n            const v = new MatrixVector();\n            v.a = m.a;\n            v.b = m.b;\n            v.c = m.c;\n            v.d = m.d;\n            v.e = m.e;\n            v.f = m.f;\n            return v;\n        }\n    }\n    /**\n     * SVG transformation matrix.\n     */\n    class Matrix {\n        constructor(a, b, c, d, e, f) {\n            this.a = a || 0;\n            this.b = b || 0;\n            this.c = c || 0;\n            this.d = d || 0;\n            this.e = e || 0;\n            this.f = f || 0;\n        }\n        plus(m) {\n            this.a += m.a;\n            this.b += m.b;\n            this.c += m.c;\n            this.d += m.d;\n            this.e += m.e;\n            this.f += m.f;\n        }\n        minus(m) {\n            this.a -= m.a;\n            this.b -= m.b;\n            this.c -= m.c;\n            this.d -= m.d;\n            this.e -= m.e;\n            this.f -= m.f;\n        }\n        times(m) {\n            return new Matrix(this.a * m.a + this.c * m.b, this.b * m.a + this.d * m.b, this.a * m.c + this.c * m.d, this.b * m.c + this.d * m.d, this.a * m.e + this.c * m.f + this.e, this.b * m.e + this.d * m.f + this.f);\n        }\n        apply(p) {\n            return new Point(this.a * p.x + this.c * p.y + this.e, this.b * p.x + this.d * p.y + this.f);\n        }\n        applyRect(r) {\n            return Rect.fromPoints(this.apply(r.topLeft()), this.apply(r.bottomRight()));\n        }\n        toString() {\n            return 'matrix(' + this.a + ' ' + this.b + ' ' + this.c + ' ' + this.d + ' ' + this.e + ' ' + this.f + ')';\n        }\n        static fromSVGMatrix(vm) {\n            const m = new Matrix();\n            m.a = vm.a;\n            m.b = vm.b;\n            m.c = vm.c;\n            m.d = vm.d;\n            m.e = vm.e;\n            m.f = vm.f;\n            return m;\n        }\n        static fromMatrixVector(v) {\n            const m = new Matrix();\n            m.a = v.a;\n            m.b = v.b;\n            m.c = v.c;\n            m.d = v.d;\n            m.e = v.e;\n            m.f = v.f;\n            return m;\n        }\n        static fromList(v) {\n            if (v.length !== 6) {\n                throw new Error('The given list should consist of six elements.');\n            }\n            const m = new Matrix();\n            m.a = v[0];\n            m.b = v[1];\n            m.c = v[2];\n            m.d = v[3];\n            m.e = v[4];\n            m.f = v[5];\n            return m;\n        }\n        static translation(x, y) {\n            const m = new Matrix();\n            m.a = 1;\n            m.b = 0;\n            m.c = 0;\n            m.d = 1;\n            m.e = x;\n            m.f = y;\n            return m;\n        }\n        static unit() {\n            return new Matrix(1, 0, 0, 1, 0, 0);\n        }\n        static rotation(angle, x, y) {\n            const m = new Matrix();\n            m.a = Math.cos(angle * Math.PI / 180);\n            m.b = Math.sin(angle * Math.PI / 180);\n            m.c = -m.b;\n            m.d = m.a;\n            m.e = (x - x * m.a + y * m.b) || 0;\n            m.f = (y - y * m.a - x * m.b) || 0;\n            return m;\n        }\n        static scaling(scaleX, scaleY) {\n            const m = new Matrix();\n            m.a = scaleX;\n            m.b = 0;\n            m.c = 0;\n            m.d = scaleY;\n            m.e = 0;\n            m.f = 0;\n            return m;\n        }\n        static parse(v) {\n            let parts, nums;\n            if (v) {\n                v = v.trim();\n                // of the form \"matrix(...)\"\n                if (v.slice(0, 6).toLowerCase() === 'matrix') {\n                    nums = v.slice(7, v.length - 1).trim();\n                    parts = nums.split(',');\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function (p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                    parts = nums.split(' ');\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function (p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n                // of the form \"(...)\"\n                if (v.slice(0, 1) === '(' && v.slice(v.length - 1) === ')') {\n                    v = v.substr(1, v.length - 1);\n                }\n                if (v.indexOf(',') > 0) {\n                    parts = v.split(',');\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function (p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n                if (v.indexOf(' ') > 0) {\n                    parts = v.split(' ');\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function (p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n            }\n            return parts;\n        }\n    }\n\n    /**\n     * Returns a value with Gaussian (normal) distribution.\n     *\n     * @param mean The mean value of the distribution.\n     * @param deviation The deviation (spreading at half-height) of the distribution.\n     * @returns {number}\n     */\n    function normalVariable(mean, deviation) {\n        let x, y, r;\n        do {\n            x = Math.random() * 2 - 1;\n            y = Math.random() * 2 - 1;\n            r = x * x + y * y;\n        } while (!r || r > 1);\n        return mean + deviation * x * Math.sqrt(-2 * Math.log(r) / r);\n    }\n\n    /**\n     * Structure combining a Point with two additional points representing the handles or tangents attached to the first point.\n     * If the additional points are null or equal to the first point the path will be sharp.\n     * Left and right correspond to the direction of the underlying path.\n     */\n    class PathDefiner {\n        constructor(p, left, right) {\n            this.point = p;\n            this.left = left;\n            this.right = right;\n        }\n    }\n\n    /**\n     * While other data structures can have multiple times the same item a Set owns only\n     * once a particular item.\n     *\n     * @type {*}\n     */\n    class Set extends Observable {\n        constructor(resource) {\n            super();\n            this._hashTable = new HashTable();\n            this.length = 0;\n            if (isDefined(resource)) {\n                if (resource instanceof HashTable) {\n                    resource.forEach(function (d) {\n                        this.add(d);\n                    });\n                }\n                else if (resource instanceof Dictionary) {\n                    resource.forEach(function (k, v) {\n                        this.add({ key: k, value: v });\n                    }, this);\n                }\n            }\n        }\n        contains(item) {\n            return this._hashTable.containsKey(item);\n        }\n        add(item) {\n            const entry = this._hashTable.get(item);\n            if (!entry) {\n                this._hashTable.add(item, item);\n                this.length++;\n                this.trigger('changed');\n            }\n        }\n        get(item) {\n            if (this.contains(item)) {\n                return this._hashTable.get(item).value;\n            }\n            else {\n                return null;\n            }\n        }\n        /**\n         * Returns the hash of the item.\n         *\n         * @param item\n         * @returns {*}\n         */\n        hash(item) {\n            return this._hashTable._hash(item);\n        }\n        /**\n         * Removes the given item from the set. No exception is thrown if the item is not in the Set.\n         *\n         * @param item\n         */\n        remove(item) {\n            if (this.contains(item)) {\n                this._hashTable.remove(item);\n                this.length--;\n                this.trigger('changed');\n            }\n        }\n        /**\n         * Foreach with an iterator working on the key-value pairs.\n         *\n         * @param func\n         */\n        forEach(func, context) {\n            const call = context ? func.bind(context) : func;\n            this._hashTable.forEach(function (kv) {\n                call(kv.value);\n            });\n        }\n        toArray() {\n            const r = [];\n            this.forEach(function (d) {\n                r.push(d);\n            });\n            return r;\n        }\n    }\n\n    class Size {\n        constructor(width, height) {\n            this.width = width;\n            this.height = height;\n        }\n        static Empty() {\n            return new Size(0, 0);\n        }\n    }\n\n    /**\n     * Represents a rotation transformation with angle and optional center point.\n     * Provides methods to convert to matrix form and create inverse transformations.\n     */\n    class Rotation {\n        /**\n         * Creates a new Rotation transformation.\n         * @param angle The rotation angle in radians\n         * @param x The x coordinate of the rotation center (optional)\n         * @param y The y coordinate of the rotation center (optional)\n         */\n        constructor(angle, x, y) {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.angle = angle;\n        }\n        /**\n         * Returns a string representation of the rotation transformation.\n         * @returns String representation in CSS transform format\n         */\n        toString() {\n            if (this.x && this.y) {\n                return `rotate(${this.angle},${this.x},${this.y})`;\n            }\n            else {\n                return `rotate(${this.angle})`;\n            }\n        }\n        /**\n         * Converts the rotation transformation to a matrix representation.\n         * @returns A matrix representing the rotation transformation\n         */\n        toMatrix() {\n            return Matrix.rotation(this.angle, this.x, this.y); // T*R*T^-1\n        }\n        /**\n         * Gets the center point of the rotation.\n         * @returns A Point representing the rotation center\n         */\n        center() {\n            return new Point(this.x, this.y);\n        }\n        /**\n         * Creates an inverted version of this rotation transformation.\n         * @returns A new Rotation with inverted angle\n         */\n        invert() {\n            return new Rotation(FULL_CIRCLE_ANGLE - this.angle, this.x, this.y);\n        }\n        /**\n         * Creates a new Rotation instance from an existing rotation.\n         * @param rotation The rotation to copy\n         * @returns A new Rotation instance\n         */\n        static create(rotation) {\n            return new Rotation(rotation.angle, rotation.x, rotation.y);\n        }\n        /**\n         * Parses a rotation from a string representation.\n         * @param str The string to parse\n         * @returns A new Rotation instance\n         */\n        static parse(str) {\n            const values = str.slice(1, str.length - 1).split(',');\n            const angle = parseFloat(values[0]);\n            const x = parseFloat(values[1]);\n            const y = parseFloat(values[2]);\n            return new Rotation(angle, x, y);\n        }\n    }\n    /** A static instance representing zero rotation. */\n    Rotation.ZERO = new Rotation(0);\n\n    /**\n     * Represents a scaling transformation with separate x and y scaling factors.\n     * Provides methods to convert to matrix form and create inverse transformations.\n     */\n    class Scale {\n        /**\n         * Creates a new Scale transformation.\n         * @param x The scaling factor for the x-axis\n         * @param y The scaling factor for the y-axis\n         */\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        /**\n         * Converts the scaling transformation to a matrix representation.\n         * @returns A matrix representing the scaling transformation\n         */\n        toMatrix() {\n            return Matrix.scaling(this.x, this.y);\n        }\n        /**\n         * Returns a string representation of the scaling transformation.\n         * @returns String representation in CSS transform format\n         */\n        toString() {\n            return `scale(${this.x},${this.y})`;\n        }\n        /**\n         * Creates an inverted version of this scaling transformation.\n         * @returns A new Scale with inverted scaling factors\n         */\n        invert() {\n            return new Scale(1 / this.x, 1 / this.y);\n        }\n    }\n    ;\n\n    /**\n     * Represents a translation transformation with x and y offset values.\n     * Provides methods to convert to matrix form and perform vector operations.\n     */\n    class Translation {\n        /**\n         * Creates a new Translation transformation.\n         * @param x The x offset\n         * @param y The y offset\n         */\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        /**\n         * Converts the translation to a matrix vector representation.\n         * @returns A MatrixVector representing the translation\n         */\n        toMatrixVector() {\n            return new MatrixVector(0, 0, 0, 0, this.x, this.y);\n        }\n        /**\n         * Converts the translation transformation to a matrix representation.\n         * @returns A matrix representing the translation transformation\n         */\n        toMatrix() {\n            return Matrix.translation(this.x, this.y);\n        }\n        /**\n         * Returns a string representation of the translation transformation.\n         * @returns String representation in CSS transform format\n         */\n        toString() {\n            return `translate(${this.x},${this.y})`;\n        }\n        /**\n         * Adds another translation to this one.\n         * @param delta The translation to add\n         */\n        plus(delta) {\n            this.x += delta.x;\n            this.y += delta.y;\n        }\n        /**\n         * Multiplies the translation by a scaling factor.\n         * @param factor The scaling factor to apply\n         */\n        times(factor) {\n            this.x *= factor;\n            this.y *= factor;\n        }\n        /**\n         * Calculates the length (magnitude) of the translation vector.\n         * @returns The length of the translation vector\n         */\n        length() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        }\n        /**\n         * Normalizes the translation vector to unit length.\n         */\n        normalize() {\n            if (this.Length === 0) {\n                return;\n            }\n            this.times(1 / this.length());\n        }\n        /**\n         * Creates an inverted version of this translation transformation.\n         * @returns A new Translation with inverted offsets\n         */\n        invert() {\n            return new Translation(-this.x, -this.y);\n        }\n    }\n\n    /**\n     * A composite transformation that combines translation, rotation, and scaling operations.\n     * Provides methods to apply multiple transformations as a single matrix operation.\n     */\n    class CompositeTransform {\n        /**\n         * Creates a new CompositeTransform instance.\n         * @param x The x translation offset\n         * @param y The y translation offset\n         * @param scaleX The x scaling factor\n         * @param scaleY The y scaling factor\n         * @param angle The rotation angle in radians\n         * @param center The center point for rotation\n         */\n        constructor(x, y, scaleX, scaleY, angle, center) {\n            this.translate = new Translation(x, y);\n            if (scaleX !== undefined && scaleY !== undefined) {\n                this.scale = new Scale(scaleX, scaleY);\n            }\n            if (angle !== undefined) {\n                this.rotate = center ? new Rotation(angle, center.x, center.y) : new Rotation(angle);\n            }\n        }\n        /**\n         * Returns a string representation of the composite transformation.\n         * @returns String representation of all transformations\n         */\n        toString() {\n            const toString = function (transform) {\n                return transform ? transform.toString() : '';\n            };\n            return toString(this.translate) +\n                toString(this.rotate) +\n                toString(this.scale);\n        }\n        /**\n         * Renders the transformation by applying it to a visual element.\n         * @param visual The visual element to apply the transformation to\n         */\n        render(visual) {\n            visual._transform = this;\n            visual._renderTransform();\n        }\n        /**\n         * Converts the composite transformation to a matrix representation.\n         * @returns A matrix representing the combined transformations\n         */\n        toMatrix() {\n            let m = Matrix.unit();\n            if (this.translate) {\n                m = m.times(this.translate.toMatrix());\n            }\n            if (this.rotate) {\n                m = m.times(this.rotate.toMatrix());\n            }\n            if (this.scale) {\n                m = m.times(this.scale.toMatrix());\n            }\n            return m;\n        }\n        /**\n         * Creates an inverted version of this composite transformation.\n         * @returns A new CompositeTransform that represents the inverse transformation\n         */\n        invert() {\n            const rotate = this.rotate ? this.rotate.invert() : undefined, rotateMatrix = rotate ? rotate.toMatrix() : Matrix.unit(), scale = this.scale ? this.scale.invert() : undefined, scaleMatrix = scale ? scale.toMatrix() : Matrix.unit();\n            let translatePoint = new Point(-this.translate.x, -this.translate.y);\n            translatePoint = rotateMatrix.times(scaleMatrix).apply(translatePoint);\n            const translate = new Translation(translatePoint.x, translatePoint.y);\n            const transform = new CompositeTransform();\n            transform.translate = translate;\n            transform.rotate = rotate;\n            transform.scale = scale;\n            return transform;\n        }\n    }\n\n    /**\n     * Compares numeric options and updates element options if they have changed.\n     * @param options - The new options to compare against\n     * @param fields - Array of field names to check for changes\n     * @returns True if any numeric options have changed, false otherwise\n     */\n    function diffNumericOptions(options, fields) {\n        const elementOptions = this.options;\n        let hasChanges = false;\n        let value, field;\n        for (let i = 0; i < fields.length; i++) {\n            field = fields[i];\n            value = options[field];\n            if (isNumber(value) && elementOptions[field] !== value) {\n                elementOptions[field] = value;\n                hasChanges = true;\n            }\n        }\n        return hasChanges;\n    }\n\n    /**\n     * Base class for all visual elements in the diagram system.\n     * Provides core functionality for positioning, transformation, and drawing operations.\n     */\n    class Element {\n        /**\n         * Creates a new Element instance.\n         * @param options Configuration options for the element\n         */\n        constructor(options) {\n            this.options = deepExtend({}, this.options, options);\n            this.id = this.options.id;\n            this._originSize = Rect.empty();\n            this._transform = new CompositeTransform();\n        }\n        /**\n         * Gets or sets the visibility of the element.\n         * @param value The visibility value to set, or undefined to get current visibility\n         * @returns The current visibility state when called as getter\n         */\n        visible(value) {\n            return this.drawingContainer().visible(value);\n        }\n        /**\n         * Redraws the element with updated options.\n         * @param options New options to apply to the element\n         */\n        redraw(options) {\n            if (options && options.id) {\n                this.id = options.id;\n            }\n        }\n        /**\n         * Gets or sets the position of the element.\n         * @param x The x coordinate or Point object, or undefined to get current position\n         * @param y The y coordinate when x is a number\n         * @returns The current position as a Point when called as getter\n         */\n        position(x, y) {\n            const options = this.options;\n            if (!defined(x)) {\n                return new Point(options.x, options.y);\n            }\n            if (defined(y)) {\n                options.x = x;\n                options.y = y;\n            }\n            else if (x instanceof Point) {\n                options.x = x.x;\n                options.y = x.y;\n            }\n            this._transform.translate = new Translation(options.x, options.y);\n            this._renderTransform();\n        }\n        /**\n         * Gets or sets the rotation of the element.\n         * @param angle The rotation angle in radians, or undefined to get current rotation\n         * @param center The center point for rotation\n         * @returns The current rotation when called as getter\n         */\n        rotate(angle, center) {\n            if (defined(angle)) {\n                this._transform.rotate = new Rotation(angle, center.x, center.y);\n                this._renderTransform();\n            }\n            return this._transform.rotate || Rotation.ZERO;\n        }\n        /**\n         * Gets the drawing container for this element.\n         * @returns The drawing element container\n         */\n        drawingContainer() {\n            return this.drawingElement;\n        }\n        /** @hidden */\n        _renderTransform() {\n            const matrix = this._transform.toMatrix();\n            this.drawingContainer().transform(new kendo_drawing_cmn_chunk_js.M(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f));\n        }\n        /** @hidden */\n        _hover() { }\n        /** @hidden */\n        _diffNumericOptions(options, fields) {\n            return diffNumericOptions.call(this, options, fields);\n        }\n        /** @hidden */\n        _measure(force) {\n            let rect;\n            if (!this._measured || force) {\n                const box = this._boundingBox() || new kendo_drawing_cmn_chunk_js.R([0, 0], [0, 0]);\n                const startPoint = box.topLeft();\n                rect = new Rect(startPoint.x, startPoint.y, box.width(), box.height());\n                this._originSize = rect;\n                this._originWidth = rect.width;\n                this._originHeight = rect.height;\n                this._measured = true;\n            }\n            else {\n                rect = this._originSize;\n            }\n            return rect;\n        }\n        /** @hidden */\n        _boundingBox() {\n            return this.drawingElement.rawBBox();\n        }\n    }\n\n    /**\n     * Gets size options from configuration or returns default values.\n     * @param options - The options object to extract size values from\n     * @returns An object containing x, y, width, and height values\n     */\n    function sizeOptionsOrDefault(options) {\n        return {\n            x: options.x || 0,\n            y: options.y || 0,\n            width: options.width || 0,\n            height: options.height || 0\n        };\n    }\n    /**\n     * Normalizes drawing options to ensure consistent format.\n     * @param options - The drawing options to normalize\n     * @returns Normalized drawing options with proper color format\n     */\n    function normalizeDrawingOptions(options) {\n        if (options) {\n            let drawingOptions = options;\n            if (isString$1(drawingOptions)) {\n                drawingOptions = {\n                    color: drawingOptions\n                };\n            }\n            if (drawingOptions.color) {\n                drawingOptions.color = getColor(drawingOptions.color);\n            }\n            return drawingOptions;\n        }\n    }\n    /**\n     * Converts a color value to a proper hex color format.\n     * @param value - The color value to convert\n     * @returns The converted color in hex format or the original value for transparent\n     */\n    function getColor(value) {\n        let color;\n        if (value !== TRANSPARENT) {\n            color = new kendo_drawing_cmn_chunk_js.C(value).toHex();\n        }\n        else {\n            color = value;\n        }\n        return color;\n    }\n    /**\n     * Calculates the angle of a line between two points.\n     * @param p1 - The first point\n     * @param p2 - The second point\n     * @returns The angle in degrees between the two points\n     */\n    function lineAngle(p1, p2) {\n        const xDiff = p2.x - p1.x;\n        const yDiff = p2.y - p1.y;\n        const angle = kendo_drawing_cmn_chunk_js.q(Math.atan2(yDiff, xDiff));\n        return angle;\n    }\n    /**\n     * Creates a path segment from x and y coordinates.\n     * @param x - The x coordinate\n     * @param y - The y coordinate\n     * @returns A new path segment\n     */\n    function createSegment(x, y) {\n        return new kendo_drawing_cmn_chunk_js.S(new kendo_drawing_cmn_chunk_js.P(x, y));\n    }\n    /**\n     * Converts a rectangle to a drawing rectangle format.\n     * @param rect - The rectangle to convert\n     * @returns A drawing rectangle or undefined if rect is not provided\n     */\n    function toDrawingRect(rect) {\n        if (rect) {\n            return new kendo_drawing_cmn_chunk_js.R([rect.x, rect.y], [rect.width, rect.height]);\n        }\n    }\n    /**\n     * Removes all child elements from a DOM element.\n     * @param element - The DOM element to remove children from\n     */\n    function removeChildren$1(element) {\n        while (element.firstChild) {\n            element.removeChild(element.firstChild);\n        }\n    }\n    /**\n     * Gets spacing values from a number or spacing object.\n     * @param value - The spacing value as number or object with side-specific values\n     * @param defaultSpacing - Default spacing value to use for undefined sides\n     * @returns A complete spacing object with values for all four sides\n     */\n    function getSpacing(value, defaultSpacing = 0) {\n        const spacing = { top: 0, right: 0, bottom: 0, left: 0 };\n        if (typeof value === 'number') {\n            spacing.top = spacing.right = spacing.bottom = spacing.left = value;\n        }\n        else {\n            spacing.top = value.top || defaultSpacing;\n            spacing.right = value.right || defaultSpacing;\n            spacing.bottom = value.bottom || defaultSpacing;\n            spacing.left = value.left || defaultSpacing;\n        }\n        return spacing;\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     * @param path - The path or multipath to draw on\n     * @param points - Array of points defining the polygon vertices\n     * @param r - Corner radius value or array of radius values per vertex\n     */\n    const drawRoundedPolygon = (path, points, r) => {\n        const n = points.length;\n        for (let i = 0; i < n; i++) {\n            const prev = points[(i + n - 1) % n];\n            const curr = points[i];\n            const next = points[(i + 1) % n];\n            const cornerRadius = Array.isArray(r) ? r[i] : r;\n            // --- vectors from the vertex to the neighbors ---\n            const v1 = { x: prev.x - curr.x, y: prev.y - curr.y };\n            const v2 = { x: next.x - curr.x, y: next.y - curr.y };\n            const len1 = Math.hypot(v1.x, v1.y);\n            const len2 = Math.hypot(v2.x, v2.y);\n            // --- internal angle  (phi) ---\n            const cosPhi = (v1.x * v2.x + v1.y * v2.y) / (len1 * len2);\n            const phi = Math.acos(Math.max(-1, Math.min(1, cosPhi))); // clamp for safety\n            // --- distance s = r / tan(/2) ---\n            const ds = cornerRadius / Math.tan(phi / 2);\n            // --- clamp if the side is too short ---\n            const dsClamped = Math.min(ds, len1 - 1e-3, len2 - 1e-3);\n            // --- tangent points ---\n            const start = {\n                x: curr.x + (v1.x / len1) * dsClamped,\n                y: curr.y + (v1.y / len1) * dsClamped\n            };\n            const end = {\n                x: curr.x + (v2.x / len2) * dsClamped,\n                y: curr.y + (v2.y / len2) * dsClamped\n            };\n            // --- first / next segments ---\n            if (i === 0) {\n                path.moveTo(start.x, start.y);\n            }\n            else {\n                path.lineTo(start.x, start.y);\n            }\n            // --- direction of the arc (CW / CCW) ---\n            const cross = v1.x * v2.y - v1.y * v2.x; // z-component\n            const sweep = cross < 0; // for CW sweep (Canvas Y axis down)\n            // --- always the short arc (largeArc = false) ---\n            path.arcTo([end.x, end.y], cornerRadius, cornerRadius, /*largeArc*/ false, sweep);\n        }\n        path.close();\n    };\n    /**\n     * Draws a polygon by connecting a series of points.\n     * @param path - The path or multipath to draw on\n     * @param points - Array of points defining the polygon vertices\n     */\n    const drawPolygon = (path, points) => {\n        const n = points.length;\n        for (let i = 0; i < n; i++) {\n            const point = points[i];\n            if (i === 0) {\n                path.moveTo(point.x, point.y);\n            }\n            else {\n                path.lineTo(point.x, point.y);\n            }\n        }\n        path.close();\n    };\n    /**\n     * Scales and positions a drawing element to fit within specified dimensions.\n     * @param drawingElement - The path or multipath element to fit\n     * @param width - Target width\n     * @param height - Target height\n     * @param strokeWidth - Stroke width to account for in sizing\n     */\n    const fitToSize = (drawingElement, width, height, strokeWidth) => {\n        const bb = drawingElement.bbox();\n        if (!bb.size.width || !bb.size.height) {\n            return;\n        }\n        const targetW = width + strokeWidth;\n        const targetH = height + strokeWidth;\n        const sx = targetW / bb.size.width;\n        const sy = targetH / bb.size.height;\n        drawingElement.transform(new kendo_drawing_cmn_chunk_js.v(new kendo_drawing_cmn_chunk_js.M(sx, 0, 0, sy, -bb.origin.x * sx, -bb.origin.y * sy)));\n    };\n    /**\n     * Inflates (expands outward) a polygon by moving each vertex along the external bisector.\n     * @param points - Array of points defining the polygon vertices\n     * @param r - Inflation radius value or array of radius values per vertex\n     * @returns Array of inflated polygon points\n     */\n    function inflatePolygon(points, r) {\n        const n = points.length;\n        const out = [];\n        for (let i = 0; i < n; i++) {\n            const prev = points[(i + n - 1) % n];\n            const curr = points[i];\n            const next = points[(i + 1) % n];\n            const radius = Array.isArray(r) ? r[i] : r;\n            // --- vectors to the neighbors ---\n            const v1 = { x: prev.x - curr.x, y: prev.y - curr.y };\n            const v2 = { x: next.x - curr.x, y: next.y - curr.y };\n            const len1 = Math.hypot(v1.x, v1.y);\n            const len2 = Math.hypot(v2.x, v2.y);\n            // --- normalized ---\n            const n1 = { x: v1.x / len1, y: v1.y / len1 };\n            const n2 = { x: v2.x / len2, y: v2.y / len2 };\n            // --- internal angle  (phi) ---\n            const phi = Math.acos(Math.max(-1, Math.min(1, n1.x * n2.x + n1.y * n2.y)));\n            // --- distance  along the external bisector ---\n            const delta = radius / Math.sin(phi / 2) - radius;\n            // --- internal bisector ---\n            let b = { x: n1.x + n2.x, y: n1.y + n2.y };\n            const bLen = Math.hypot(b.x, b.y);\n            b = { x: b.x / bLen, y: b.y / bLen };\n            // --- external bisector = -internal bisector (for clockwise polygon) ---\n            const outDir = { x: -b.x, y: -b.y };\n            out.push({\n                x: curr.x + outDir.x * delta,\n                y: curr.y + outDir.y * delta\n            });\n        }\n        return out;\n    }\n\n    const defaultOptions$n = {\n        stroke: {\n            color: 'gray',\n            width: 1\n        },\n        fill: {\n            color: TRANSPARENT\n        }\n    };\n    /**\n     * Base class for visual elements that can be rendered with fill and stroke properties.\n     * Extends Element and provides common functionality for visual styling and drawing operations.\n     */\n    class VisualBase extends Element {\n        /**\n         * Creates a new VisualBase instance.\n         * @param options Configuration options for the visual element\n         */\n        constructor(options) {\n            options = deepExtend({}, defaultOptions$n, options);\n            super(options);\n            options = this.options;\n            options.fill = normalizeDrawingOptions(options.fill);\n            options.stroke = normalizeDrawingOptions(options.stroke);\n        }\n        /**\n         * Sets the fill color and opacity of the visual element.\n         * @param color The fill color\n         * @param opacity The fill opacity (optional)\n         */\n        fill(color, opacity) {\n            this._fill({\n                color: getColor(color),\n                opacity: opacity\n            });\n        }\n        /**\n         * Sets the stroke color, width, and opacity of the visual element.\n         * @param color The stroke color\n         * @param width The stroke width\n         * @param opacity The stroke opacity\n         */\n        stroke(color, width, opacity) {\n            this._stroke({\n                color: getColor(color),\n                width: width,\n                opacity: opacity\n            });\n        }\n        /**\n         * Redraws the visual element with updated options.\n         * @param options New options to apply to the visual element\n         */\n        redraw(options) {\n            if (options) {\n                const stroke = options.stroke;\n                const fill = options.fill;\n                if (stroke) {\n                    this._stroke(normalizeDrawingOptions(stroke));\n                }\n                if (fill) {\n                    this._fill(normalizeDrawingOptions(fill));\n                }\n                super.redraw(options);\n            }\n        }\n        /** @hidden */\n        _hover(show) {\n            const options = this.options;\n            const hover = options.hover;\n            if (hover && hover.fill) {\n                const fill = show ? normalizeDrawingOptions(hover.fill) : options.fill;\n                this._setFill(fill);\n            }\n        }\n        /** @hidden */\n        _setFill(fill) {\n            this.drawingElement.fill(fill.color, fill.opacity);\n        }\n        /** @hidden */\n        _evalStrokeOptions(strokeOptions) {\n            const options = this.options;\n            deepExtend(options, {\n                stroke: strokeOptions\n            });\n            strokeOptions = options.stroke;\n            let stroke = null;\n            if (strokeOptions.width > 0) {\n                stroke = {\n                    color: strokeOptions.color,\n                    width: strokeOptions.width,\n                    opacity: strokeOptions.opacity,\n                    dashType: strokeOptions.dashType\n                };\n            }\n            return stroke;\n        }\n        /** @hidden */\n        _evalFillOptions(fillOptions) {\n            const options = this.options;\n            deepExtend(options, {\n                fill: fillOptions || {}\n            });\n            return options.fill;\n        }\n        /** @hidden */\n        _stroke(strokeOptions) {\n            const stroke = this._evalStrokeOptions(strokeOptions);\n            this.drawingElement.options.set('stroke', stroke);\n        }\n        /** @hidden */\n        _fill(fillOptions) {\n            const fill = this._evalFillOptions(fillOptions);\n            if (fill.gradient) {\n                const gradient = fill.gradient;\n                const GradientClass = (gradient.type === 'radial' ? kendo_drawing_cmn_chunk_js.h : kendo_drawing_cmn_chunk_js.L);\n                this.drawingElement.fill(new GradientClass(gradient));\n            }\n            else {\n                this.drawingElement.fill(fill.color, fill.opacity);\n            }\n        }\n    }\n\n    const defaultOptions$m = {\n        stroke: {\n            color: TRANSPARENT,\n            width: 0\n        },\n        fill: {\n            color: 'black'\n        }\n    };\n    /**\n     * Base class for visual markers that can be positioned on paths.\n     * Extends VisualBase and provides common functionality for marker positioning and transformation.\n     */\n    class MarkerBase extends VisualBase {\n        /**\n         * Creates a new MarkerBase instance.\n         * @param options Configuration options for the marker\n         */\n        constructor(options) {\n            options = deepExtend({}, defaultOptions$m, options);\n            super(options);\n            const anchor = this.options.anchor || {};\n            this.anchor = new kendo_drawing_cmn_chunk_js.P(anchor.x, anchor.y);\n            this.createElement();\n        }\n        /**\n         * Creates the drawing element for the marker. Should be overridden by subclasses.\n         */\n        createElement() { }\n        /** @hidden */\n        _transformToPath(point, path) {\n            const transform = path.transform();\n            if (point && transform) {\n                point = point.transformCopy(transform);\n            }\n            return point;\n        }\n        /**\n         * Redraws the marker with updated options.\n         * @param options New options to apply to the marker\n         */\n        redraw(options) {\n            if (options) {\n                if (options.position) {\n                    this.options.position = options.position;\n                }\n                super.redraw(options);\n            }\n        }\n    }\n\n    /**\n     * An object that defines the default options for the arrow marker.\n     */\n    const defaultArrowOptions = {\n        path: 'M 0 0 L 10 5 L 0 10 L 3 5 z',\n        anchor: {\n            x: 10,\n            y: 5\n        }\n    };\n    /**\n     * An object that defines the line arrow options for the arrow marker.\n     */\n    const lineArrowOptions = {\n        path: 'M 0 0 L 8 7 L 0 14',\n        anchor: {\n            x: 8,\n            y: 7\n        },\n        fill: null,\n        stroke: {\n            color: '#000',\n            lineCap: 'round',\n            lineJoin: 'round',\n            width: 1\n        }\n    };\n    /**\n     * An object that defines the triangle arrow options for the arrow marker.\n     */\n    const triangleArrowOptions = {\n        path: 'M 0 0 L 8.5 5 L 0 10 L 0 0 z',\n        anchor: {\n            x: 8.5,\n            y: 5\n        }\n    };\n    /**\n     * A visual marker that renders an arrow shape at the start or end of a path.\n     * Extends MarkerBase to provide arrow-specific positioning and rendering functionality.\n     */\n    class ArrowMarker extends MarkerBase {\n        /**\n         * Creates a new ArrowMarker instance.\n         * @param options Configuration options for the arrow marker\n         */\n        constructor(options) {\n            options = deepExtend({}, defaultArrowOptions, options);\n            super(options);\n        }\n        /**\n         * Creates the drawing element for the arrow marker.\n         */\n        createElement() {\n            const options = this.options;\n            this.drawingElement = kendo_drawing_cmn_chunk_js.a.parse(options.path, {\n                fill: options.fill,\n                stroke: options.stroke\n            });\n        }\n        /**\n         * Positions the arrow marker on the specified path.\n         * @param path The path on which to position the arrow marker\n         */\n        positionMarker(path) {\n            const points = this._linePoints(path);\n            const start = points.start;\n            const end = points.end;\n            const transform$1 = kendo_drawing_cmn_chunk_js.t();\n            if (start) {\n                transform$1.rotate(lineAngle(start, end), end);\n            }\n            if (end) {\n                const anchor = this.anchor;\n                const translate = end.clone().translate(-anchor.x, -anchor.y);\n                transform$1.translate(translate.x, translate.y);\n            }\n            this.drawingElement.transform(transform$1);\n        }\n        /** @hidden */\n        _linePoints(path) {\n            const options = this.options;\n            const segments = path.segments;\n            let startPoint, endPoint, targetSegment;\n            if (options.position === START$1) {\n                targetSegment = segments[0];\n                if (targetSegment) {\n                    endPoint = targetSegment.anchor();\n                    startPoint = targetSegment.controlOut();\n                    const nextSegment = segments[1];\n                    if (!startPoint && nextSegment) {\n                        startPoint = nextSegment.anchor();\n                    }\n                }\n            }\n            else {\n                targetSegment = segments[segments.length - 1];\n                if (targetSegment) {\n                    endPoint = targetSegment.anchor();\n                    startPoint = targetSegment.controlIn();\n                    const prevSegment = segments[segments.length - 2];\n                    if (!startPoint && prevSegment) {\n                        startPoint = prevSegment.anchor();\n                    }\n                }\n            }\n            if (endPoint) {\n                return {\n                    start: this._transformToPath(startPoint, path),\n                    end: this._transformToPath(endPoint, path)\n                };\n            }\n        }\n    }\n\n    /**\n     * A canvas that provides a drawing surface for rendering visual elements.\n     * Manages the underlying drawing surface and provides methods for drawing operations.\n     */\n    let Canvas$1 = class Canvas {\n        /**\n         * Creates a new Canvas instance.\n         * @param element The HTML element to attach the canvas to\n         * @param options Configuration options for the canvas\n         */\n        constructor(element, options) {\n            /** @hidden */\n            this._translate = (x, y) => {\n                const viewBox = this._viewBox;\n                if (defined(x) && defined(y)) {\n                    viewBox.x = x;\n                    viewBox.y = y;\n                    this.surface.translate({ x: x, y: y });\n                }\n                return {\n                    x: viewBox.x,\n                    y: viewBox.y\n                };\n            };\n            this.element = element;\n            this.surface = kendo_drawing_cmn_chunk_js.k.create(element, options);\n            if (isFunction$1(this.surface.translate)) {\n                this.translate = this._translate;\n            }\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.G();\n            this._viewBox = new Rect(0, 0, options.width, options.height);\n            this.size(this._viewBox);\n        }\n        /**\n         * Gets the bounding box of all drawing elements on the canvas.\n         * @returns A rectangle representing the bounds of the canvas content\n         */\n        bounds() {\n            const box = this.drawingElement.clippedBBox();\n            return new Rect(0, 0, box.width(), box.height());\n        }\n        /**\n         * Gets or sets the size of the canvas.\n         * @param size The size to set, or undefined to get current size\n         * @returns The current size when called as getter\n         */\n        size(size) {\n            const viewBox = this._viewBox;\n            if (defined(size)) {\n                viewBox.width = size.width;\n                viewBox.height = size.height;\n                this.surface.setSize(size);\n            }\n            return {\n                width: viewBox.width,\n                height: viewBox.height\n            };\n        }\n        /**\n         * Draws all visual elements to the canvas surface.\n         */\n        draw() {\n            this.surface.draw(this.drawingElement);\n        }\n        /**\n         * Appends a visual element to the canvas.\n         * @param visual The visual element to append\n         * @returns The canvas instance for method chaining\n         */\n        append(visual) {\n            this.drawingElement.append(visual.drawingContainer());\n            return this;\n        }\n        /**\n         * Removes a visual element from the canvas.\n         * @param visual The visual element to remove\n         */\n        remove(visual) {\n            this.drawingElement.remove(visual.drawingContainer());\n        }\n        /**\n         * Inserts a visual element before another element (currently not implemented).\n         */\n        insertBefore() { }\n        /**\n         * Clears all visual elements from the canvas.\n         */\n        clear() {\n            this.drawingElement.clear();\n        }\n        /**\n         * Destroys the canvas and optionally removes the HTML element.\n         * @param clearHtml Whether to remove the HTML element from the DOM\n         */\n        destroy(clearHtml) {\n            this.surface.destroy();\n            if (clearHtml) {\n                removeChildren$1(this.element);\n                this.element.remove();\n            }\n        }\n    };\n\n    /**\n     * Mixin that provides automatic sizing and positioning capabilities for visual elements.\n     * Can be mixed into classes to add automatic scaling and translation functionality.\n     */\n    const AutoSizeableMixin = {\n        /**\n         * @hidden\n         * Sets the scale transformation based on the difference between original and target dimensions.\n         */\n        _setScale: function () {\n            const options = this.options;\n            const originWidth = this._originWidth;\n            const originHeight = this._originHeight;\n            let scaleX = options.width / originWidth;\n            let scaleY = options.height / originHeight;\n            if (!isNumber(scaleX)) {\n                scaleX = 1;\n            }\n            if (!isNumber(scaleY)) {\n                scaleY = 1;\n            }\n            this._transform.scale = new Scale(scaleX, scaleY);\n        },\n        /**\n         * @hidden\n         * Sets the translation transformation based on x and y position options.\n         */\n        _setTranslate: function () {\n            const options = this.options;\n            const x = options.x || 0;\n            const y = options.y || 0;\n            this._transform.translate = new Translation(x, y);\n        },\n        /**\n         * @hidden\n         * Initializes the element size by setting up scaling and translation transforms.\n         */\n        _initSize: function () {\n            const options = this.options;\n            let transform = false;\n            if (options.autoSize !== false && (isDefined(options.width) || isDefined(options.height))) {\n                this._measure(true);\n                this._setScale();\n                transform = true;\n            }\n            if (isDefined(options.x) || isDefined(options.y)) {\n                this._setTranslate();\n                transform = true;\n            }\n            if (transform) {\n                this._renderTransform();\n            }\n        },\n        /**\n         * @hidden\n         * Updates the element size and position based on new options.\n         * @param options - The new options to apply\n         * @returns True if the element was updated, false otherwise\n         */\n        _updateSize: function (options) {\n            let update = false;\n            if (this.options.autoSize !== false && this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n                update = true;\n                this._measure(true);\n                this._setScale();\n            }\n            if (this._diffNumericOptions(options, [X, Y])) {\n                update = true;\n                this._setTranslate();\n            }\n            if (update) {\n                this._renderTransform();\n            }\n            return update;\n        }\n    };\n\n    /**\n     * A visual element that renders a circle shape.\n     * Extends VisualBase and provides functionality for creating and managing circular graphics.\n     */\n    class Circle extends VisualBase {\n        /**\n         * Creates a new Circle instance.\n         * @param options Configuration options for the circle\n         */\n        constructor(options) {\n            super(options);\n            // Bind mixin methods to current instance\n            this._setScale = AutoSizeableMixin._setScale.bind(this);\n            this._setTranslate = AutoSizeableMixin._setTranslate.bind(this);\n            this._initSize = AutoSizeableMixin._initSize.bind(this);\n            this._updateSize = AutoSizeableMixin._updateSize.bind(this);\n            this._initCircle();\n            this._initSize();\n        }\n        /**\n         * Redraws the circle with updated options.\n         * @param options New options to apply to the circle\n         */\n        redraw(options) {\n            if (options) {\n                const circleOptions = this.options;\n                if (options.center) {\n                    deepExtend(circleOptions, {\n                        center: options.center\n                    });\n                    this._center.move(circleOptions.center.x, circleOptions.center.y);\n                }\n                if (this._diffNumericOptions(options, ['radius'])) {\n                    this._circle.setRadius(circleOptions.radius);\n                }\n                this._updateSize(options);\n                super.redraw.call(this, options);\n            }\n        }\n        /** @hidden */\n        _initCircle() {\n            const options = this.options;\n            let width = options.width;\n            let height = options.height;\n            let radius = options.radius;\n            if (!defined(radius)) {\n                if (!defined(width)) {\n                    width = height;\n                }\n                if (!defined(height)) {\n                    height = width;\n                }\n                options.radius = radius = Math.min(width, height) / 2;\n            }\n            const center = options.center || { x: radius, y: radius };\n            this._center = new kendo_drawing_cmn_chunk_js.P(center.x, center.y);\n            this._circle = new kendo_drawing_cmn_chunk_js.f(this._center, radius);\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.e(this._circle, {\n                stroke: options.stroke\n            });\n            this._fill();\n        }\n    }\n\n    const defaultOptions$l = {\n        radius: 4,\n        anchor: {\n            x: 0,\n            y: 0\n        }\n    };\n    /**\n     * A visual marker that renders a circle shape at the start or end of a path.\n     * Extends MarkerBase to provide circle-specific positioning and rendering functionality.\n     */\n    class CircleMarker extends MarkerBase {\n        /**\n         * Creates a new CircleMarker instance.\n         * @param options Configuration options for the circle marker\n         */\n        constructor(options) {\n            options = deepExtend({}, defaultOptions$l, options);\n            super(options);\n        }\n        /**\n         * Creates the drawing element for the circle marker.\n         */\n        createElement() {\n            const options = this.options;\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.e(new kendo_drawing_cmn_chunk_js.f(this.anchor, options.radius), {\n                fill: options.fill,\n                stroke: options.stroke\n            });\n        }\n        /**\n         * Positions the circle marker on the specified path.\n         * @param path The path on which to position the circle marker\n         */\n        positionMarker(path) {\n            const options = this.options;\n            const position = options.position;\n            const segments = path.segments;\n            let targetSegment;\n            let point;\n            if (position === START$1) {\n                targetSegment = segments[0];\n            }\n            else {\n                targetSegment = segments[segments.length - 1];\n            }\n            if (targetSegment) {\n                point = this._transformToPath(targetSegment.anchor(), path);\n                this.drawingElement.transform(kendo_drawing_cmn_chunk_js.t().translate(point.x, point.y));\n            }\n        }\n    }\n\n    /**\n     * A visual element that renders a rectangle shape.\n     * Extends VisualBase and provides functionality for creating and managing rectangular graphics.\n     */\n    class Rectangle extends VisualBase {\n        /**\n         * Creates a new Rectangle instance.\n         * @param options Configuration options for the rectangle\n         */\n        constructor(options) {\n            super(options);\n            this._initPath();\n            this._setPosition();\n        }\n        /** @hidden */\n        _setPosition() {\n            const options = this.options;\n            const x = options.x;\n            const y = options.y;\n            if (defined(x) || defined(y)) {\n                this.position(x || 0, y || 0);\n            }\n        }\n        /**\n         * Redraws the rectangle with updated options.\n         * @param options New options to apply to the rectangle\n         */\n        redraw(options) {\n            if (options) {\n                super.redraw(options);\n                if (this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n                    this._drawPath();\n                }\n                if (this._diffNumericOptions(options, [X, Y])) {\n                    this._setPosition();\n                }\n            }\n        }\n        /** @hidden */\n        _initPath() {\n            const options = this.options;\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.a({\n                stroke: options.stroke\n            });\n            this._fill();\n            this._drawPath();\n        }\n        /** @hidden */\n        _drawPath() {\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const drawingElement = this.drawingElement;\n            const points = [\n                { x: 0, y: 0 },\n                { x: width, y: 0 },\n                { x: width, y: height },\n                { x: 0, y: height }\n            ];\n            if (this.options.cornerRadius > 0) {\n                drawRoundedPolygon(drawingElement, points, this.options.cornerRadius);\n            }\n            else {\n                drawPolygon(drawingElement, points);\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     *\n     * A base class for shapes that require multiple path elements for rendering.\n     * Extends Rectangle and provides functionality for complex shapes with multiple drawing paths.\n     */\n    class MultiPathShape extends Rectangle {\n        /** @hidden */\n        _initPath() {\n            const options = this.options;\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.g({\n                stroke: options.stroke\n            });\n            this._fill();\n            this._drawPath();\n        }\n    }\n\n    const defaultOptions$k = {\n        shapesOffsetRatio: 0.025,\n    };\n    /**\n     * Represents a Collate shape, a flowchart element used to indicate collating or gathering operations.\n     * Extends MultiPathShape with two triangular shapes arranged in an hourglass pattern.\n     */\n    class Collate extends MultiPathShape {\n        /**\n         * Creates a new Collate instance.\n         * @param options - Configuration options for the collate shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$k, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the collate shape path as two triangular shapes forming an hourglass.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const cornerRadius = this.options.cornerRadius;\n            const strokeWidth = this.options.stroke.width || 0;\n            const shapesOffset = height * this.options.shapesOffsetRatio - cornerRadius / 2;\n            const halfWidth = width / 2;\n            const halfHeight = height / 2;\n            const firstShape = [\n                { x: halfWidth, y: halfHeight - shapesOffset },\n                { x: 0, y: 0 },\n                { x: width, y: 0 },\n            ];\n            drawRoundedPolygon(drawingElement, firstShape, [cornerRadius / 3, cornerRadius, cornerRadius]);\n            const secondShape = [\n                { x: halfWidth, y: halfHeight + shapesOffset },\n                { x: width, y: height },\n                { x: 0, y: height }\n            ];\n            drawRoundedPolygon(drawingElement, secondShape, [cornerRadius / 3, cornerRadius, cornerRadius]);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * Represents an On-Page Connector shape, a flowchart element used to indicate continuation\n     * of a flowchart on the same page. Extends the Rectangle class with a custom circular path.\n     */\n    class OnPageConnector extends Rectangle {\n        /**\n         * @hidden\n         * Draws the on-page connector shape path as a circle with arcs.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const centerX = width / 2;\n            const radius = (Math.min(width, height) / 2);\n            drawingElement\n                .moveTo([centerX, 0])\n                .arcTo([centerX, height], radius, radius, false, true)\n                .arcTo([centerX, 0], radius, radius, false, true);\n        }\n    }\n\n    const defaultOptions$j = {\n        slantRatio: 0.15\n    };\n    /**\n     * Represents a Data Input/Output shape, a flowchart element used to indicate\n     * data input or output operations. Extends Rectangle with a parallelogram path.\n     */\n    class DataInputOutput extends Rectangle {\n        /**\n         * Creates a new DataInputOutput instance.\n         * @param options - Configuration options for the data input/output shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$j, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the data input/output shape path as a parallelogram.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const { slantRatio, cornerRadius } = this.options;\n            const slant = width * slantRatio;\n            const points = [\n                { x: slant, y: 0 },\n                { x: width, y: 0 },\n                { x: width - slant, y: height },\n                { x: 0, y: height }\n            ];\n            drawRoundedPolygon(drawingElement, points, cornerRadius);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    const defaultOptions$i = {\n        ellipseRxRatio: 0.5,\n        ellipseRyRatio: 0.2\n    };\n    /**\n     * A visual element that renders a database symbol with cylindrical appearance.\n     * Extends Rectangle and provides functionality for creating database storage shapes with elliptical top and bottom.\n     */\n    class Database extends Rectangle {\n        /**\n         * Creates a new Database instance.\n         * @param options Configuration options for the database shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$i, ...options });\n        }\n        /** @hidden */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const rx = width * this.options.ellipseRxRatio;\n            const ellipseRY = height * this.options.ellipseRyRatio;\n            const cy = ellipseRY;\n            const ry = ellipseRY;\n            drawingElement\n                .moveTo([width, cy])\n                .arcTo([0, cy], rx, ry, false, true)\n                .arcTo([width, cy], rx, ry, false, true)\n                .lineTo([width, height])\n                .arcTo([0, height], rx, ry, false, true)\n                .lineTo([0, cy]);\n            fitToSize(this.drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    const defaultOptions$h = {\n        ellipseRadiusXRatio: 0.165,\n        ellipseRadiusYRatio: 0.5\n    };\n    /**\n     * A visual element that renders a data storage symbol with curved sides.\n     * Extends MultiPathShape and provides functionality for creating storage device shapes.\n     */\n    class DataStorage extends MultiPathShape {\n        /**\n         * Creates a new DataStorage instance.\n         * @param options Configuration options for the data storage shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$h, ...options });\n        }\n        /** @hidden */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const ellipseRX = width * this.options.ellipseRadiusXRatio;\n            const rx = ellipseRX;\n            const ry = height * this.options.ellipseRadiusYRatio;\n            const leftCx = ellipseRX;\n            drawingElement\n                .moveTo(leftCx, 0)\n                .lineTo(width, 0)\n                .arc(270, 90, rx, ry, true)\n                .lineTo(leftCx, height)\n                .arcTo([leftCx, 0], rx, ry, false, true)\n                .close();\n        }\n    }\n\n    /**\n     * A visual element that renders a diamond-shaped decision flowchart symbol.\n     * Extends Rectangle and provides functionality for creating diamond/rhombus shapes.\n     */\n    class Decision extends Rectangle {\n        /** @hidden */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const points = [\n                { x: 0, y: height / 2 },\n                { x: width / 2, y: 0 },\n                { x: width, y: height / 2 },\n                { x: width / 2, y: height }\n            ];\n            const inflated = inflatePolygon(points, this.options.cornerRadius);\n            drawRoundedPolygon(drawingElement, inflated, this.options.cornerRadius);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    const defaultOptions$g = {\n        arcRadiusXRatio: 0.17,\n        arcRadiusYRatio: 0.3,\n    };\n    /**\n     * A visual element that renders a delay symbol with curved right edge.\n     * Extends Rectangle and provides functionality for creating delay/wait process shapes.\n     */\n    class Delay extends Rectangle {\n        /**\n         * Creates a new Delay instance.\n         * @param options Configuration options for the delay shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$g, ...options });\n        }\n        /** @hidden */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const { arcRadiusXRatio, arcRadiusYRatio, cornerRadius } = this.options;\n            const arcRadiusX = width * arcRadiusXRatio;\n            const arcRadiusY = height * arcRadiusYRatio;\n            drawingElement\n                .moveTo([0, cornerRadius])\n                .arcTo([cornerRadius, 0], cornerRadius, cornerRadius, true, false)\n                .lineTo([width - arcRadiusX, 0])\n                .arcTo([width - arcRadiusX, height], arcRadiusX, arcRadiusY, false, false)\n                .lineTo([cornerRadius, height])\n                .arcTo([0, height - cornerRadius], cornerRadius, cornerRadius, true, false)\n                .close();\n            fitToSize(this.drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    const defaultOptions$f = {\n        ellipseRatio: 0.1407\n    };\n    /**\n     * Represents a Direct Access Storage shape, a flowchart element used to indicate\n     * direct access storage devices like magnetic disks. Extends Rectangle with\n     * rounded ends.\n     */\n    class DirectAccessStorage extends Rectangle {\n        /**\n         * Creates a new DirectAccessStorage instance.\n         * @param options - Configuration options for the direct access storage shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$f, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the direct access storage shape path as a rounded rectangle with elliptical ends.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const ellipseRX = width * this.options.ellipseRatio;\n            const cx = ellipseRX;\n            const rx = ellipseRX;\n            const ry = height / 2;\n            drawingElement\n                .moveTo([width - cx, height])\n                .arcTo([width - cx, 0], rx, ry, false, true)\n                .arcTo([width - cx, height], rx, ry, false, true)\n                .lineTo([cx, height])\n                .arcTo([cx, 0], rx, ry, false, true)\n                .lineTo([width - cx, 0]);\n        }\n    }\n\n    const defaultOptions$e = {\n        sideCutRatio: 0.35,\n        arcRadiusYRatio: 0.3,\n        arcRadiusXRatio: 0.08\n    };\n    /**\n     * A visual element that renders a display symbol with angled left side and curved right edge.\n     * Extends Rectangle and provides functionality for creating display/output device shapes.\n     */\n    class Display extends Rectangle {\n        /**\n         * Creates a new Display instance.\n         * @param options Configuration options for the display shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$e, ...options });\n        }\n        /** @hidden */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const arcRadiusY = height * this.options.arcRadiusYRatio;\n            const arcRadiusX = width * this.options.arcRadiusXRatio;\n            const arcStartX = width - arcRadiusX;\n            const cut = width * this.options.sideCutRatio;\n            drawingElement\n                .moveTo([cut, 0])\n                .lineTo([arcStartX, 0])\n                .arcTo([arcStartX, height], arcRadiusX, arcRadiusY, false, true)\n                .lineTo([arcStartX, height])\n                .lineTo([cut, height])\n                .lineTo([0, height / 2])\n                .close();\n            fitToSize(this.drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    const cp1XRatio = 5 / 6;\n    const cp2XRatio = 1 / 6;\n    const docDefaultOptions = {\n        waveRatio: 0.37\n    };\n    const multyDocsDefaultOptions = {\n        ...docDefaultOptions,\n        docsXRatio: 0.14,\n        docsYRatio: 0.2,\n    };\n    /**\n     * @hidden\n     * Draws a document shape with a wavy bottom edge.\n     * @param drawingElement - The drawing element to draw on\n     * @param origin - Starting position coordinates\n     * @param width - Width of the document\n     * @param height - Height of the document\n     * @param waveRatio - Ratio for the wave amplitude\n     * @param cornerRadius - Corner radius for rounded corners\n     */\n    const drawDocument = (drawingElement, origin, width, height, waveRatio, cornerRadius) => {\n        const amplitude = height * waveRatio;\n        drawingElement\n            .moveTo(origin[0] + width, origin[1] + height)\n            .curveTo([origin[0] + width, origin[1] + height], [origin[0] + width * cp1XRatio, origin[1] + height - amplitude], [origin[0] + width / 2, origin[1] + height])\n            .curveTo([origin[0] + width * cp2XRatio, origin[1] + height + amplitude], [origin[0], origin[1] + height], [origin[0], origin[1] + height])\n            .lineTo(origin[0], origin[1] + cornerRadius)\n            .arcTo([origin[0] + cornerRadius, origin[1]], cornerRadius, cornerRadius, true, false)\n            .lineTo(origin[0] + width - cornerRadius, origin[1])\n            .arcTo([origin[0] + width, origin[1] + cornerRadius], cornerRadius, cornerRadius, true, false)\n            .lineTo(origin[0] + width, origin[1] + height)\n            .close();\n    };\n    /**\n     * Represents a Document shape, a flowchart element used to indicate documents\n     * or printed output. Extends Rectangle with a wavy bottom edge.\n     */\n    class Document extends Rectangle {\n        /**\n         * Creates a new Document instance.\n         * @param options - Configuration options for the document shape\n         */\n        constructor(options) {\n            super({ ...docDefaultOptions, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the document shape path with a wavy bottom edge.\n         */\n        _drawPath() {\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const { waveRatio, cornerRadius } = this.options;\n            const halfAmplitude = height * waveRatio * 0.5;\n            drawDocument(this.drawingElement, [0, 0], width, height - halfAmplitude, waveRatio, cornerRadius);\n            fitToSize(this.drawingElement, width, height, strokeWidth);\n        }\n    }\n    /**\n     * Represents a Multiple Documents shape, indicating multiple documents or pages.\n     * Extends Document with additional overlapping document shapes.\n     */\n    class MultipleDocuments extends Document {\n        /**\n         * Creates a new MultipleDocuments instance.\n         * @param options - Configuration options for the multiple documents shape\n         */\n        constructor(options) {\n            super({ ...multyDocsDefaultOptions, ...options });\n        }\n        /**\n         * @hidden\n         * Initializes the path using a group for multiple document shapes.\n         */\n        _initPath() {\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.G();\n            this._fill();\n            this._drawPath();\n        }\n        /**\n         * @hidden\n         * Fills the multiple document shapes with the specified fill options.\n         * @param fillOptions - Fill options to apply\n         */\n        _fill(fillOptions) {\n            const fill = this._evalFillOptions(fillOptions);\n            if (fill.gradient) {\n                const gradient = fill.gradient;\n                const GradientClass = (gradient.type === 'radial' ? kendo_drawing_cmn_chunk_js.h : kendo_drawing_cmn_chunk_js.L);\n                this.drawingElement.children.forEach((child) => {\n                    child.fill(new GradientClass(gradient));\n                });\n            }\n            else {\n                this.drawingElement.children.forEach((child) => {\n                    child.fill(fill.color, fill.opacity);\n                });\n            }\n        }\n        /**\n         * @hidden\n         * Draws multiple overlapping document shapes.\n         */\n        _drawPath() {\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const { waveRatio, docsXRatio, docsYRatio, stroke, fill, cornerRadius } = this.options;\n            const docOffsetX = width * docsXRatio;\n            const docOffsetY = height * docsYRatio;\n            const drawingElement = this.drawingElement;\n            const path1 = new kendo_drawing_cmn_chunk_js.g({ stroke, fill });\n            const path2 = new kendo_drawing_cmn_chunk_js.g({ stroke, fill });\n            const halfAmplitude = height * waveRatio * 0.5;\n            drawDocument(path1, [docOffsetX, 0], width - docOffsetX, height - docOffsetY - halfAmplitude, waveRatio, cornerRadius);\n            drawDocument(path2, [0, docOffsetY], width - docOffsetX, height - docOffsetY - halfAmplitude, waveRatio, cornerRadius);\n            drawingElement.append(path1);\n            drawingElement.append(path2);\n            fitToSize(this.drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * A visual element that renders a terminator symbol with rounded ends.\n     * Extends Rectangle and provides functionality for creating start/end flowchart shapes.\n     */\n    class Terminator extends Rectangle {\n        /** @hidden */\n        _drawPath() {\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const drawingElement = this.drawingElement;\n            const r = height / 2;\n            drawingElement\n                .moveTo(r, 0)\n                .lineTo(width - 2 * r, 0)\n                .arcTo([width - 2 * r, height], r, r, false, false)\n                .lineTo(r, height)\n                .arcTo([r, 0], r, r, false, false)\n                .close();\n        }\n    }\n\n    /**\n     * Represents an Extract shape, a flowchart element used to indicate extraction of data or a process step.\n     * Extends the Rectangle class with a custom triangular path.\n     */\n    class Extract extends Rectangle {\n        /**\n         * @hidden\n         * Draws the extract shape path as a triangle.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const r = this.options.cornerRadius || 0;\n            const points = [\n                { x: width / 2, y: 0 },\n                { x: width, y: height },\n                { x: 0, y: height }\n            ];\n            const inflated = inflatePolygon(points, r);\n            drawRoundedPolygon(drawingElement, inflated, r);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * Represents a group of visual elements that can be managed and manipulated as a single unit.\n     * Extends Element and incorporates AutoSizeableMixin functionality for automatic sizing.\n     */\n    class Group extends Element {\n        /**\n         * Creates a new Group instance.\n         * @param options Configuration options for the group\n         */\n        constructor(options) {\n            options = deepExtend({ autoSize: false }, options);\n            super(options);\n            /**\n             * Array of child visual elements contained in this group.\n             */\n            this.children = [];\n            /** @hidden */\n            this._childrenChange = false;\n            // Bind mixin methods to current instance\n            this._setScale = AutoSizeableMixin._setScale.bind(this);\n            this._setTranslate = AutoSizeableMixin._setTranslate.bind(this);\n            this._initSize = AutoSizeableMixin._initSize.bind(this);\n            this._updateSize = AutoSizeableMixin._updateSize.bind(this);\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.G();\n            this._initSize();\n        }\n        /**\n         * Appends a visual element to this group.\n         * @param visual The visual element to append to the group\n         */\n        append(visual) {\n            this.drawingElement.append(visual.drawingContainer());\n            this.children.push(visual);\n            this._childrenChange = true;\n        }\n        ;\n        /**\n         * Removes a visual element from this group.\n         * @param visual The visual element to remove from the group\n         */\n        remove(visual) {\n            if (this._remove(visual)) {\n                this._childrenChange = true;\n            }\n        }\n        /** @hidden */\n        _remove(visual) {\n            const index = this.children.indexOf(visual);\n            if (index >= 0) {\n                this.drawingElement.removeAt(index);\n                this.children.splice(index, 1);\n                return true;\n            }\n        }\n        /**\n         * Removes all child visual elements from this group.\n         */\n        clear() {\n            this.drawingElement.clear();\n            this.children = [];\n            this._childrenChange = true;\n        }\n        /**\n         * Moves the specified visual elements to the front of the display order.\n         * @param visuals Array of visual elements to move to front\n         */\n        toFront(visuals) {\n            let visual;\n            for (let i = 0; i < visuals.length; i++) {\n                visual = visuals[i];\n                if (this._remove(visual)) {\n                    this.append(visual);\n                }\n            }\n        }\n        // TO DO: add drawing group support for moving and inserting children\n        /**\n         * Moves the specified visual elements to the back of the display order.\n         * @param visuals Array of visual elements to move to back\n         */\n        toBack(visuals) {\n            this._reorderChildren(visuals, 0);\n        }\n        /**\n         * Moves the specified visual elements to specific indices in the display order.\n         * @param visuals Array of visual elements to reorder\n         * @param indices Target indices for the visual elements\n         */\n        toIndex(visuals, indices) {\n            this._reorderChildren(visuals, indices);\n        }\n        /** @hidden */\n        _reorderChildren(visuals, indices) {\n            const group = this.drawingElement;\n            const drawingChildren = group.children.slice(0);\n            const children = this.children;\n            const fixedPosition = isNumber(indices);\n            let i, index, toIndex, drawingElement, visual;\n            for (i = 0; i < visuals.length; i++) {\n                visual = visuals[i];\n                drawingElement = visual.drawingContainer();\n                index = children.indexOf(visual);\n                if (index >= 0) {\n                    drawingChildren.splice(index, 1);\n                    children.splice(index, 1);\n                    toIndex = fixedPosition ? indices : indices[i];\n                    drawingChildren.splice(toIndex, 0, drawingElement);\n                    children.splice(toIndex, 0, visual);\n                }\n            }\n            group.clear();\n            group.append(...drawingChildren);\n        }\n        /**\n         * Redraws the group with updated options.\n         * @param options New options to apply to the group\n         */\n        redraw(options) {\n            if (options) {\n                if (this._childrenChange) {\n                    this._childrenChange = false;\n                    if (!this._updateSize(options)) {\n                        this._initSize();\n                    }\n                }\n                else {\n                    this._updateSize(options);\n                }\n                super.redraw(options);\n            }\n        }\n        /** @hidden */\n        _boundingBox() {\n            const children = this.children;\n            let boundingBox;\n            let visual, childBoundingBox;\n            for (let i = 0; i < children.length; i++) {\n                visual = children[i];\n                if (visual.visible() && visual._includeInBBox !== false) {\n                    childBoundingBox = visual.drawingContainer().clippedBBox(null);\n                    if (childBoundingBox) {\n                        if (boundingBox) {\n                            boundingBox = kendo_drawing_cmn_chunk_js.R.union(boundingBox, childBoundingBox);\n                        }\n                        else {\n                            boundingBox = childBoundingBox;\n                        }\n                    }\n                }\n            }\n            return boundingBox;\n        }\n    }\n\n    /**\n     * Represents an Image element for displaying images in SVG.\n     * Extends the Element class to provide image-specific functionality.\n     */\n    class Image extends Element {\n        /**\n         * Creates a new Image instance.\n         * @param options - Configuration options for the image including source, position, and size\n         */\n        constructor(options) {\n            super(options);\n            this._initImage();\n        }\n        /**\n         * Redraws the image with updated options.\n         * @param options - Updated configuration options\n         */\n        redraw(options) {\n            if (options) {\n                if (options.source) {\n                    this.drawingElement.src(options.source);\n                }\n                if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n                    this.drawingElement.rect(this._rect());\n                }\n                super.redraw(options);\n            }\n        }\n        /**\n         * @hidden\n         * Initializes the image drawing element.\n         */\n        _initImage() {\n            const options = this.options;\n            const rect = this._rect();\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.I(options.source, rect);\n        }\n        /** @hidden */\n        _rect() {\n            const sizeOptions = sizeOptionsOrDefault(this.options);\n            const origin = new kendo_drawing_cmn_chunk_js.P(sizeOptions.x, sizeOptions.y);\n            const size = new kendo_drawing_cmn_chunk_js.o(sizeOptions.width, sizeOptions.height);\n            return new kendo_drawing_cmn_chunk_js.R(origin, size);\n        }\n    }\n\n    const defaultOptions$d = {\n        leftLineOffsetRatio: 0.13,\n        topLineOffsetRatio: 0.23,\n    };\n    /**\n     * Represents an Internal Storage shape, a flowchart element used to indicate\n     * internal storage or memory operations. Extends MultiPathShape with a rectangle\n     * containing internal dividing lines.\n     */\n    class InternalStorage extends MultiPathShape {\n        /**\n         * Creates a new InternalStorage instance.\n         * @param options - Configuration options for the internal storage shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$d, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the internal storage shape path as a rectangle with internal lines.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const { leftLineOffsetRatio, topLineOffsetRatio } = this.options;\n            const leftLineX = width * leftLineOffsetRatio;\n            const topLineOffset = height * topLineOffsetRatio;\n            const points = [\n                { x: 0, y: 0 },\n                { x: width, y: 0 },\n                { x: width, y: height },\n                { x: 0, y: height }\n            ];\n            drawRoundedPolygon(drawingElement, points, this.options.cornerRadius);\n            drawingElement\n                .moveTo(leftLineX, 0)\n                .lineTo(leftLineX, height)\n                .moveTo(0, topLineOffset)\n                .lineTo(width, topLineOffset);\n        }\n    }\n\n    /**\n     * Represents a layout container that automatically arranges child elements.\n     * Extends Group to provide automatic layout and positioning capabilities.\n     */\n    class Layout extends Group {\n        /**\n         * Creates a new Layout instance.\n         * @param rect The rectangle bounds for the layout\n         * @param options Configuration options for the layout\n         */\n        constructor(rect, options) {\n            super(options);\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.j(toDrawingRect(rect), options);\n            this._initSize();\n        }\n        /**\n         * Gets or sets the rectangle bounds of the layout.\n         * @param rect The rectangle bounds to set, or undefined to get current bounds\n         * @returns The current rectangle bounds when called as getter\n         */\n        rect(rect) {\n            if (rect) {\n                this.drawingElement.rect(toDrawingRect(rect));\n            }\n            else {\n                const drawingRect = this.drawingElement.rect();\n                if (drawingRect) {\n                    return new Rect(drawingRect.origin.x, drawingRect.origin.y, drawingRect.size.width, drawingRect.size.height);\n                }\n            }\n        }\n        /**\n         * Triggers a reflow of the layout, recalculating positions and sizes.\n         */\n        reflow() {\n            this.drawingElement.reflow();\n        }\n        /**\n         * Redraws the layout with updated options.\n         * @param options New options to apply to the layout\n         */\n        redraw(options) {\n            deepExtend(this.drawingElement.options, options);\n            super.redraw.call(this, options);\n        }\n    }\n\n    /**\n     * Mixin that provides marker functionality for path-based elements.\n     * Can be mixed into classes to add start and end marker capabilities.\n     */\n    const MarkerPathMixin = {\n        /**\n         * @hidden\n         * Gets the path element for marker positioning.\n         * @param position - The marker position (start or end)\n         * @returns The path element or undefined\n         */\n        _getPath: function (position) {\n            let path = this.drawingElement;\n            if (path instanceof kendo_drawing_cmn_chunk_js.g) {\n                if (position === START$1) {\n                    path = path.paths[0];\n                }\n                else {\n                    path = path.paths[path.paths.length - 1];\n                }\n            }\n            if (path && path.segments.length) {\n                return path;\n            }\n        },\n        /**\n         * @hidden\n         * Normalizes marker options by converting string values to objects.\n         * @param options - The options to normalize\n         */\n        _normalizeMarkerOptions: function (options) {\n            const startCap = options.startCap;\n            const endCap = options.endCap;\n            if (isString$1(startCap)) {\n                options.startCap = {\n                    type: startCap\n                };\n            }\n            if (isString$1(endCap)) {\n                options.endCap = {\n                    type: endCap\n                };\n            }\n        },\n        /**\n         * @hidden\n         * Removes a marker from the specified position.\n         * @param position - The marker position (start or end)\n         */\n        _removeMarker: function (position) {\n            const marker = this._markers[position];\n            if (marker) {\n                this.drawingContainer().remove(marker.drawingElement);\n                delete this._markers[position];\n            }\n        },\n        /**\n         * @hidden\n         * Creates markers for both start and end positions.\n         */\n        _createMarkers: function () {\n            const options = this.options;\n            this._normalizeMarkerOptions(options);\n            this._markers = {};\n            this._markers[START$1] = this._createMarker(options.startCap, START$1);\n            this._markers[END$1] = this._createMarker(options.endCap, END$1);\n        },\n        /**\n         * @hidden\n         * Creates a marker for the specified position.\n         * @param options - Marker configuration options\n         * @param position - The marker position (start or end)\n         * @returns The created marker instance\n         */\n        _createMarker: function (options, position) {\n            const type = (options || {}).type;\n            const path = this._getPath(position);\n            let markerType, marker;\n            if (!path) {\n                this._removeMarker(position);\n                return;\n            }\n            if (type === MarkerType.FilledCircle) {\n                markerType = CircleMarker;\n            }\n            else if (type === MarkerType.ArrowStart || type === MarkerType.ArrowEnd) {\n                markerType = ArrowMarker;\n            }\n            else {\n                this._removeMarker(position);\n            }\n            if (markerType) {\n                marker = new markerType(deepExtend({}, options, {\n                    position: position\n                }));\n                marker.positionMarker(path);\n                this.drawingContainer().append(marker.drawingElement);\n                return marker;\n            }\n        },\n        /**\n         * @hidden\n         * Positions a marker at the specified position along the path.\n         * @param position - The marker position (start or end)\n         */\n        _positionMarker: function (position) {\n            const marker = this._markers[position];\n            if (marker) {\n                const path = this._getPath(position);\n                if (path) {\n                    marker.positionMarker(path);\n                }\n                else {\n                    this._removeMarker(position);\n                }\n            }\n        },\n        /**\n         * @hidden\n         * Mapping of position names to cap option names.\n         */\n        _capMap: {\n            start: 'startCap',\n            end: 'endCap'\n        },\n        /**\n         * @hidden\n         * Redraws a marker at the specified position with updated options.\n         * @param pathChange - Whether the path has changed\n         * @param position - The marker position (start or end)\n         * @param options - Updated marker options\n         * @returns True if a new marker was created, false otherwise\n         */\n        _redrawMarker: function (pathChange, position, options) {\n            this._normalizeMarkerOptions(options);\n            const pathOptions = this.options;\n            const cap = this._capMap[position];\n            const pathCapType = (pathOptions[cap] || {}).type;\n            const optionsCap = options[cap];\n            let created = false;\n            if (optionsCap) {\n                pathOptions[cap] = deepExtend({}, pathOptions[cap], optionsCap);\n                if (optionsCap.type && pathCapType !== optionsCap.type) {\n                    this._removeMarker(position);\n                    this._markers[position] = this._createMarker(pathOptions[cap], position);\n                    created = true;\n                }\n                else if (this._markers[position]) {\n                    this._markers[position].redraw(optionsCap);\n                }\n            }\n            else if (pathChange && !this._markers[position] && pathOptions[cap]) {\n                this._markers[position] = this._createMarker(pathOptions[cap], position);\n                created = true;\n            }\n            return created;\n        },\n        /**\n         * @hidden\n         * Redraws all markers with updated options.\n         * @param pathChange - Whether the path has changed\n         * @param options - Updated marker options\n         */\n        _redrawMarkers: function (pathChange, options) {\n            if (!this._redrawMarker(pathChange, START$1, options) && pathChange) {\n                this._positionMarker(START$1);\n            }\n            if (!this._redrawMarker(pathChange, END$1, options) && pathChange) {\n                this._positionMarker(END$1);\n            }\n        }\n    };\n\n    /**\n     * Represents a line segment with marker capabilities.\n     * Extends VisualBase and incorporates MarkerPathMixin functionality.\n     */\n    class Line extends VisualBase {\n        /**\n         * Creates a new Line instance.\n         * @param options - Configuration options for the line including endpoints and styling\n         */\n        constructor(options) {\n            super(options);\n            this._capMap = MarkerPathMixin._capMap;\n            this.container = new kendo_drawing_cmn_chunk_js.G();\n            this._getPath = MarkerPathMixin._getPath.bind(this);\n            this._normalizeMarkerOptions = MarkerPathMixin._normalizeMarkerOptions.bind(this);\n            this._removeMarker = MarkerPathMixin._removeMarker.bind(this);\n            this._createMarkers = MarkerPathMixin._createMarkers.bind(this);\n            this._createMarker = MarkerPathMixin._createMarker.bind(this);\n            this._positionMarker = MarkerPathMixin._positionMarker.bind(this);\n            this._redrawMarker = MarkerPathMixin._redrawMarker.bind(this);\n            this._redrawMarkers = MarkerPathMixin._redrawMarkers.bind(this);\n            this._initPath();\n            this._createMarkers();\n        }\n        /**\n         * Returns the drawing container for this line.\n         * @returns The drawing container\n         */\n        drawingContainer() {\n            return this.container;\n        }\n        /**\n         * Redraws the line with updated options.\n         * @param options - Updated configuration options\n         */\n        redraw(options) {\n            if (options) {\n                options = options || {};\n                const from = options.from;\n                const to = options.to;\n                if (from) {\n                    this.options.from = from;\n                }\n                if (to) {\n                    this.options.to = to;\n                }\n                if (from || to) {\n                    this._drawPath();\n                    this._redrawMarkers(true, options);\n                }\n                else {\n                    this._redrawMarkers(false, options);\n                }\n                super.redraw(options);\n            }\n        }\n        /**\n         * @hidden\n         * Initializes the path drawing element.\n         */\n        _initPath() {\n            const options = this.options;\n            const drawingElement = this.drawingElement = new kendo_drawing_cmn_chunk_js.a({\n                stroke: options.stroke\n            });\n            this._fill();\n            this._drawPath();\n            this.container.append(drawingElement);\n        }\n        /**\n         * @hidden\n         * Draws the line path between from and to points.\n         */\n        _drawPath() {\n            const options = this.options;\n            const drawingElement = this.drawingElement;\n            const from = options.from || new Point();\n            const to = options.to || new Point();\n            drawingElement.segments.elements([\n                createSegment(from.x, from.y),\n                createSegment(to.x, to.y)\n            ]);\n        }\n    }\n\n    const defaultOptions$c = {\n        topSlantRatio: 0.2\n    };\n    /**\n     * Represents a Manual Input/Output shape, a flowchart element used to indicate\n     * manual input or output operations. Extends Rectangle with a slanted top edge.\n     */\n    class ManualInputOutput extends Rectangle {\n        /**\n         * Creates a new ManualInputOutput instance.\n         * @param options - Configuration options for the manual input/output shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$c, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the manual input/output shape path as a quadrilateral with slanted top.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const { topSlantRatio, cornerRadius } = this.options;\n            const topSlant = height * topSlantRatio;\n            const points = [\n                { x: 0, y: topSlant },\n                { x: width, y: 0 },\n                { x: width, y: height },\n                { x: 0, y: height }\n            ];\n            drawRoundedPolygon(drawingElement, points, cornerRadius);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    const defaultOptions$b = {\n        baseShrinkRatio: 0.5\n    };\n    /**\n     * Represents a Manual Operation shape, a flowchart element used to indicate a manual process or operation.\n     * Extends the Rectangle class with a custom trapezoid path.\n     */\n    class ManualOperation extends Rectangle {\n        /**\n         * Creates a new ManualOperation instance.\n         * @param options - Configuration options for the manual operation shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$b, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the manual operation shape path as a trapezoid.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const baseShrink = width * this.options.baseShrinkRatio;\n            const points = [\n                { x: 0, y: 0 },\n                { x: width, y: 0 },\n                { x: width - baseShrink / 2, y: height },\n                { x: baseShrink / 2, y: height }\n            ];\n            drawRoundedPolygon(drawingElement, points, this.options.cornerRadius);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * Represents a Merge shape, a flowchart element used to indicate the merging\n     * of multiple processes or data streams. Extends Rectangle with a triangular path.\n     */\n    class Merge extends Rectangle {\n        /**\n         * @hidden\n         * Draws the merge shape path as an inverted triangle.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const points = [\n                { x: 0, y: 0 },\n                { x: width, y: 0 },\n                { x: width / 2, y: height }\n            ];\n            const inflated = inflatePolygon(points, this.options.cornerRadius);\n            drawRoundedPolygon(drawingElement, inflated, this.options.cornerRadius);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * Represents a Logical OR shape, used in logic diagrams and circuit diagrams\n     * to indicate logical OR operations. Extends MultiPathShape with a circular path\n     * and intersecting lines.\n     */\n    class LogicalOr extends MultiPathShape {\n        /**\n         * @hidden\n         * Draws the logical OR shape path as a circle with horizontal and vertical lines.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const centerX = width / 2;\n            const centerY = height / 2;\n            const radius = (Math.min(width, height) / 2) - this.options.stroke.width;\n            drawingElement\n                .moveTo(centerX, 0)\n                .arcTo([centerX, height], radius, radius, false, true)\n                .arcTo([centerX, 0], radius, radius, false, true)\n                .moveTo(0, centerY)\n                .lineTo(width, centerY)\n                .moveTo(centerX, 0)\n                .lineTo(centerX, height);\n        }\n    }\n\n    const defaultOptions$a = {\n        ellipseRxRatio: 0.5,\n        ellipseRyRatio: 0.13,\n        bottomEdgeYRatio: 0.76\n    };\n    /**\n     * Represents an Off-Page Connector shape, a flowchart element used to indicate\n     * continuation of a flowchart on another page. Extends Rectangle with a custom\n     * pentagon-like path with rounded top edge.\n     */\n    class OffPageConnector extends Rectangle {\n        /**\n         * Creates a new OffPageConnector instance.\n         * @param options - Configuration options for the off-page connector shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$a, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the off-page connector shape path as a pentagon with rounded top.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const ellipseRX = width * this.options.ellipseRxRatio;\n            const ellipseRY = height * this.options.ellipseRyRatio;\n            const topY = ellipseRY;\n            const leftY = topY;\n            const rightY = topY;\n            const bottomY = height * this.options.bottomEdgeYRatio;\n            const bottomMiddleX = width / 2;\n            const bottomMiddleY = height;\n            drawingElement\n                .moveTo([0, topY])\n                .arcTo([width, rightY], ellipseRX, ellipseRY, false, false)\n                .lineTo([width, bottomY])\n                .lineTo([bottomMiddleX, bottomMiddleY])\n                .lineTo([0, bottomY])\n                .lineTo([0, leftY])\n                .close();\n            fitToSize(this.drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * Represents an SVG path element with auto-sizing and marker capabilities.\n     * Combines VisualBase with AutoSizeableMixin and MarkerPathMixin functionality.\n     */\n    class Path extends VisualBase {\n        /**\n         * Creates a new Path instance.\n         * @param options - Configuration options for the path\n         */\n        constructor(options) {\n            options = deepExtend({ autoSize: true }, options);\n            super(options);\n            this._capMap = MarkerPathMixin._capMap;\n            this.container = new kendo_drawing_cmn_chunk_js.G();\n            this._setScale = AutoSizeableMixin._setScale.bind(this);\n            this._setTranslate = AutoSizeableMixin._setTranslate.bind(this);\n            this._initSize = AutoSizeableMixin._initSize.bind(this);\n            this._updateSize = AutoSizeableMixin._updateSize.bind(this);\n            this._getPath = MarkerPathMixin._getPath.bind(this);\n            this._normalizeMarkerOptions = MarkerPathMixin._normalizeMarkerOptions.bind(this);\n            this._removeMarker = MarkerPathMixin._removeMarker.bind(this);\n            this._createMarkers = MarkerPathMixin._createMarkers.bind(this);\n            this._createMarker = MarkerPathMixin._createMarker.bind(this);\n            this._positionMarker = MarkerPathMixin._positionMarker.bind(this);\n            this._redrawMarker = MarkerPathMixin._redrawMarker.bind(this);\n            this._redrawMarkers = MarkerPathMixin._redrawMarkers.bind(this);\n            this._createElements();\n            this._initSize();\n        }\n        /**\n         * Gets the drawing container that holds the path and its markers.\n         * @returns The drawing group container\n         */\n        drawingContainer() {\n            return this.container;\n        }\n        /**\n         * Gets or sets the path data string for the SVG path.\n         * @param value The SVG path data string to set, or undefined to get current data\n         * @returns The current path data string when called as getter\n         */\n        data(value) {\n            const options = this.options;\n            if (value) {\n                if (options.data !== value) {\n                    options.data = value;\n                    this._setData(value);\n                    this._initSize();\n                    this._redrawMarkers(true, {});\n                }\n            }\n            else {\n                return options.data;\n            }\n        }\n        /**\n         * Redraws the path with updated options.\n         * @param options - Updated configuration options\n         */\n        redraw(options) {\n            if (options) {\n                super.redraw(options);\n                const pathOptions = this.options;\n                const data = options.data;\n                if (defined(data) && pathOptions.data !== data) {\n                    pathOptions.data = data;\n                    this._setData(data);\n                    if (!this._updateSize(options)) {\n                        this._initSize();\n                    }\n                    this._redrawMarkers(true, options);\n                }\n                else {\n                    this._updateSize(options);\n                    this._redrawMarkers(false, options);\n                }\n            }\n        }\n        /**\n         * @hidden\n         * Creates the drawing elements for the path.\n         */\n        _createElements() {\n            const options = this.options;\n            this.drawingElement = kendo_drawing_cmn_chunk_js.a.parse(options.data || '', {\n                stroke: options.stroke\n            });\n            this._fill();\n            this.container.append(this.drawingElement);\n            this._createMarkers();\n        }\n        /**\n         * @hidden\n         * Sets the path data for the drawing element.\n         * @param data - The SVG path data string\n         */\n        _setData(data) {\n            const drawingElement = this.drawingElement;\n            const multipath = kendo_drawing_cmn_chunk_js.a.parse(data || '');\n            const paths = multipath.paths.slice(0);\n            multipath.paths.elements([]);\n            drawingElement.paths.elements(paths);\n        }\n    }\n\n    /**\n     * Represents a polyline (multi-segment line) with marker capabilities.\n     * Extends VisualBase and incorporates MarkerPathMixin functionality.\n     */\n    class Polyline extends VisualBase {\n        /**\n         * Creates a new Polyline instance.\n         * @param options - Configuration options for the polyline including points and styling\n         */\n        constructor(options) {\n            options = deepExtend({ points: [] }, options);\n            super(options);\n            this._capMap = MarkerPathMixin._capMap;\n            this.container = new kendo_drawing_cmn_chunk_js.G();\n            this._getPath = MarkerPathMixin._getPath.bind(this);\n            this._normalizeMarkerOptions = MarkerPathMixin._normalizeMarkerOptions.bind(this);\n            this._removeMarker = MarkerPathMixin._removeMarker.bind(this);\n            this._createMarkers = MarkerPathMixin._createMarkers.bind(this);\n            this._createMarker = MarkerPathMixin._createMarker.bind(this);\n            this._positionMarker = MarkerPathMixin._positionMarker.bind(this);\n            this._redrawMarker = MarkerPathMixin._redrawMarker.bind(this);\n            this._redrawMarkers = MarkerPathMixin._redrawMarkers.bind(this);\n            this._initPath();\n            this._createMarkers();\n        }\n        /**\n         * Gets the drawing container that holds the polyline and its markers.\n         * @returns The drawing group container\n         */\n        drawingContainer() {\n            return this.container;\n        }\n        /**\n         * Gets or sets the points that define the polyline path.\n         * @param points Array of points to set for the polyline, or undefined to get current points\n         * @returns The current points array when called as getter\n         */\n        points(points) {\n            const options = this.options;\n            if (points) {\n                options.points = points;\n                this._updatePath();\n            }\n            else {\n                return options.points;\n            }\n        }\n        /**\n         * Redraws the polyline with updated options.\n         * @param options - Updated configuration options\n         */\n        redraw(options) {\n            if (options) {\n                const points = options.points;\n                super.redraw.call(this, options);\n                if (points && this._pointsDiffer(points)) {\n                    this.points(points);\n                    this._redrawMarkers(true, options);\n                }\n                else {\n                    this._redrawMarkers(false, options);\n                }\n            }\n        }\n        /**\n         * @hidden\n         * Initializes the path drawing element.\n         */\n        _initPath() {\n            const options = this.options;\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.a({\n                stroke: options.stroke\n            });\n            this._fill();\n            this.container.append(this.drawingElement);\n            if (options.points) {\n                this._updatePath();\n            }\n        }\n        /** @hidden */\n        _pointsDiffer(points) {\n            const currentPoints = this.options.points;\n            let differ = currentPoints.length !== points.length;\n            if (!differ) {\n                for (let i = 0; i < points.length; i++) {\n                    if (currentPoints[i].x !== points[i].x || currentPoints[i].y !== points[i].y) {\n                        differ = true;\n                        break;\n                    }\n                }\n            }\n            return differ;\n        }\n        /**\n         * @hidden\n         * Updates the path with current points.\n         */\n        _updatePath() {\n            const drawingElement = this.drawingElement;\n            const options = this.options;\n            const points = options.points;\n            const segments = [];\n            let point;\n            for (let i = 0; i < points.length; i++) {\n                point = points[i];\n                segments.push(createSegment(point.x, point.y));\n            }\n            drawingElement.segments.elements(segments);\n        }\n    }\n\n    const defaultOptions$9 = {\n        sideLineOffsetRatio: 0.1\n    };\n    /**\n     * Represents a Predefined Process shape, a flowchart element used to indicate\n     * a process that is defined elsewhere. Extends MultiPathShape with a rectangle\n     * containing vertical side lines.\n     */\n    class PredefinedProcess extends MultiPathShape {\n        /**\n         * Creates a new PredefinedProcess instance.\n         * @param options - Configuration options for the predefined process shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$9, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the predefined process shape path as a rectangle with vertical lines.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const sideLineOffsetRatio = this.options.sideLineOffsetRatio;\n            const sideLineOffset = width * sideLineOffsetRatio;\n            const leftLineX = sideLineOffset;\n            const rightLineX = width - sideLineOffset;\n            const points = [\n                { x: 0, y: 0 },\n                { x: width, y: 0 },\n                { x: width, y: height },\n                { x: 0, y: height }\n            ];\n            drawRoundedPolygon(drawingElement, points, this.options.cornerRadius);\n            drawingElement\n                .moveTo(leftLineX, 0)\n                .lineTo(leftLineX, height)\n                .moveTo(rightLineX, 0)\n                .lineTo(rightLineX, height);\n        }\n    }\n\n    const defaultOptions$8 = {\n        horizontalInsetRatio: 1 / 6\n    };\n    /**\n     * A visual element that renders a preparation symbol with hexagonal shape.\n     * Extends Rectangle and provides functionality for creating preparation/setup process shapes.\n     */\n    class Preparation extends Rectangle {\n        /**\n         * Creates a new Preparation instance.\n         * @param options Configuration options for the preparation shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$8, ...options });\n        }\n        /** @hidden */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const xOffset = width * this.options.horizontalInsetRatio;\n            const points = [\n                { x: xOffset, y: 0 },\n                { x: width - xOffset, y: 0 },\n                { x: width, y: height / 2 },\n                { x: width - xOffset, y: height },\n                { x: xOffset, y: height },\n                { x: 0, y: height / 2 }\n            ];\n            drawRoundedPolygon(drawingElement, points, this.options.cornerRadius);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * A visual element that renders a rectangular process flowchart symbol.\n     */\n    class Process extends Rectangle {\n    }\n\n    const defaultOptions$7 = {\n        shapesOffsetRatio: 0.015,\n    };\n    /**\n     * Represents a Sort shape, a flowchart element used to indicate sorting operations.\n     * Extends MultiPathShape with two triangular shapes arranged vertically.\n     */\n    class Sort extends MultiPathShape {\n        /**\n         * Creates a new Sort instance.\n         * @param options - Configuration options for the sort shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$7, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the sort shape path as two triangular shapes.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const cornerRadius = this.options.cornerRadius;\n            const shapesOffset = this.options.shapesOffsetRatio * height;\n            const halfHeight = height / 2;\n            const firstShape = [\n                { x: width / 2, y: 0 },\n                { x: width, y: halfHeight - shapesOffset },\n                { x: 0, y: halfHeight - shapesOffset }\n            ];\n            drawRoundedPolygon(drawingElement, firstShape, [cornerRadius / 3, cornerRadius, cornerRadius]);\n            const secondShape = [\n                { x: width / 2, y: height },\n                { x: 0, y: halfHeight + shapesOffset },\n                { x: width, y: halfHeight + shapesOffset }\n            ];\n            drawRoundedPolygon(drawingElement, secondShape, [cornerRadius / 3, cornerRadius, cornerRadius]);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * Represents a Summing Junction shape, used in control system diagrams to indicate\n     * mathematical operations like addition or subtraction. Extends MultiPathShape with\n     * a circular path containing cross lines.\n     */\n    class SummingJunction extends MultiPathShape {\n        /**\n         * @hidden\n         * Draws the summing junction shape path as a circle with intersecting lines.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const cx = width / 2;\n            const cy = height / 2;\n            const radius = Math.min(width, height) * 0.5;\n            const topY = cy - radius;\n            const bottomY = cy + radius;\n            const x1 = cx - radius / Math.SQRT2;\n            const y1 = cy - radius / Math.SQRT2;\n            const x2 = cx + radius / Math.SQRT2;\n            const y2 = cy + radius / Math.SQRT2;\n            drawingElement\n                .moveTo(cx, topY)\n                .arcTo([cx, bottomY], radius, radius, false, true)\n                .arcTo([cx, topY], radius, radius, false, true)\n                .moveTo(x1, y1)\n                .lineTo(x2, y2)\n                .moveTo(x2, y1)\n                .lineTo(x1, y2);\n        }\n    }\n\n    const textColor = (options) => {\n        if (options && options.color) {\n            options = deepExtend({}, options, {\n                fill: {\n                    color: options.color\n                }\n            });\n        }\n        return options;\n    };\n    const defaultOptions$6 = {\n        fontSize: 15,\n        fontFamily: 'sans-serif',\n        lineSpacing: 0,\n        textWrap: 'nowrap',\n        padding: getSpacing(0),\n        relativePadding: getSpacing(0),\n        stroke: {\n            width: 0\n        },\n        fill: {\n            color: 'black'\n        },\n        autoSize: true\n    };\n    /**\n     * A visual element that renders text content.\n     * Extends VisualBase and provides functionality for creating and managing text graphics with font styling.\n     */\n    class TextBlock extends VisualBase {\n        /**\n         * Creates a new TextBlock instance.\n         * @param options Configuration options for the text block\n         */\n        constructor(options) {\n            options = deepExtend({}, defaultOptions$6, options);\n            options = textColor(options);\n            super(options);\n            /** Array of text elements for multi-line text support. */\n            this.textElements = [];\n            /** Whether the text block can be aligned within its container. */\n            this.alignable = true;\n            this._setScale = AutoSizeableMixin._setScale.bind(this);\n            this._setTranslate = AutoSizeableMixin._setTranslate.bind(this);\n            this._initSize = AutoSizeableMixin._initSize.bind(this);\n            this._updateSize = AutoSizeableMixin._updateSize.bind(this);\n            this._font();\n            this._initText();\n            this._initSize();\n        }\n        /** @hidden */\n        _initText() {\n            const options = this.options;\n            this.textElements.length = 0;\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.T(defined(options.text) ? options.text : '', new kendo_drawing_cmn_chunk_js.P(), {\n                font: options.font\n            });\n            this.textElements.push(this.drawingElement);\n            this._fill();\n            this._stroke();\n        }\n        /** @hidden */\n        _fill(fillOptions) {\n            const fill = this._evalFillOptions(fillOptions);\n            if (fill.gradient) {\n                const gradient = fill.gradient;\n                const GradientClass = (gradient.type === 'radial' ? kendo_drawing_cmn_chunk_js.h : kendo_drawing_cmn_chunk_js.L);\n                this.textElements.forEach((el) => {\n                    el.fill(new GradientClass(gradient));\n                });\n            }\n            else {\n                this._setFill(fill);\n            }\n        }\n        /** @hidden */\n        _setFill(fill) {\n            this.textElements.forEach((el) => {\n                el.fill(fill.color, fill.opacity);\n            });\n        }\n        /** @hidden */\n        _stroke(strokeOptions) {\n            const stroke = this._evalStrokeOptions(strokeOptions);\n            this.textElements.forEach(el => el.options.set('stroke', stroke));\n        }\n        /** @hidden */\n        _font() {\n            const options = this.options;\n            if (options.fontFamily && defined(options.fontSize)) {\n                const fontOptions = [];\n                if (options.fontStyle) {\n                    fontOptions.push(options.fontStyle);\n                }\n                if (options.fontWeight) {\n                    fontOptions.push(options.fontWeight);\n                }\n                fontOptions.push(options.fontSize + (isNumber(options.fontSize) ? 'px' : ''));\n                fontOptions.push(options.fontFamily);\n                options.font = fontOptions.join(' ');\n            }\n            else {\n                delete options.font;\n            }\n        }\n        /**\n         * Gets or sets the text content of the text block.\n         * @param text The text content to set, or undefined to get current content\n         * @returns The current text content when called as getter\n         */\n        content(text) {\n            return this.drawingElement.content(text);\n        }\n        /**\n         * Redraws the text block with updated options.\n         * @param options New options to apply to the text block\n         */\n        redraw(options) {\n            if (options) {\n                let sizeChanged = false;\n                const textOptions = this.options;\n                options = textColor(options);\n                super.redraw(options);\n                if (options.fontFamily || defined(options.fontSize) || options.fontStyle || options.fontWeight) {\n                    deepExtend(textOptions, {\n                        fontFamily: options.fontFamily,\n                        fontSize: options.fontSize,\n                        fontStyle: options.fontStyle,\n                        fontWeight: options.fontWeight\n                    });\n                    this._font();\n                    this.drawingElement.options.set('font', textOptions.font);\n                    sizeChanged = true;\n                }\n                if (options.text) {\n                    this.content(options.text);\n                    sizeChanged = true;\n                }\n                if (!this._updateSize(options) && sizeChanged) {\n                    this._initSize();\n                }\n            }\n        }\n    }\n\n    class Box {\n        constructor(x1, y1, x2, y2) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n        }\n        width() {\n            return this.x2 - this.x1;\n        }\n        height() {\n            return this.y2 - this.y1;\n        }\n        pad(padding) {\n            const spacing = { ...padding };\n            this.x1 -= spacing.left;\n            this.x2 += spacing.right;\n            this.y1 -= spacing.top;\n            this.y2 += spacing.bottom;\n            return this;\n        }\n        unpad(padding) {\n            const spacing = { ...padding };\n            spacing.left = -spacing.left;\n            spacing.top = -spacing.top;\n            spacing.right = -spacing.right;\n            spacing.bottom = -spacing.bottom;\n            return this.pad(spacing);\n        }\n        toRect() {\n            return new kendo_drawing_cmn_chunk_js.R([this.x1, this.y1], [this.width(), this.height()]);\n        }\n    }\n\n    const parseAlign = (align = '') => {\n        const result = {\n            justifyContent: 'center', // horizontal align\n            alignContent: 'center' // vertical align\n        };\n        if (align.includes('left')) {\n            result.justifyContent = 'start';\n        }\n        if (align.includes('right')) {\n            result.justifyContent = 'end';\n        }\n        if (align.includes('top')) {\n            result.alignContent = 'start';\n        }\n        if (align.includes('bottom')) {\n            result.alignContent = 'end';\n        }\n        return result;\n    };\n    function getContentSpacing(shape, relativePadding) {\n        const spacing = getSpacing(relativePadding, 0);\n        const left = shape.width * spacing.left;\n        const top = shape.height * spacing.top;\n        const right = shape.width * spacing.right;\n        const bottom = shape.height * spacing.bottom;\n        return { left, top, right, bottom };\n    }\n    /**\n     * A text block that supports multi-line text with line wrapping and alignment.\n     * Extends TextBlock and provides functionality for rendering text across multiple lines with layout support.\n     */\n    class MultiLineTextBlock extends TextBlock {\n        constructor() {\n            super(...arguments);\n            /** Whether the text block can be aligned within its container. */\n            this.alignable = false;\n        }\n        /**\n         * Gets or sets the text content of the multi-line text block.\n         * @param text The text content to set, or undefined to get current content\n         * @returns The current text content when called as getter\n         */\n        content(text) {\n            if (text !== undefined) {\n                this.options.text = text;\n                this._initText();\n            }\n            return this.options.text;\n        }\n        /** @hidden */\n        _initText() {\n            this.textElements.length = 0;\n            this.alignable = false;\n            const drawingElement = this.drawingElement = this.drawingElement || new kendo_drawing_cmn_chunk_js.G();\n            if (drawingElement.children.length) {\n                drawingElement.clear();\n            }\n            const options = this.options;\n            const { shapeSize } = options;\n            const box = new Box(0, 0, shapeSize.width, shapeSize.height);\n            const contentSpacing = getContentSpacing(shapeSize, options.relativePadding);\n            box.unpad(contentSpacing);\n            box.unpad(options.padding);\n            const rect = box.toRect();\n            const layout = new kendo_drawing_cmn_chunk_js.j(rect, {\n                ...parseAlign(options.align),\n                lineSpacing: options.lineSpacing\n            });\n            this._textLines(rect ? rect.size.width : undefined).forEach((line) => {\n                const textElement = new kendo_drawing_cmn_chunk_js.T(line, new kendo_drawing_cmn_chunk_js.P(0, 0), {\n                    font: options.font\n                });\n                this.textElements.push(textElement);\n                (layout || drawingElement).append(textElement);\n            });\n            if (layout) {\n                layout.reflow();\n                drawingElement.append(layout);\n            }\n            this._fill();\n            this._stroke();\n        }\n        /** @hidden */\n        _textLines(maxWidth) {\n            const { text = '' } = this.options;\n            if (maxWidth === undefined) {\n                return [text];\n            }\n            const style = { font: this.options.font };\n            const measureText$1 = kendo_drawing_cmn_chunk_js.m;\n            const words = text.split(' ');\n            const lines = [];\n            let currentLine = '';\n            words.forEach((word) => {\n                while (measureText$1(word, style).width > maxWidth) {\n                    let part = '';\n                    for (let i = 1; i <= word.length; i++) {\n                        const testPart = word.substring(0, i);\n                        const width = measureText$1(testPart, style).width;\n                        if (width > maxWidth) {\n                            break;\n                        }\n                        part = testPart;\n                    }\n                    if (!part) {\n                        break;\n                    }\n                    if (currentLine) {\n                        lines.push(currentLine);\n                        currentLine = '';\n                    }\n                    lines.push(part);\n                    word = word.substring(part.length);\n                }\n                const testLine = currentLine ? `${currentLine} ${word}` : word;\n                const width = measureText$1(testLine, style).width;\n                if (width > maxWidth && currentLine) {\n                    lines.push(currentLine);\n                    currentLine = word;\n                }\n                else {\n                    currentLine = testLine;\n                }\n            });\n            if (currentLine) {\n                lines.push(currentLine);\n            }\n            return lines;\n        }\n    }\n\n    /**\n     * The Sugiyama aka layered layout algorithm.\n     *\n     * @type {*}\n     */\n    class LayeredLayout extends LayoutBase {\n        constructor(diagram) {\n            super();\n            if (isUndefined(diagram)) {\n                throw new Error('Diagram is not specified.');\n            }\n            this.diagram = diagram;\n        }\n        layout(options) {\n            this.transferOptions(options);\n            const adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            const graph = adapter.convert(options);\n            if (graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            const components = graph.getConnectedComponents();\n            if (isEmpty(components)) {\n                return;\n            }\n            for (let i = 0; i < components.length; i++) {\n                const component = components[i];\n                this.layoutGraph(component, options);\n            }\n            const finalNodeSet = this.gridLayoutComponents(components);\n            return new LayoutState(this.diagram, finalNodeSet);\n        }\n        /**\n         * Initializes the runtime data properties of the layout.\n         *\n         * @private\n         */\n        _initRuntimeProperties() {\n            for (let k = 0; k < this.graph.nodes.length; k++) {\n                const node = this.graph.nodes[k];\n                node.layer = -1;\n                node.downstreamLinkCount = 0;\n                node.upstreamLinkCount = 0;\n                node.isVirtual = false;\n                node.uBaryCenter = 0.0;\n                node.dBaryCenter = 0.0;\n                node.upstreamPriority = 0;\n                node.downstreamPriority = 0;\n                node.gridPosition = 0;\n            }\n        }\n        _prepare(graph) {\n            const current = [];\n            let i, l, link;\n            // defines a mapping of a node to the layer index\n            const layerMap = new Dictionary();\n            let layerCount = 0;\n            let targetLayer, next, target;\n            forEach(graph.nodes, function (node) {\n                if (node.incoming.length === 0) {\n                    layerMap.set(node, 0);\n                    current.push(node);\n                }\n            });\n            while (current.length > 0) {\n                next = current.shift();\n                for (i = 0; i < next.outgoing.length; i++) {\n                    link = next.outgoing[i];\n                    target = link.target;\n                    if (layerMap.containsKey(target)) {\n                        targetLayer = Math.max(layerMap.get(next) + 1, layerMap.get(target));\n                    }\n                    else {\n                        targetLayer = layerMap.get(next) + 1;\n                    }\n                    layerMap.set(target, targetLayer);\n                    if (targetLayer > layerCount) {\n                        layerCount = targetLayer;\n                    }\n                    if (!contains(current, target)) {\n                        current.push(target);\n                    }\n                }\n            }\n            const sortedNodes = layerMap.keys();\n            sortedNodes.sort(function (o1, o2) {\n                const o1layer = layerMap.get(o1);\n                const o2layer = layerMap.get(o2);\n                return sign(o2layer - o1layer);\n            });\n            for (let n = 0; n < sortedNodes.length; ++n) {\n                const node = sortedNodes[n];\n                let minLayer = Number.MAX_VALUE;\n                if (node.outgoing.length === 0) {\n                    continue;\n                }\n                for (l = 0; l < node.outgoing.length; ++l) {\n                    link = node.outgoing[l];\n                    minLayer = Math.min(minLayer, layerMap.get(link.target));\n                }\n                if (minLayer > 1) {\n                    layerMap.set(node, minLayer - 1);\n                }\n            }\n            this.layers = [];\n            let layer;\n            for (i = 0; i < layerCount + 1; i++) {\n                layer = [];\n                layer.linksTo = {};\n                this.layers.push(layer);\n            }\n            layerMap.forEach(function (node, layerVal) {\n                node.layer = layerVal;\n                this.layers[layerVal].push(node);\n            }, this);\n            // set initial grid positions\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n                for (i = 0; i < layer.length; i++) {\n                    layer[i].gridPosition = i;\n                }\n            }\n        }\n        /**\n         * Performs the layout of a single component.\n         */\n        layoutGraph(graph, options) {\n            if (isUndefined(graph)) {\n                throw new Error('No graph given or graph analysis of the diagram failed.');\n            }\n            if (isDefined(options)) {\n                this.transferOptions(options);\n            }\n            this.graph = graph;\n            // sets unique indices on the nodes\n            graph.setItemIndices();\n            // ensures no cycles present for this layout\n            const reversedEdges = graph.makeAcyclic();\n            // define the runtime props being used by the layout algorithm\n            this._initRuntimeProperties();\n            this._prepare(graph);\n            this._dummify();\n            this._optimizeCrossings();\n            this._swapPairs();\n            this.arrangeNodes();\n            this._moveThingsAround();\n            this._dedummify();\n            // re-reverse the links which were switched earlier\n            forEach(reversedEdges, function (e) {\n                if (e.points) {\n                    e.points.reverse();\n                }\n            });\n        }\n        setMinDist(m, _n, minDist) {\n            const l = m.layer;\n            const i = m.layerIndex;\n            // Validate indices to prevent prototype pollution\n            if (!Number.isInteger(l) || !Number.isInteger(i) || l < 0 || i < 0) {\n                throw new Error('Invalid layer or index value.');\n            }\n            this.minDistances[l][i] = minDist;\n        }\n        getMinDist(m, n) {\n            let dist = 0;\n            const i1 = m.layerIndex, i2 = n.layerIndex, l = m.layer, min = Math.min(i1, i2), max = Math.max(i1, i2);\n            // use Sum()?\n            for (let k = min; k < max; ++k) {\n                dist += this.minDistances[l][k];\n            }\n            return dist;\n        }\n        placeLeftToRight(leftClasses) {\n            const leftPos = new Dictionary();\n            let n, node;\n            for (let c = 0; c < this.layers.length; ++c) {\n                const classNodes = leftClasses[c];\n                if (!classNodes) {\n                    continue;\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    if (!leftPos.containsKey(node)) {\n                        this.placeLeft(node, leftPos, c);\n                    }\n                }\n                // adjust class\n                let d = Number.POSITIVE_INFINITY;\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    const rightSibling = this.rightSibling(node);\n                    if (rightSibling && this.nodeLeftClass.get(rightSibling) !== c) {\n                        d = Math.min(d, leftPos.get(rightSibling) - leftPos.get(node) - this.getMinDist(node, rightSibling));\n                    }\n                }\n                if (d === Number.POSITIVE_INFINITY) {\n                    const D = [];\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        const neighbors = [];\n                        addRange(neighbors, this.upNodes.get(node));\n                        addRange(neighbors, this.downNodes.get(node));\n                        for (let e = 0; e < neighbors.length; e++) {\n                            const neighbor = neighbors[e];\n                            if (this.nodeLeftClass.get(neighbor) < c) {\n                                D.push(leftPos.get(neighbor) - leftPos.get(node));\n                            }\n                        }\n                    }\n                    D.sort();\n                    if (D.length === 0) {\n                        d = 0;\n                    }\n                    else if (D.length % 2 === 1) {\n                        d = D[this.intDiv(D.length, 2)];\n                    }\n                    else {\n                        d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                    }\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    leftPos.set(node, leftPos.get(node) + d);\n                }\n            }\n            return leftPos;\n        }\n        placeRightToLeft(rightClasses) {\n            const rightPos = new Dictionary();\n            let n, node;\n            for (let c = 0; c < this.layers.length; ++c) {\n                const classNodes = rightClasses[c];\n                if (!classNodes) {\n                    continue;\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    if (!rightPos.containsKey(node)) {\n                        this.placeRight(node, rightPos, c);\n                    }\n                }\n                // adjust class\n                let d = Number.NEGATIVE_INFINITY;\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    const leftSibling = this.leftSibling(node);\n                    if (leftSibling && this.nodeRightClass.get(leftSibling) !== c) {\n                        d = Math.max(d, rightPos.get(leftSibling) - rightPos.get(node) + this.getMinDist(leftSibling, node));\n                    }\n                }\n                if (d === Number.NEGATIVE_INFINITY) {\n                    const D = [];\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        const neighbors = [];\n                        addRange(neighbors, this.upNodes.get(node));\n                        addRange(neighbors, this.downNodes.get(node));\n                        for (let e = 0; e < neighbors.length; e++) {\n                            const neighbor = neighbors[e];\n                            if (this.nodeRightClass.get(neighbor) < c) {\n                                D.push(rightPos.get(node) - rightPos.get(neighbor));\n                            }\n                        }\n                    }\n                    D.sort();\n                    if (D.length === 0) {\n                        d = 0;\n                    }\n                    else if (D.length % 2 === 1) {\n                        d = D[this.intDiv(D.length, 2)];\n                    }\n                    else {\n                        d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                    }\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    rightPos.set(node, rightPos.get(node) + d);\n                }\n            }\n            return rightPos;\n        }\n        _getLeftWing() {\n            const leftWing = { value: null };\n            const result = this.computeClasses(leftWing, 1);\n            this.nodeLeftClass = leftWing.value;\n            return result;\n        }\n        _getRightWing() {\n            const rightWing = { value: null };\n            const result = this.computeClasses(rightWing, -1);\n            this.nodeRightClass = rightWing.value;\n            return result;\n        }\n        computeClasses(wingPair, d) {\n            let currentWing = 0;\n            const wing = wingPair.value = new Dictionary();\n            for (let l = 0; l < this.layers.length; ++l) {\n                currentWing = l;\n                const layer = this.layers[l];\n                for (let n = d === 1 ? 0 : layer.length - 1; n >= 0 && n < layer.length; n += d) {\n                    const node = layer[n];\n                    if (!wing.containsKey(node)) {\n                        wing.set(node, currentWing);\n                        if (node.isVirtual) {\n                            const ndsinl = this._nodesInLink(node);\n                            for (let kk = 0; kk < ndsinl.length; kk++) {\n                                const vnode = ndsinl[kk];\n                                wing.set(vnode, currentWing);\n                            }\n                        }\n                    }\n                    else {\n                        currentWing = wing.get(node);\n                    }\n                }\n            }\n            const wings = [];\n            for (let i = 0; i < this.layers.length; i++) {\n                wings.push(null);\n            }\n            wing.forEach(function (node, classIndex) {\n                if (wings[classIndex] === null) {\n                    wings[classIndex] = [];\n                }\n                wings[classIndex].push(node);\n            });\n            return wings;\n        }\n        _isVerticalLayout() {\n            return this.options.subtype.toLowerCase() === 'up' || this.options.subtype.toLowerCase() === 'down' || this.options.subtype.toLowerCase() === 'vertical';\n        }\n        _isHorizontalLayout() {\n            return this.options.subtype.toLowerCase() === 'right' || this.options.subtype.toLowerCase() === 'left' || this.options.subtype.toLowerCase() === 'horizontal';\n        }\n        _isIncreasingLayout() {\n            // meaning that the visiting of the layers goes in the natural order of increasing layer index\n            return this.options.subtype.toLowerCase() === 'right' || this.options.subtype.toLowerCase() === 'down';\n        }\n        _moveThingsAround() {\n            let i, l, node, layer, n, w;\n            // sort the layers by their grid position\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                layer.sort(this._gridPositionComparer.bind(this));\n            }\n            this.minDistances = [];\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                this.minDistances[l] = [];\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    node.layerIndex = n;\n                    this.minDistances[l][n] = this.options.nodeDistance;\n                    if (n < layer.length - 1) {\n                        if (this._isVerticalLayout()) {\n                            this.minDistances[l][n] += (node.width + layer[n + 1].width) / 2;\n                        }\n                        else {\n                            this.minDistances[l][n] += (node.height + layer[n + 1].height) / 2;\n                        }\n                    }\n                }\n            }\n            this.downNodes = new Dictionary();\n            this.upNodes = new Dictionary();\n            forEach(this.graph.nodes, function (gNode) {\n                this.downNodes.set(gNode, []);\n                this.upNodes.set(gNode, []);\n            }, this);\n            forEach(this.graph.links, function (link) {\n                const origin = link.source;\n                const dest = link.target;\n                let down = null, up = null;\n                if (origin.layer > dest.layer) {\n                    down = link.source;\n                    up = link.target;\n                }\n                else {\n                    up = link.source;\n                    down = link.target;\n                }\n                this.downNodes.get(up).push(down);\n                this.upNodes.get(down).push(up);\n            }, this);\n            this.downNodes.forEachValue(function (list) {\n                list.sort(this._gridPositionComparer);\n            }, this);\n            this.upNodes.forEachValue(function (list) {\n                list.sort(this._gridPositionComparer);\n            }, this);\n            for (l = 0; l < this.layers.length - 1; ++l) {\n                layer = this.layers[l];\n                for (w = 0; w < layer.length - 1; w++) {\n                    const currentNode = layer[w];\n                    if (!currentNode.isVirtual) {\n                        continue;\n                    }\n                    const currDown = this.downNodes.get(currentNode)[0];\n                    if (!currDown.isVirtual) {\n                        continue;\n                    }\n                    for (n = w + 1; n < layer.length; ++n) {\n                        node = layer[n];\n                        if (!node.isVirtual) {\n                            continue;\n                        }\n                        const downNode = this.downNodes.get(node)[0];\n                        if (!downNode.isVirtual) {\n                            continue;\n                        }\n                        if (currDown.gridPosition > downNode.gridPosition) {\n                            const pos = currDown.gridPosition;\n                            currDown.gridPosition = downNode.gridPosition;\n                            downNode.gridPosition = pos;\n                            const i1 = currDown.layerIndex;\n                            const i2 = downNode.layerIndex;\n                            this.layers[l + 1][i1] = downNode;\n                            this.layers[l + 1][i2] = currDown;\n                            currDown.layerIndex = i2;\n                            downNode.layerIndex = i1;\n                        }\n                    }\n                }\n            }\n            const leftClasses = this._getLeftWing();\n            const rightClasses = this._getRightWing();\n            const leftPos = this.placeLeftToRight(leftClasses);\n            const rightPos = this.placeRightToLeft(rightClasses);\n            const x = new Dictionary();\n            forEach(this.graph.nodes, function (gNode) {\n                x.set(gNode, (leftPos.get(gNode) + rightPos.get(gNode)) / 2);\n            });\n            const order = new Dictionary();\n            const placed = new Dictionary();\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                let sequenceStart = -1; // , sequenceEnd = -1;\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    order.set(node, 0);\n                    placed.set(node, false);\n                    if (node.isVirtual) {\n                        if (sequenceStart === -1) {\n                            sequenceStart = n;\n                        }\n                        else if (sequenceStart === n - 1) {\n                            sequenceStart = n;\n                        }\n                        else {\n                            // sequenceEnd = n;\n                            order.set(layer[sequenceStart], 0);\n                            if (x.get(node) - x.get(layer[sequenceStart]) === this.getMinDist(layer[sequenceStart], node)) {\n                                placed.set(layer[sequenceStart], true);\n                            }\n                            else {\n                                placed.set(layer[sequenceStart], false);\n                            }\n                            sequenceStart = n;\n                        }\n                    }\n                }\n            }\n            const directions = [1, -1];\n            forEach(directions, function (d) {\n                const start = d === 1 ? 0 : this.layers.length - 1;\n                for (let ll = start; ll >= 0 && ll < this.layers.length; ll += d) {\n                    const layer2 = this.layers[ll];\n                    let virtualStartIndex = this._firstVirtualNode(layer2);\n                    let virtualStart = null;\n                    let sequence = null;\n                    if (virtualStartIndex !== -1) {\n                        virtualStart = layer2[virtualStartIndex];\n                        sequence = [];\n                        for (i = 0; i < virtualStartIndex; i++) {\n                            sequence.push(layer2[i]);\n                        }\n                    }\n                    else {\n                        virtualStart = null;\n                        sequence = layer2;\n                    }\n                    if (sequence.length > 0) {\n                        this._sequencer(x, null, virtualStart, d, sequence);\n                        for (i = 0; i < sequence.length - 1; ++i) {\n                            this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                        }\n                        if (virtualStart) {\n                            this.setMinDist(sequence[sequence.length - 1], virtualStart, x.get(virtualStart) - x.get(sequence[sequence.length - 1]));\n                        }\n                    }\n                    while (virtualStart) {\n                        const virtualEnd = this.nextVirtualNode(layer2, virtualStart);\n                        if (!virtualEnd) {\n                            virtualStartIndex = virtualStart.layerIndex;\n                            sequence = [];\n                            for (i = virtualStartIndex + 1; i < layer2.length; i++) {\n                                sequence.push(layer2[i]);\n                            }\n                            if (sequence.length > 0) {\n                                this._sequencer(x, virtualStart, null, d, sequence);\n                                for (i = 0; i < sequence.length - 1; ++i) {\n                                    this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                                }\n                                this.setMinDist(virtualStart, sequence[0], x.get(sequence[0]) - x.get(virtualStart));\n                            }\n                        }\n                        else if (order.get(virtualStart) === d) {\n                            virtualStartIndex = virtualStart.layerIndex;\n                            const virtualEndIndex = virtualEnd.layerIndex;\n                            sequence = [];\n                            for (i = virtualStartIndex + 1; i < virtualEndIndex; i++) {\n                                sequence.push(layer2[i]);\n                            }\n                            if (sequence.length > 0) {\n                                this._sequencer(x, virtualStart, virtualEnd, d, sequence);\n                            }\n                            placed.set(virtualStart, true);\n                        }\n                        virtualStart = virtualEnd;\n                    }\n                    this.adjustDirections(ll, d, order, placed);\n                }\n            }, this);\n            const fromLayerIndex = this._isIncreasingLayout() ? 0 : this.layers.length - 1;\n            const reachedFinalLayerIndex = function (k, ctx) {\n                if (ctx._isIncreasingLayout()) {\n                    return k < ctx.layers.length;\n                }\n                else {\n                    return k >= 0;\n                }\n            };\n            const layerIncrement = this._isIncreasingLayout() ? +1 : -1;\n            let offset = 0;\n            /**\n             * Calcs the max height of the given layer.\n             */\n            function maximumHeight(layer2, ctx) {\n                let height = Number.MIN_VALUE;\n                for (let nn = 0; nn < layer2.length; ++nn) {\n                    const node2 = layer2[nn];\n                    if (ctx._isVerticalLayout()) {\n                        height = Math.max(height, node2.height);\n                    }\n                    else {\n                        height = Math.max(height, node2.width);\n                    }\n                }\n                return height;\n            }\n            for (i = fromLayerIndex; reachedFinalLayerIndex(i, this); i += layerIncrement) {\n                layer = this.layers[i];\n                const height = maximumHeight(layer, this);\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    if (this._isVerticalLayout()) {\n                        node.x = x.get(node);\n                        node.y = offset + height / 2;\n                    }\n                    else {\n                        node.x = offset + height / 2;\n                        node.y = x.get(node);\n                    }\n                }\n                offset += this.options.layerSeparation + height;\n            }\n        }\n        adjustDirections(l, d, order, placed) {\n            if (l + d < 0 || l + d >= this.layers.length) {\n                return;\n            }\n            let prevBridge = null, prevBridgeTarget = null;\n            const layer = this.layers[l + d];\n            for (let n = 0; n < layer.length; ++n) {\n                const nextBridge = layer[n];\n                if (nextBridge.isVirtual) {\n                    const nextBridgeTarget = this.getNeighborOnLayer(nextBridge, l);\n                    if (nextBridgeTarget.isVirtual) {\n                        if (prevBridge) {\n                            let p = placed.get(prevBridgeTarget);\n                            const clayer = this.layers[l];\n                            const i1 = prevBridgeTarget.layerIndex;\n                            const i2 = nextBridgeTarget.layerIndex;\n                            for (let i = i1 + 1; i < i2; ++i) {\n                                if (clayer[i].isVirtual) {\n                                    p = p && placed.get(clayer[i]);\n                                }\n                            }\n                            if (p) {\n                                order.set(prevBridge, d);\n                                const j1 = prevBridge.layerIndex;\n                                const j2 = nextBridge.layerIndex;\n                                for (let j = j1 + 1; j < j2; ++j) {\n                                    if (layer[j].isVirtual) {\n                                        order.set(layer[j], d);\n                                    }\n                                }\n                            }\n                        }\n                        prevBridge = nextBridge;\n                        prevBridgeTarget = nextBridgeTarget;\n                    }\n                }\n            }\n        }\n        getNeighborOnLayer(node, l) {\n            let neighbor = this.upNodes.get(node)[0];\n            if (neighbor.layer === l) {\n                return neighbor;\n            }\n            neighbor = this.downNodes.get(node)[0];\n            if (neighbor.layer === l) {\n                return neighbor;\n            }\n            return null;\n        }\n        _sequencer(x, virtualStart, virtualEnd, dir, sequence) {\n            if (sequence.length === 1) {\n                this._sequenceSingle(x, virtualStart, virtualEnd, dir, sequence[0]);\n            }\n            if (sequence.length > 1) {\n                const r = sequence.length, t = this.intDiv(r, 2);\n                this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(0, t));\n                this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(t));\n                this.combineSequences(x, virtualStart, virtualEnd, dir, sequence);\n            }\n        }\n        _sequenceSingle(x, virtualStart, virtualEnd, dir, node) {\n            const neighbors = dir === -1 ? this.downNodes.get(node) : this.upNodes.get(node);\n            const n = neighbors.length;\n            if (n !== 0) {\n                if (n % 2 === 1) {\n                    x.set(node, x.get(neighbors[this.intDiv(n, 2)]));\n                }\n                else {\n                    x.set(node, (x.get(neighbors[this.intDiv(n, 2) - 1]) + x.get(neighbors[this.intDiv(n, 2)])) / 2);\n                }\n                if (virtualStart) {\n                    x.set(node, Math.max(x.get(node), x.get(virtualStart) + this.getMinDist(virtualStart, node)));\n                }\n                if (virtualEnd) {\n                    x.set(node, Math.min(x.get(node), x.get(virtualEnd) - this.getMinDist(node, virtualEnd)));\n                }\n            }\n        }\n        combineSequences(x, virtualStart, virtualEnd, dir, sequence) {\n            const r = sequence.length, t = this.intDiv(r, 2);\n            // collect left changes\n            const leftHeap = [];\n            let i, c, n, neighbors, neighbor, pair;\n            for (i = 0; i < t; ++i) {\n                c = 0;\n                neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n                for (n = 0; n < neighbors.length; ++n) {\n                    neighbor = neighbors[n];\n                    if (x.get(neighbor) >= x.get(sequence[i])) {\n                        c++;\n                    }\n                    else {\n                        c--;\n                        leftHeap.push({ k: x.get(neighbor) + this.getMinDist(sequence[i], sequence[t - 1]), v: 2 });\n                    }\n                }\n                leftHeap.push({ k: x.get(sequence[i]) + this.getMinDist(sequence[i], sequence[t - 1]), v: c });\n            }\n            if (virtualStart) {\n                leftHeap.push({ k: x.get(virtualStart) + this.getMinDist(virtualStart, sequence[t - 1]), v: Number.MAX_VALUE });\n            }\n            leftHeap.sort(this._positionDescendingComparer.bind(this));\n            // collect right changes\n            const rightHeap = [];\n            for (i = t; i < r; ++i) {\n                c = 0;\n                neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n                for (n = 0; n < neighbors.length; ++n) {\n                    neighbor = neighbors[n];\n                    if (x.get(neighbor) <= x.get(sequence[i])) {\n                        c++;\n                    }\n                    else {\n                        c--;\n                        rightHeap.push({ k: x.get(neighbor) - this.getMinDist(sequence[i], sequence[t]), v: 2 });\n                    }\n                }\n                rightHeap.push({ k: x.get(sequence[i]) - this.getMinDist(sequence[i], sequence[t]), v: c });\n            }\n            if (virtualEnd) {\n                rightHeap.push({ k: x.get(virtualEnd) - this.getMinDist(virtualEnd, sequence[t]), v: Number.MAX_VALUE });\n            }\n            rightHeap.sort(this._positionAscendingComparer.bind(this));\n            let leftRes = 0, rightRes = 0;\n            const m = this.getMinDist(sequence[t - 1], sequence[t]);\n            while (x.get(sequence[t]) - x.get(sequence[t - 1]) < m) {\n                if (leftRes < rightRes) {\n                    if (leftHeap.length === 0) {\n                        x.set(sequence[t - 1], x.get(sequence[t]) - m);\n                        break;\n                    }\n                    else {\n                        pair = leftHeap.shift();\n                        leftRes = leftRes + pair.v;\n                        x.set(sequence[t - 1], pair.k);\n                        x.set(sequence[t - 1], Math.max(x.get(sequence[t - 1]), x.get(sequence[t]) - m));\n                    }\n                }\n                else {\n                    if (rightHeap.length === 0) {\n                        x.set(sequence[t], x.get(sequence[t - 1]) + m);\n                        break;\n                    }\n                    else {\n                        pair = rightHeap.shift();\n                        rightRes = rightRes + pair.v;\n                        x.set(sequence[t], pair.k);\n                        x.set(sequence[t], Math.min(x.get(sequence[t]), x.get(sequence[t - 1]) + m));\n                    }\n                }\n            }\n            for (i = t - 2; i >= 0; i--) {\n                x.set(sequence[i], Math.min(x.get(sequence[i]), x.get(sequence[t - 1]) - this.getMinDist(sequence[i], sequence[t - 1])));\n            }\n            for (i = t + 1; i < r; i++) {\n                x.set(sequence[i], Math.max(x.get(sequence[i]), x.get(sequence[t]) + this.getMinDist(sequence[i], sequence[t])));\n            }\n        }\n        placeLeft(node, leftPos, leftClass) {\n            let pos = Number.NEGATIVE_INFINITY;\n            forEach(this._getComposite(node), function (v) {\n                const leftSibling = this.leftSibling(v);\n                if (leftSibling && this.nodeLeftClass.get(leftSibling) === this.nodeLeftClass.get(v)) {\n                    if (!leftPos.containsKey(leftSibling)) {\n                        this.placeLeft(leftSibling, leftPos, leftClass);\n                    }\n                    pos = Math.max(pos, leftPos.get(leftSibling) + this.getMinDist(leftSibling, v));\n                }\n            }, this);\n            if (pos === Number.NEGATIVE_INFINITY) {\n                pos = 0;\n            }\n            forEach(this._getComposite(node), function (v) {\n                leftPos.set(v, pos);\n            });\n        }\n        placeRight(node, rightPos, rightClass) {\n            let pos = Number.POSITIVE_INFINITY;\n            forEach(this._getComposite(node), function (v) {\n                const rightSibling = this.rightSibling(v);\n                if (rightSibling && this.nodeRightClass.get(rightSibling) === this.nodeRightClass.get(v)) {\n                    if (!rightPos.containsKey(rightSibling)) {\n                        this.placeRight(rightSibling, rightPos, rightClass);\n                    }\n                    pos = Math.min(pos, rightPos.get(rightSibling) - this.getMinDist(v, rightSibling));\n                }\n            }, this);\n            if (pos === Number.POSITIVE_INFINITY) {\n                pos = 0;\n            }\n            forEach(this._getComposite(node), function (v) {\n                rightPos.set(v, pos);\n            });\n        }\n        leftSibling(node) {\n            const layer = this.layers[node.layer], layerIndex = node.layerIndex;\n            return layerIndex === 0 ? null : layer[layerIndex - 1];\n        }\n        rightSibling(node) {\n            const layer = this.layers[node.layer];\n            const layerIndex = node.layerIndex;\n            return layerIndex === layer.length - 1 ? null : layer[layerIndex + 1];\n        }\n        _getComposite(node) {\n            return node.isVirtual ? this._nodesInLink(node) : [node];\n        }\n        arrangeNodes() {\n            let i, l, ni, layer, node;\n            // Initialize node's base priority\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n                for (ni = 0; ni < layer.length; ni++) {\n                    node = layer[ni];\n                    node.upstreamPriority = node.upstreamLinkCount;\n                    node.downstreamPriority = node.downstreamLinkCount;\n                }\n            }\n            // Layout is invoked after MinimizeCrossings\n            // so we may assume node's barycenters are initially correct\n            const maxLayoutIterations = 2;\n            for (let it = 0; it < maxLayoutIterations; it++) {\n                for (i = this.layers.length - 1; i >= 1; i--) {\n                    this.layoutLayer(false, i);\n                }\n                for (i = 0; i < this.layers.length - 1; i++) {\n                    this.layoutLayer(true, i);\n                }\n            }\n            // Offset the whole structure so that there are no gridPositions < 0\n            let gridPos = Number.MAX_VALUE;\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n                for (ni = 0; ni < layer.length; ni++) {\n                    node = layer[ni];\n                    gridPos = Math.min(gridPos, node.gridPosition);\n                }\n            }\n            if (gridPos < 0) {\n                for (l = 0; l < this.layers.length; l++) {\n                    layer = this.layers[l];\n                    for (ni = 0; ni < layer.length; ni++) {\n                        node = layer[ni];\n                        node.gridPosition = node.gridPosition - gridPos;\n                    }\n                }\n            }\n        }\n        /// <summary>\n        /// Layout of a single layer.\n        /// </summary>\n        /// <param name=\"layerIndex\">The layer to organize.</param>\n        /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n        /// <seealso cref=\"OptimizeCrossings()\"/>\n        layoutLayer(down, layer) {\n            let iconsidered;\n            let considered;\n            if (down) {\n                considered = this.layers[iconsidered = layer + 1];\n            }\n            else {\n                considered = this.layers[iconsidered = layer - 1];\n            }\n            // list containing the nodes in the considered layer sorted by priority\n            const sorted = [];\n            for (let n = 0; n < considered.length; n++) {\n                sorted.push(considered[n]);\n            }\n            sorted.sort(function (n1, n2) {\n                const n1Priority = (n1.upstreamPriority + n1.downstreamPriority) / 2;\n                const n2Priority = (n2.upstreamPriority + n2.downstreamPriority) / 2;\n                if (Math.abs(n1Priority - n2Priority) < 0.0001) {\n                    return 0;\n                }\n                if (n1Priority < n2Priority) {\n                    return 1;\n                }\n                return -1;\n            });\n            // each node strives for its barycenter; high priority nodes start first\n            forEach(sorted, function (node) {\n                let nodeGridPos = node.gridPosition;\n                const nodeBaryCenter = this.calcBaryCenter(node);\n                const nodePriority = (node.upstreamPriority + node.downstreamPriority) / 2;\n                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.0001) {\n                    // This node is exactly at its barycenter -> perfect\n                    return;\n                }\n                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.25 + 0.0001) {\n                    // This node is close enough to the barycenter -> should work\n                    return;\n                }\n                if (nodeGridPos < nodeBaryCenter) {\n                    // Try to move the node to the right in an\n                    // attempt to reach its barycenter\n                    while (nodeGridPos < nodeBaryCenter) {\n                        if (!this.moveRight(node, considered, nodePriority)) {\n                            break;\n                        }\n                        nodeGridPos = node.gridPosition;\n                    }\n                }\n                else {\n                    // Try to move the node to the left in an\n                    // attempt to reach its barycenter\n                    while (nodeGridPos > nodeBaryCenter) {\n                        if (!this.moveLeft(node, considered, nodePriority)) {\n                            break;\n                        }\n                        nodeGridPos = node.gridPosition;\n                    }\n                }\n            }, this);\n            // after the layer has been rearranged we need to recalculate the barycenters\n            // of the nodes in the surrounding layers\n            if (iconsidered > 0) {\n                this.calcDownData(iconsidered - 1);\n            }\n            if (iconsidered < this.layers.length - 1) {\n                this.calcUpData(iconsidered + 1);\n            }\n        }\n        /// <summary>\n        /// Moves the node to the right and returns <c>true</c> if this was possible.\n        /// </summary>\n        /// <param name=\"node\">The node.</param>\n        /// <param name=\"layer\">The layer.</param>\n        /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n        moveRight(node, layer, priority) {\n            const index = indexOf(layer, node);\n            if (index === layer.length - 1) {\n                // this is the last node in the layer, so we can move to the right without troubles\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n            const rightNode = layer[index + 1];\n            const rightNodePriority = (rightNode.upstreamPriority + rightNode.downstreamPriority) / 2;\n            // check if there is space between the right and the current node\n            if (rightNode.gridPosition > node.gridPosition + 1) {\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n            // we have reached a node with higher priority; no movement is allowed\n            if (rightNodePriority > priority ||\n                Math.abs(rightNodePriority - priority) < 0.0001) {\n                return false;\n            }\n            // the right node has lower priority - try to move it\n            if (this.moveRight(rightNode, layer, priority)) {\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n            return false;\n        }\n        /// <summary>\n        /// Moves the node to the left and returns <c>true</c> if this was possible.\n        /// </summary>\n        /// <param name=\"node\">The node.</param>\n        /// <param name=\"layer\">The layer.</param>\n        /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n        moveLeft(node, layer, priority) {\n            const index = indexOf(layer, node);\n            if (index === 0) {\n                // this is the last node in the layer, so we can move to the left without troubles\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n            const leftNode = layer[index - 1];\n            const leftNodePriority = (leftNode.upstreamPriority + leftNode.downstreamPriority) / 2;\n            // check if there is space between the left and the current node\n            if (leftNode.gridPosition < node.gridPosition - 1) {\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n            // we have reached a node with higher priority; no movement is allowed\n            if (leftNodePriority > priority ||\n                Math.abs(leftNodePriority - priority) < 0.0001) {\n                return false;\n            }\n            // The left node has lower priority - try to move it\n            if (this.moveLeft(leftNode, layer, priority)) {\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n            return false;\n        }\n        mapVirtualNode(node, link) {\n            this.nodeToLinkMap.set(node, link);\n            if (!this.linkToNodeMap.containsKey(link)) {\n                this.linkToNodeMap.set(link, []);\n            }\n            this.linkToNodeMap.get(link).push(node);\n        }\n        _nodesInLink(node) {\n            return this.linkToNodeMap.get(this.nodeToLinkMap.get(node));\n        }\n        /// <summary>\n        /// Inserts dummy nodes to break long links.\n        /// </summary>\n        _dummify() {\n            this.linkToNodeMap = new Dictionary();\n            this.nodeToLinkMap = new Dictionary();\n            const links = this.graph.links.slice(0);\n            const layers = this.layers;\n            let layer, pos, newNode, node, r, newLink, i, l;\n            const addLinkBetweenLayers = function (upLayer, downLayer, link) {\n                layers[upLayer].linksTo[downLayer] = layers[upLayer].linksTo[downLayer] || [];\n                layers[upLayer].linksTo[downLayer].push(link);\n            };\n            for (l = 0; l < links.length; l++) {\n                const link = links[l];\n                const o = link.source;\n                const d = link.target;\n                const oLayer = o.layer;\n                const dLayer = d.layer;\n                const oPos = o.gridPosition;\n                const dPos = d.gridPosition;\n                const step = (dPos - oPos) / Math.abs(dLayer - oLayer);\n                let p = o;\n                if (oLayer - dLayer > 1) {\n                    for (i = oLayer - 1; i > dLayer; i--) {\n                        newNode = new Node();\n                        newNode.x = o.x;\n                        newNode.y = o.y;\n                        newNode.width = o.width / 100;\n                        newNode.height = o.height / 100;\n                        layer = layers[i];\n                        pos = (i - dLayer) * step + oPos;\n                        if (pos > layer.length) {\n                            pos = layer.length;\n                        }\n                        // check if origin and dest are both last\n                        if (oPos >= layers[oLayer].length - 1 &&\n                            dPos >= layers[dLayer].length - 1) {\n                            pos = layer.length;\n                        }\n                        else if (oPos === 0 && dPos === 0) { // check if origin and destination are both first\n                            pos = 0;\n                        }\n                        newNode.layer = i;\n                        newNode.uBaryCenter = 0.0;\n                        newNode.dBaryCenter = 0.0;\n                        newNode.upstreamLinkCount = 0;\n                        newNode.downstreamLinkCount = 0;\n                        newNode.gridPosition = pos;\n                        newNode.isVirtual = true;\n                        insert(layer, newNode, pos);\n                        // translate rightwards nodes' positions\n                        for (r = pos + 1; r < layer.length; r++) {\n                            node = layer[r];\n                            node.gridPosition = node.gridPosition + 1;\n                        }\n                        newLink = new Link(p, newNode);\n                        newLink.depthOfDumminess = 0;\n                        addLinkBetweenLayers(i - 1, i, newLink);\n                        p = newNode;\n                        // add the new node and the new link to the graph\n                        this.graph._addNode(newNode);\n                        this.graph.addLink(newLink);\n                        newNode.index = this.graph.nodes.length - 1;\n                        this.mapVirtualNode(newNode, link);\n                    }\n                    // set the origin of the real arrow to the last dummy\n                    addLinkBetweenLayers(dLayer - 1, dLayer, newLink);\n                    link.changeSource(p);\n                    link.depthOfDumminess = oLayer - dLayer - 1;\n                }\n                else if (oLayer - dLayer < -1) {\n                    for (i = oLayer + 1; i < dLayer; i++) {\n                        newNode = new Node();\n                        newNode.x = o.x;\n                        newNode.y = o.y;\n                        newNode.width = o.width / 100;\n                        newNode.height = o.height / 100;\n                        layer = layers[i];\n                        pos = (i - oLayer) * step + oPos;\n                        if (pos > layer.length) {\n                            pos = layer.length;\n                        }\n                        // check if origin and dest are both last\n                        if (oPos >= layers[oLayer].length - 1 &&\n                            dPos >= layers[dLayer].length - 1) {\n                            pos = layer.length;\n                        }\n                        else if (oPos === 0 && dPos === 0) { // check if origin and destination are both first\n                            pos = 0;\n                        }\n                        newNode.layer = i;\n                        newNode.uBaryCenter = 0.0;\n                        newNode.dBaryCenter = 0.0;\n                        newNode.upstreamLinkCount = 0;\n                        newNode.downstreamLinkCount = 0;\n                        newNode.gridPosition = pos;\n                        newNode.isVirtual = true;\n                        pos = Math.floor(pos); // truncates to int\n                        insert(layer, newNode, pos);\n                        // translate rightwards nodes' positions\n                        for (r = pos + 1; r < layer.length; r++) {\n                            node = layer[r];\n                            node.gridPosition = node.gridPosition + 1;\n                        }\n                        newLink = new Link(p, newNode);\n                        newLink.depthOfDumminess = 0;\n                        addLinkBetweenLayers(i - 1, i, newLink);\n                        p = newNode;\n                        // add the new node and the new link to the graph\n                        this.graph._addNode(newNode);\n                        this.graph.addLink(newLink);\n                        newNode.index = this.graph.nodes.length - 1;\n                        this.mapVirtualNode(newNode, link);\n                    }\n                    addLinkBetweenLayers(dLayer - 1, dLayer, link);\n                    // Set the origin of the real arrow to the last dummy\n                    link.changeSource(p);\n                    link.depthOfDumminess = dLayer - oLayer - 1;\n                }\n                else {\n                    addLinkBetweenLayers(oLayer, dLayer, link);\n                }\n            }\n        }\n        /// <summary>\n        /// Removes the dummy nodes inserted earlier to break long links.\n        /// </summary>\n        /// <remarks>The virtual nodes are effectively turned into intermediate connection points.</remarks>\n        _dedummify() {\n            let dedum = true;\n            while (dedum) {\n                dedum = false;\n                for (let l = 0; l < this.graph.links.length; l++) {\n                    const link = this.graph.links[l];\n                    if (!link.depthOfDumminess) {\n                        continue;\n                    }\n                    const points = [];\n                    // add points in reverse order\n                    points.unshift({ x: link.target.x, y: link.target.y });\n                    points.unshift({ x: link.source.x, y: link.source.y });\n                    // _dedummify the link\n                    let temp = link;\n                    const depthOfDumminess = link.depthOfDumminess;\n                    for (let d = 0; d < depthOfDumminess; d++) {\n                        const node = temp.source;\n                        const prevLink = node.incoming[0];\n                        points.unshift({ x: prevLink.source.x, y: prevLink.source.y });\n                        temp = prevLink;\n                    }\n                    // restore the original link origin\n                    link.changeSource(temp.source);\n                    // reset dummification flag\n                    link.depthOfDumminess = 0;\n                    // note that we only need the intermediate points, floating links have been dropped in the analysis\n                    if (points.length > 2) {\n                        // first and last are the endpoints\n                        points.splice(0, 1);\n                        points.splice(points.length - 1);\n                        link.points = points;\n                    }\n                    else {\n                        link.points = [];\n                    }\n                    // we are not going to delete the dummy elements;\n                    // they won't be needed anymore anyway.\n                    dedum = true;\n                    break;\n                }\n            }\n        }\n        /// <summary>\n        /// Optimizes/reduces the crossings between the layers by turning the crossing problem into a (combinatorial) number ordering problem.\n        /// </summary>\n        _optimizeCrossings() {\n            let moves = -1, i;\n            const maxIterations = 3;\n            let iter = 0;\n            while (moves !== 0) {\n                if (iter++ > maxIterations) {\n                    break;\n                }\n                moves = 0;\n                for (i = this.layers.length - 1; i >= 1; i--) {\n                    moves += this.optimizeLayerCrossings(false, i);\n                }\n                for (i = 0; i < this.layers.length - 1; i++) {\n                    moves += this.optimizeLayerCrossings(true, i);\n                }\n            }\n        }\n        calcUpData(layer) {\n            if (layer === 0) {\n                return;\n            }\n            const considered = this.layers[layer];\n            let i, l, link;\n            const upLayer = new Set();\n            const temp = this.layers[layer - 1];\n            for (i = 0; i < temp.length; i++) {\n                upLayer.add(temp[i]);\n            }\n            for (i = 0; i < considered.length; i++) {\n                const node = considered[i];\n                // calculate barycenter\n                let sum = 0;\n                let total = 0;\n                for (l = 0; l < node.incoming.length; l++) {\n                    link = node.incoming[l];\n                    if (upLayer.contains(link.source)) {\n                        total++;\n                        sum += link.source.gridPosition;\n                    }\n                }\n                for (l = 0; l < node.outgoing.length; l++) {\n                    link = node.outgoing[l];\n                    if (upLayer.contains(link.target)) {\n                        total++;\n                        sum += link.target.gridPosition;\n                    }\n                }\n                if (total > 0) {\n                    node.uBaryCenter = sum / total;\n                    node.upstreamLinkCount = total;\n                }\n                else {\n                    node.uBaryCenter = i;\n                    node.upstreamLinkCount = 0;\n                }\n            }\n        }\n        calcDownData(layer) {\n            if (layer === this.layers.length - 1) {\n                return;\n            }\n            const considered = this.layers[layer];\n            let i, l, link;\n            const downLayer = new Set();\n            const temp = this.layers[layer + 1];\n            for (i = 0; i < temp.length; i++) {\n                downLayer.add(temp[i]);\n            }\n            for (i = 0; i < considered.length; i++) {\n                const node = considered[i];\n                // calculate barycenter\n                let sum = 0;\n                let total = 0;\n                for (l = 0; l < node.incoming.length; l++) {\n                    link = node.incoming[l];\n                    if (downLayer.contains(link.source)) {\n                        total++;\n                        sum += link.source.gridPosition;\n                    }\n                }\n                for (l = 0; l < node.outgoing.length; l++) {\n                    link = node.outgoing[l];\n                    if (downLayer.contains(link.target)) {\n                        total++;\n                        sum += link.target.gridPosition;\n                    }\n                }\n                if (total > 0) {\n                    node.dBaryCenter = sum / total;\n                    node.downstreamLinkCount = total;\n                }\n                else {\n                    node.dBaryCenter = i;\n                    node.downstreamLinkCount = 0;\n                }\n            }\n        }\n        /// <summary>\n        /// Optimizes the crossings.\n        /// </summary>\n        /// <remarks>The big trick here is the usage of weights or values attached to connected nodes which turn a problem of crossing links\n        /// to an a problem of ordering numbers.</remarks>\n        /// <param name=\"layerIndex\">The layer index.</param>\n        /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n        /// <returns>The number of nodes having moved, i.e. the number of crossings reduced.</returns>\n        optimizeLayerCrossings(down, layer) {\n            let iconsidered;\n            let considered;\n            if (down) {\n                considered = this.layers[iconsidered = layer + 1];\n            }\n            else {\n                considered = this.layers[iconsidered = layer - 1];\n            }\n            // remember what it was\n            const presorted = considered.slice(0);\n            // calculate barycenters for all nodes in the considered layer\n            if (down) {\n                this.calcUpData(iconsidered);\n            }\n            else {\n                this.calcDownData(iconsidered);\n            }\n            // sort nodes within this layer according to the barycenters\n            considered.sort((n1, n2) => {\n                const n1BaryCenter = this.calcBaryCenter(n1), n2BaryCenter = this.calcBaryCenter(n2);\n                if (Math.abs(n1BaryCenter - n2BaryCenter) < 0.0001) {\n                    // in case of coinciding barycenters compare by the count of in/out links\n                    if (n1.degree() === n2.degree()) {\n                        return this.compareByIndex(n1, n2);\n                    }\n                    else if (n1.degree() < n2.degree()) {\n                        return 1;\n                    }\n                    return -1;\n                }\n                const compareValue = (n2BaryCenter - n1BaryCenter) * 1000;\n                if (compareValue > 0) {\n                    return -1;\n                }\n                else if (compareValue < 0) {\n                    return 1;\n                }\n                return this.compareByIndex(n1, n2);\n            });\n            // count relocations\n            let i, moves = 0;\n            for (i = 0; i < considered.length; i++) {\n                if (considered[i] !== presorted[i]) {\n                    moves++;\n                }\n            }\n            if (moves > 0) {\n                // now that the boxes have been arranged, update their grid positions\n                let inode = 0;\n                for (i = 0; i < considered.length; i++) {\n                    const node = considered[i];\n                    node.gridPosition = inode++;\n                }\n            }\n            return moves;\n        }\n        /// <summary>\n        /// Swaps a pair of nodes in a layer.\n        /// </summary>\n        /// <param name=\"layerIndex\">Index of the layer.</param>\n        /// <param name=\"n\">The Nth node in the layer.</param>\n        _swapPairs() {\n            const maxIterations = this.options.layeredIterations;\n            let iter = 0;\n            while (true) {\n                if (iter++ > maxIterations) {\n                    break;\n                }\n                const downwards = (iter % 4 <= 1);\n                const secondPass = (iter % 4 === 1);\n                for (let l = (downwards ? 0 : this.layers.length - 1); downwards ? l <= this.layers.length - 1 : l >= 0; l += (downwards ? 1 : -1)) {\n                    const layer = this.layers[l];\n                    let hasSwapped = false;\n                    // there is no need to recalculate crossings if they were calculated\n                    // on the previous step and nothing has changed\n                    let calcCrossings = true;\n                    let memCrossings = 0;\n                    for (let n = 0; n < layer.length - 1; n++) {\n                        // count crossings\n                        let up = 0;\n                        let down = 0;\n                        let crossBefore = 0;\n                        if (calcCrossings) {\n                            if (l !== 0) {\n                                up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                            }\n                            if (l !== this.layers.length - 1) {\n                                down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                            }\n                            if (downwards) {\n                                up *= 2;\n                            }\n                            else {\n                                down *= 2;\n                            }\n                            crossBefore = up + down;\n                        }\n                        else {\n                            crossBefore = memCrossings;\n                        }\n                        if (crossBefore === 0) {\n                            continue;\n                        }\n                        // Swap nodes\n                        let node1 = layer[n];\n                        let node2 = layer[n + 1];\n                        let node1GridPos = node1.gridPosition;\n                        let node2GridPos = node2.gridPosition;\n                        layer[n] = node2;\n                        layer[n + 1] = node1;\n                        node1.gridPosition = node2GridPos;\n                        node2.gridPosition = node1GridPos;\n                        // count crossings again and if worse than before, restore swapping\n                        up = 0;\n                        if (l !== 0) {\n                            up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                        }\n                        down = 0;\n                        if (l !== this.layers.length - 1) {\n                            down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                        }\n                        if (downwards) {\n                            up *= 2;\n                        }\n                        else {\n                            down *= 2;\n                        }\n                        const crossAfter = up + down;\n                        let revert = false;\n                        if (secondPass) {\n                            revert = crossAfter >= crossBefore;\n                        }\n                        else {\n                            revert = crossAfter > crossBefore;\n                        }\n                        if (revert) {\n                            node1 = layer[n];\n                            node2 = layer[n + 1];\n                            node1GridPos = node1.gridPosition;\n                            node2GridPos = node2.gridPosition;\n                            layer[n] = node2;\n                            layer[n + 1] = node1;\n                            node1.gridPosition = node2GridPos;\n                            node2.gridPosition = node1GridPos;\n                            // nothing has changed, remember the crossings so that\n                            // they are not calculated again on the next step\n                            memCrossings = crossBefore;\n                            calcCrossings = false;\n                        }\n                        else {\n                            hasSwapped = true;\n                            calcCrossings = true;\n                        }\n                    }\n                    if (hasSwapped) {\n                        if (l !== this.layers.length - 1) {\n                            this.calcUpData(l + 1);\n                        }\n                        if (l !== 0) {\n                            this.calcDownData(l - 1);\n                        }\n                    }\n                }\n            }\n        }\n        /// <summary>\n        /// Counts the number of links crossing between two layers.\n        /// </summary>\n        /// <param name=\"layerIndex1\">The layer index.</param>\n        /// <param name=\"layerIndex2\">Another layer index.</param>\n        /// <returns></returns>\n        countLinksCrossingBetweenTwoLayers(ulayer, dlayer) {\n            const links = this.layers[ulayer].linksTo[dlayer];\n            let link1, link2, n11, n12, n21, n22, l1, l2;\n            let crossings = 0;\n            const length = links.length;\n            for (l1 = 0; l1 < length; l1++) {\n                link1 = links[l1];\n                for (l2 = l1 + 1; l2 < length; l2++) {\n                    link2 = links[l2];\n                    if (link1.target.layer === dlayer) {\n                        n11 = link1.source;\n                        n12 = link1.target;\n                    }\n                    else {\n                        n11 = link1.target;\n                        n12 = link1.source;\n                    }\n                    if (link2.target.layer === dlayer) {\n                        n21 = link2.source;\n                        n22 = link2.target;\n                    }\n                    else {\n                        n21 = link2.target;\n                        n22 = link2.source;\n                    }\n                    const n11gp = n11.gridPosition;\n                    const n12gp = n12.gridPosition;\n                    const n21gp = n21.gridPosition;\n                    const n22gp = n22.gridPosition;\n                    if ((n11gp - n21gp) * (n12gp - n22gp) < 0) {\n                        crossings++;\n                    }\n                }\n            }\n            return crossings;\n        }\n        calcBaryCenter(node) {\n            const upstreamLinkCount = node.upstreamLinkCount;\n            const downstreamLinkCount = node.downstreamLinkCount;\n            const uBaryCenter = node.uBaryCenter;\n            const dBaryCenter = node.dBaryCenter;\n            if (upstreamLinkCount > 0 && downstreamLinkCount > 0) {\n                return (uBaryCenter + dBaryCenter) / 2;\n            }\n            if (upstreamLinkCount > 0) {\n                return uBaryCenter;\n            }\n            if (downstreamLinkCount > 0) {\n                return dBaryCenter;\n            }\n            return 0;\n        }\n        _gridPositionComparer(x, y) {\n            if (x.gridPosition < y.gridPosition) {\n                return -1;\n            }\n            if (x.gridPosition > y.gridPosition) {\n                return 1;\n            }\n            return 0;\n        }\n        _positionAscendingComparer(x, y) {\n            return x.k < y.k ? -1 : x.k > y.k ? 1 : 0;\n        }\n        _positionDescendingComparer(x, y) {\n            return x.k < y.k ? 1 : x.k > y.k ? -1 : 0;\n        }\n        _firstVirtualNode(layer) {\n            for (let c = 0; c < layer.length; c++) {\n                if (layer[c].isVirtual) {\n                    return c;\n                }\n            }\n            return -1;\n        }\n        compareByIndex(o1, o2) {\n            const i1 = o1.index;\n            const i2 = o2.index;\n            if (i1 < i2) {\n                return 1;\n            }\n            if (i1 > i2) {\n                return -1;\n            }\n            return 0;\n        }\n        intDiv(numerator, denominator) {\n            return (numerator - numerator % denominator) / denominator;\n        }\n        nextVirtualNode(layer, node) {\n            const nodeIndex = node.layerIndex;\n            for (let i = nodeIndex + 1; i < layer.length; ++i) {\n                if (layer[i].isVirtual) {\n                    return layer[i];\n                }\n            }\n            return null;\n        }\n    }\n\n    class TreeLayoutProcessor {\n        constructor(options) {\n            this.center = null;\n            this.options = options;\n        }\n        layout(treeGraph, root) {\n            this.graph = treeGraph;\n            if (!this.graph.nodes || this.graph.nodes.length === 0) {\n                return;\n            }\n            if (!contains(this.graph.nodes, root)) {\n                throw new Error('The given root is not in the graph.');\n            }\n            this.center = root;\n            this.graph.cacheRelationships();\n            /* var nonull = this.graph.nodes.where(function (n) {\n             return n.associatedShape != null;\n             });*/\n            // transfer the rects\n            /* nonull.forEach(function (n) {\n             n.Location = n.associatedShape.Position;\n             n.NodeSize = n.associatedShape.ActualBounds.ToSize();\n             }\n\n             );*/\n            // caching the children\n            /* nonull.forEach(function (n) {\n             n.children = n.getChildren();\n             });*/\n            this.layoutSwitch();\n            // apply the layout to the actual visuals\n            // nonull.ForEach(n => n.associatedShape.Position = n.Location);\n        }\n        layoutLeft(left) {\n            this.setChildrenDirection(this.center, 'Left', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            let h = 0, w = 0, y, i, node;\n            for (i = 0; i < left.length; i++) {\n                node = left[i];\n                node.TreeDirection = 'Left';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w = Math.max(w, s.width);\n                h += s.height + this.options.verticalSeparation;\n            }\n            h -= this.options.verticalSeparation;\n            const x = this.center.x - this.options.horizontalSeparation;\n            y = this.center.y + ((this.center.height - h) / 2);\n            for (i = 0; i < left.length; i++) {\n                node = left[i];\n                const p = new Point(x - node.Size.width, y);\n                this.arrange(node, p);\n                y += node.Size.height + this.options.verticalSeparation;\n            }\n        }\n        layoutRight(right) {\n            this.setChildrenDirection(this.center, 'Right', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            let h = 0, w = 0, y, i, node;\n            for (i = 0; i < right.length; i++) {\n                node = right[i];\n                node.TreeDirection = 'Right';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w = Math.max(w, s.width);\n                h += s.height + this.options.verticalSeparation;\n            }\n            h -= this.options.verticalSeparation;\n            const x = this.center.x + this.options.horizontalSeparation + this.center.width;\n            y = this.center.y + ((this.center.height - h) / 2);\n            for (i = 0; i < right.length; i++) {\n                node = right[i];\n                const p = new Point(x, y);\n                this.arrange(node, p);\n                y += node.Size.height + this.options.verticalSeparation;\n            }\n        }\n        layoutUp(up) {\n            this.setChildrenDirection(this.center, 'Up', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            let w = 0, y, node, i;\n            for (i = 0; i < up.length; i++) {\n                node = up[i];\n                node.TreeDirection = 'Up';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w += s.width + this.options.horizontalSeparation;\n            }\n            w -= this.options.horizontalSeparation;\n            let x = this.center.x + (this.center.width / 2) - (w / 2);\n            // y = this.center.y -verticalSeparation -this.center.height/2 - h;\n            for (i = 0; i < up.length; i++) {\n                node = up[i];\n                y = this.center.y - this.options.verticalSeparation - node.Size.height;\n                const p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n        }\n        layoutDown(down) {\n            let node, i;\n            this.setChildrenDirection(this.center, 'Down', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            let w = 0;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                node.treeDirection = 'Down';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w += s.width + this.options.horizontalSeparation;\n            }\n            w -= this.options.horizontalSeparation;\n            let x = this.center.x + (this.center.width / 2) - (w / 2);\n            const y = this.center.y + this.options.verticalSeparation + this.center.height;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                const p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n        }\n        layoutRadialTree() {\n            // var rmax = children.Aggregate(0D, (current, node) => Math.max(node.SectorAngle, current));\n            this.setChildrenDirection(this.center, 'Radial', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            this.previousRoot = null;\n            const startAngle = this.options.startRadialAngle * DEG_TO_RAD;\n            const endAngle = this.options.endRadialAngle * DEG_TO_RAD;\n            if (endAngle <= startAngle) {\n                throw new Error('Final angle should not be less than the start angle.');\n            }\n            this.maxDepth = 0;\n            this.origin = new Point(this.center.x, this.center.y);\n            this.calculateAngularWidth(this.center, 0);\n            // perform the layout\n            if (this.maxDepth > 0) {\n                this.radialLayout(this.center, this.options.radialFirstLevelSeparation, startAngle, endAngle);\n            }\n            // update properties of the root node\n            this.center.Angle = endAngle - startAngle;\n        }\n        tipOverTree(down, startFromLevel) {\n            if (isUndefined(startFromLevel)) {\n                startFromLevel = 0;\n            }\n            this.setChildrenDirection(this.center, 'Down', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            this.setChildrenLayout(this.center, 'Underneath', false, startFromLevel);\n            let w = 0, node, i;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                // if (node.IsSpecial) continue;\n                node.TreeDirection = 'Down';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w += s.width + this.options.horizontalSeparation;\n            }\n            w -= this.options.horizontalSeparation;\n            // putting the root in the center with respect to the whole diagram is not a nice result, let's put it with respect to the first level only\n            w -= down[down.length - 1].width;\n            w += down[down.length - 1].associatedShape.bounds().width;\n            let x = this.center.x + (this.center.width / 2) - (w / 2);\n            const y = this.center.y + this.options.verticalSeparation + this.center.height;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                // if (node.IsSpecial) continue;\n                const p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n            /*/ /let's place the special node, assuming there is only one\n             if (down.Count(n => n.IsSpecial) > 0)\n             {\n             var special = (from n in down where n.IsSpecial select n).First();\n             if (special.Children.Count > 0)\n             throw new DiagramException(\"The 'special' element should not have children.\");\n             special.Data.Location = new Point(Center.Data.Location.X + Center.AssociatedShape.BoundingRectangle.Width + this.options.HorizontalSeparation, Center.Data.Location.Y);\n             }*/\n        }\n        calculateAngularWidth(n, d) {\n            if (d > this.maxDepth) {\n                this.maxDepth = d;\n            }\n            const w = 1000, h = 1000, diameter = d === 0 ? 0 : Math.sqrt((w * w) + (h * h)) / d;\n            let aw = 0;\n            if (n.children.length > 0) {\n                // eventually with n.IsExpanded\n                for (let i = 0, len = n.children.length; i < len; i++) {\n                    const child = n.children[i];\n                    aw += this.calculateAngularWidth(child, d + 1);\n                }\n                aw = Math.max(diameter, aw);\n            }\n            else {\n                aw = diameter;\n            }\n            n.sectorAngle = aw;\n            return aw;\n        }\n        sortChildren(n) {\n            let basevalue = 0, i;\n            // update basevalue angle for node ordering\n            if (n.parents.length > 1) {\n                throw new Error('Node is not part of a tree.');\n            }\n            const p = n.parents[0];\n            if (p) {\n                const pl = new Point(p.x, p.y);\n                const nl = new Point(n.x, n.y);\n                basevalue = this.normalizeAngle(Math.atan2(pl.y - nl.y, pl.x - nl.x));\n            }\n            const count = n.children.length;\n            if (count === 0) {\n                return null;\n            }\n            const angle = [];\n            const idx = [];\n            for (i = 0; i < count; ++i) {\n                const c = n.children[i];\n                const l = new Point(c.x, c.y);\n                idx[i] = i;\n                angle[i] = this.normalizeAngle(-basevalue + Math.atan2(l.y - l.y, l.x - l.x));\n            }\n            bisort(angle, idx);\n            const col = []; // list of nodes\n            const children = n.children;\n            for (i = 0; i < count; ++i) {\n                col.push(children[idx[i]]);\n            }\n            return col;\n        }\n        normalizeAngle(angle) {\n            while (angle > Math.PI * 2) {\n                angle -= 2 * Math.PI;\n            }\n            while (angle < 0) {\n                angle += Math.PI * 2;\n            }\n            return angle;\n        }\n        radialLayout(node, radius, startAngle, endAngle) {\n            const deltaTheta = endAngle - startAngle;\n            const deltaThetaHalf = deltaTheta / 2.0;\n            const parentSector = node.sectorAngle;\n            let fraction = 0;\n            const sorted = this.sortChildren(node);\n            for (let i = 0, len = sorted.length; i < len; i++) {\n                const childNode = sorted[i];\n                const cp = childNode;\n                const childAngleFraction = cp.sectorAngle / parentSector;\n                if (childNode.children.length > 0) {\n                    this.radialLayout(childNode, radius + this.options.radialSeparation, startAngle + (fraction * deltaTheta), startAngle + ((fraction + childAngleFraction) * deltaTheta));\n                }\n                this.setPolarLocation(childNode, radius, startAngle + (fraction * deltaTheta) + (childAngleFraction * deltaThetaHalf));\n                cp.angle = childAngleFraction * deltaTheta;\n                fraction += childAngleFraction;\n            }\n        }\n        setPolarLocation(node, radius, angle) {\n            node.x = this.origin.x + (radius * Math.cos(angle));\n            node.y = this.origin.y + (radius * Math.sin(angle));\n            node.BoundingRectangle = new Rect(node.x, node.y, node.width, node.height);\n        }\n        /**\n         * Sets the children direction recursively.\n         *\n         * @param node\n         * @param direction\n         * @param includeStart\n         */\n        setChildrenDirection(node, direction, includeStart) {\n            const rootDirection = node.treeDirection;\n            this.graph.depthFirstTraversal(node, (n) => {\n                n.treeDirection = direction;\n            });\n            if (!includeStart) {\n                node.treeDirection = rootDirection;\n            }\n        }\n        /**\n         * Sets the children layout recursively.\n         *\n         * @param node\n         * @param layout\n         * @param includeStart\n         * @param startFromLevel\n         */\n        setChildrenLayout(node, layout, includeStart, startFromLevel) {\n            if (isUndefined(startFromLevel)) {\n                startFromLevel = 0;\n            }\n            const rootLayout = node.childrenLayout;\n            if (startFromLevel > 0) {\n                // assign levels to the Node.Level property\n                this.graph.assignLevels(node);\n                // assign the layout on the condition that the level is at least the 'startFromLevel'\n                this.graph.depthFirstTraversal(node, (s) => {\n                    if (s.level >= startFromLevel + 1) {\n                        s.childrenLayout = layout;\n                    }\n                });\n            }\n            else {\n                this.graph.depthFirstTraversal(node, (s) => {\n                    s.childrenLayout = layout;\n                });\n                // if the start should not be affected we put the state back\n                if (!includeStart) {\n                    node.childrenLayout = rootLayout;\n                }\n            }\n        }\n        /**\n         * Returns the actual size of the node. The given size is the allowed space wherein the node can lay out itself.\n         *\n         * @param node\n         * @param givenSize\n         * @returns {Size}\n         */\n        measure(node, givenSize) {\n            let w = 0, h = 0, s;\n            let result = new Size(0, 0);\n            if (!node) {\n                throw new Error('Node is not defined.');\n            }\n            const b = node.associatedShape.bounds();\n            const shapeWidth = b.width;\n            const shapeHeight = b.height;\n            if (node.parents.length !== 1) {\n                throw new Error('Node not in a spanning tree.');\n            }\n            const parent = node.parents[0];\n            if (node.treeDirection === 'Undefined') {\n                node.treeDirection = parent.treeDirection;\n            }\n            if (isEmpty(node.children)) {\n                result = new Size(Math.abs(shapeWidth) < EPSILON ? 50 : shapeWidth, Math.abs(shapeHeight) < EPSILON ? 25 : shapeHeight);\n            }\n            else if (node.children.length === 1) {\n                switch (node.treeDirection) {\n                    case 'Radial':\n                        s = this.measure(node.children[0], givenSize); // child size\n                        w = shapeWidth + (this.options.radialSeparation * Math.cos(node.AngleToParent)) + s.width;\n                        h = shapeHeight + Math.abs(this.options.radialSeparation * Math.sin(node.AngleToParent)) + s.height;\n                        break;\n                    case 'Left':\n                    case 'Right':\n                        switch (node.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                                break;\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                s = this.measure(node.children[0], givenSize);\n                                w = shapeWidth + s.width + this.options.underneathHorizontalOffset;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                                break;\n                            case 'Default':\n                                s = this.measure(node.children[0], givenSize);\n                                w = shapeWidth + this.options.horizontalSeparation + s.width;\n                                h = Math.max(shapeHeight, s.height);\n                                break;\n                            default:\n                                throw new Error('Unhandled TreeDirection in the Radial layout measuring.');\n                        }\n                        break;\n                    case 'Up':\n                    case 'Down':\n                        switch (node.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                s = this.measure(node.children[0], givenSize);\n                                w = Math.max(shapeWidth, s.width + this.options.underneathHorizontalOffset);\n                                h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                                break;\n                            case 'Default':\n                                s = this.measure(node.children[0], givenSize);\n                                h = shapeHeight + this.options.verticalSeparation + s.height;\n                                w = Math.max(shapeWidth, s.width);\n                                break;\n                            default:\n                                throw new Error('Unhandled TreeDirection in the Down layout measuring.');\n                        }\n                        break;\n                    default:\n                        throw new Error('Unhandled TreeDirection in the layout measuring.');\n                }\n                result = new Size(w, h);\n            }\n            else {\n                let i, childNode;\n                switch (node.treeDirection) {\n                    case 'Left':\n                    case 'Right':\n                        switch (node.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                w = shapeWidth;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                                    h += s.height + this.options.underneathVerticalSeparation;\n                                }\n                                h -= this.options.underneathVerticalSeparation;\n                                break;\n                            case 'Default':\n                                w = shapeWidth;\n                                h = 0;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, shapeWidth + this.options.horizontalSeparation + s.width);\n                                    h += s.height + this.options.verticalSeparation;\n                                }\n                                h -= this.options.verticalSeparation;\n                                break;\n                            default:\n                                throw new Error('Unhandled TreeDirection in the Right layout measuring.');\n                        }\n                        break;\n                    case 'Up':\n                    case 'Down':\n                        switch (node.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                w = shapeWidth;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                                    h += s.height + this.options.underneathVerticalSeparation;\n                                }\n                                h -= this.options.underneathVerticalSeparation;\n                                break;\n                            case 'Default':\n                                w = 0;\n                                h = 0;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w += s.width + this.options.horizontalSeparation;\n                                    h = Math.max(h, s.height + this.options.verticalSeparation + shapeHeight);\n                                }\n                                w -= this.options.horizontalSeparation;\n                                break;\n                            default:\n                                throw new Error('Unhandled TreeDirection in the Down layout measuring.');\n                        }\n                        break;\n                    default:\n                        throw new Error('Unhandled TreeDirection in the layout measuring.');\n                }\n                result = new Size(w, h);\n            }\n            node.SectorAngle = Math.sqrt((w * w / 4) + (h * h / 4));\n            node.Size = result;\n            return result;\n        }\n        arrange(n, p) {\n            const b = n.associatedShape.bounds();\n            let i, pp, child, node, childrenwidth;\n            const shapeWidth = b.width;\n            const shapeHeight = b.height;\n            if (isEmpty(n.children)) {\n                n.x = p.x;\n                n.y = p.y;\n                n.BoundingRectangle = new Rect(p.x, p.y, shapeWidth, shapeHeight);\n            }\n            else {\n                let x, y;\n                let selfLocation;\n                switch (n.treeDirection) {\n                    case 'Left':\n                        switch (n.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    node = node.children[i];\n                                    x = selfLocation.x - node.associatedShape.width - this.options.underneathHorizontalOffset;\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n                            case 'Default':\n                                selfLocation = new Point(p.x + n.Size.width - shapeWidth, p.y + ((n.Size.height - shapeHeight) / 2));\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = selfLocation.x - this.options.horizontalSeparation; // alignment of children\n                                y = p.y;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x - node.Size.width, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.verticalSeparation;\n                                }\n                                break;\n                            default:\n                                throw new Error('Unsupported TreeDirection');\n                        }\n                        break;\n                    case 'Right':\n                        switch (n.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + shapeWidth + this.options.underneathHorizontalOffset;\n                                // alignment of children left-underneath the parent\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n                            case 'Default':\n                                selfLocation = new Point(p.x, p.y + ((n.Size.height - shapeHeight) / 2));\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + shapeWidth + this.options.horizontalSeparation; // alignment of children\n                                y = p.y;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.verticalSeparation;\n                                }\n                                break;\n                            default:\n                                throw new Error('Unsupported TreeDirection');\n                        }\n                        break;\n                    case 'Up':\n                        selfLocation = new Point(p.x + ((n.Size.width - shapeWidth) / 2), p.y + n.Size.height - shapeHeight);\n                        n.x = selfLocation.x;\n                        n.y = selfLocation.y;\n                        n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                        if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                            childrenwidth = 0;\n                            // means there is an aberration due to the oversized Element with respect to the children\n                            for (i = 0; i < n.children.length; i++) {\n                                child = n.children[i];\n                                childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                            }\n                            childrenwidth -= this.options.horizontalSeparation;\n                            x = p.x + ((shapeWidth - childrenwidth) / 2);\n                        }\n                        else {\n                            x = p.x;\n                        }\n                        for (i = 0; i < n.children.length; i++) {\n                            node = n.children[i];\n                            y = selfLocation.y - this.options.verticalSeparation - node.Size.height;\n                            pp = new Point(x, y);\n                            this.arrange(node, pp);\n                            x += node.Size.width + this.options.horizontalSeparation;\n                        }\n                        break;\n                    case 'Down':\n                        switch (n.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + this.options.underneathHorizontalOffset; // alignment of children left-underneath the parent\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n                            case 'Default':\n                                selfLocation = new Point(p.x + ((n.Size.width - shapeWidth) / 2), p.y);\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                                    childrenwidth = 0;\n                                    // means there is an aberration due to the oversized Element with respect to the children\n                                    for (i = 0; i < n.children.length; i++) {\n                                        child = n.children[i];\n                                        childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                                    }\n                                    childrenwidth -= this.options.horizontalSeparation;\n                                    x = p.x + ((shapeWidth - childrenwidth) / 2);\n                                }\n                                else {\n                                    x = p.x;\n                                }\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    y = selfLocation.y + this.options.verticalSeparation + shapeHeight;\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    x += node.Size.width + this.options.horizontalSeparation;\n                                }\n                                break;\n                            default:\n                                throw new Error('Unsupported TreeDirection');\n                        }\n                        break;\n                    case 'None':\n                        break;\n                    default:\n                        throw new Error('Unsupported TreeDirection');\n                }\n            }\n        }\n        layoutSwitch() {\n            if (!this.center) {\n                return;\n            }\n            if (isEmpty(this.center.children)) {\n                return;\n            }\n            let type = this.options.subtype;\n            if (isUndefined(type)) {\n                type = 'Down';\n            }\n            let single, male, female, leftcount;\n            const children = this.center.children;\n            switch (type.toLowerCase()) {\n                case 'radial':\n                case 'radialtree':\n                    this.layoutRadialTree();\n                    break;\n                case 'mindmaphorizontal':\n                case 'mindmap':\n                    single = this.center.children;\n                    if (this.center.children.length === 1) {\n                        this.layoutRight(single);\n                    }\n                    else {\n                        // odd number will give one more at the right\n                        leftcount = children.length / 2;\n                        male = grep$1(this.center.children, function (n) {\n                            return indexOf(children, n) < leftcount;\n                        });\n                        female = grep$1(this.center.children, function (n) {\n                            return indexOf(children, n) >= leftcount;\n                        });\n                        this.layoutLeft(male);\n                        this.layoutRight(female);\n                    }\n                    break;\n                case 'mindmapvertical':\n                    single = this.center.children;\n                    if (this.center.children.length === 1) {\n                        this.layoutDown(single);\n                    }\n                    else {\n                        // odd number will give one more at the right\n                        leftcount = children.length / 2;\n                        male = grep$1(this.center.children, function (n) {\n                            return indexOf(children, n) < leftcount;\n                        });\n                        female = grep$1(this.center.children, function (n) {\n                            return indexOf(children, n) >= leftcount;\n                        });\n                        this.layoutUp(male);\n                        this.layoutDown(female);\n                    }\n                    break;\n                case 'right':\n                    this.layoutRight(this.center.children);\n                    break;\n                case 'left':\n                    this.layoutLeft(this.center.children);\n                    break;\n                case 'up':\n                case 'bottom':\n                    this.layoutUp(this.center.children);\n                    break;\n                case 'down':\n                case 'top':\n                    this.layoutDown(this.center.children);\n                    break;\n                case 'tipover':\n                case 'tipovertree':\n                    if (this.options.tipOverTreeStartLevel < 0) {\n                        throw new Error('The tip-over level should be a positive integer.');\n                    }\n                    this.tipOverTree(this.center.children, this.options.tipOverTreeStartLevel);\n                    break;\n                case 'undefined':\n                case 'none':\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n\n    /**\n     * The various tree layout algorithms.\n     *\n     * @type {*}\n     */\n    class TreeLayout extends LayoutBase {\n        constructor(diagram) {\n            super();\n            if (isUndefined(diagram)) {\n                throw new Error('No diagram specified.');\n            }\n            this.diagram = diagram;\n        }\n        /**\n         * Arranges the diagram in a tree-layout with the specified options and tree subtype.\n         */\n        layout(options) {\n            this.transferOptions(options);\n            // transform the diagram into a Graph\n            const adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            /**\n             * The Graph reduction from the given diagram.\n             *\n             * @type {*}\n             */\n            this.graph = adapter.convert();\n            const finalNodeSet = this.layoutComponents();\n            // note that the graph contains the original data and\n            // the components are another instance of nodes referring to the same set of shapes\n            return new LayoutState(this.diagram, finalNodeSet);\n        }\n        layoutComponents() {\n            if (this.graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            const components = this.graph.getConnectedComponents();\n            if (isEmpty(components)) {\n                return;\n            }\n            const layout = new TreeLayoutProcessor(this.options);\n            const trees = [];\n            // find a spanning tree for each component\n            for (let i = 0; i < components.length; i++) {\n                const component = components[i];\n                const treeGraph = this.getTree(component);\n                if (!treeGraph) {\n                    throw new Error('Failed to find a spanning tree for the component.');\n                }\n                const root = treeGraph.root;\n                const tree = treeGraph.tree;\n                layout.layout(tree, root);\n                trees.push(tree);\n            }\n            return this.gridLayoutComponents(trees);\n        }\n        /**\n         * Gets a spanning tree (and root) for the given graph.\n         * Ensure that the given graph is connected!\n         *\n         * @param graph\n         * @returns {*} A literal object consisting of the found root and the spanning tree.\n         */\n        getTree(graph) {\n            let root = null;\n            if (this.options.roots && this.options.roots.length > 0) {\n                for (let i = 0, len = graph.nodes.length; i < len; i++) {\n                    const node = graph.nodes[i];\n                    for (let j = 0; j < this.options.roots.length; j++) {\n                        const givenRootShape = this.options.roots[j];\n                        if (givenRootShape === node.associatedShape) {\n                            root = node;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!root) {\n                // finds the most probable root on the basis of the longest path in the component\n                root = graph.root();\n                // should not happen really\n                if (!root) {\n                    throw new Error('Unable to find a root for the tree.');\n                }\n            }\n            return this.getTreeForRoot(graph, root);\n        }\n        getTreeForRoot(graph, root) {\n            const tree = graph.getSpanningTree(root);\n            if (isUndefined(tree) || tree.isEmpty()) {\n                return null;\n            }\n            return {\n                tree: tree,\n                root: tree.root()\n            };\n        }\n    }\n\n    class AdornerBase {\n        constructor(diagram, options) {\n            this.diagram = diagram;\n            this.options = deepExtend({}, this.options, options);\n            this.visual = new Group();\n            this.diagram._adorners.push(this);\n        }\n        refresh() { }\n    }\n\n    class ConnectionEditUndoUnit {\n        constructor(item, undoSource, undoTarget) {\n            this.item = item;\n            this._undoSource = undoSource;\n            this._undoTarget = undoTarget;\n            this._redoSource = item.source();\n            this._redoTarget = item.target();\n            this.title = ConnectionEditing;\n        }\n        undo() {\n            this.item._updateConnector(this._undoSource, SOURCE);\n            this.item._updateConnector(this._undoTarget, TARGET);\n            this.item.updateModel();\n        }\n        redo() {\n            this.item._updateConnector(this._redoSource, SOURCE);\n            this.item._updateConnector(this._redoTarget, TARGET);\n            this.item.updateModel();\n        }\n    }\n\n    function mwDelta(e) {\n        let delta = 0;\n        if (e.wheelDelta) {\n            delta = -e.wheelDelta / 40;\n            delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n        }\n        else if (e.detail) {\n            delta = e.detail;\n        }\n        return delta;\n    }\n    function isAutoConnector(connector) {\n        return connector.options.name.toLowerCase() === AUTO.toLowerCase();\n    }\n    function closestConnector(point, connectors) {\n        let minimumDistance = MAXINT, resCtr, connector;\n        for (let i = 0; i < connectors.length; i++) {\n            connector = connectors[i];\n            if (!isAutoConnector(connector)) {\n                const dist = point.distanceTo(connector.position());\n                if (dist < minimumDistance) {\n                    minimumDistance = dist;\n                    resCtr = connector;\n                }\n            }\n        }\n        return resCtr;\n    }\n    function indicesOfItems(group, visuals) {\n        const indices = [];\n        let i, visual;\n        const children = group.drawingContainer().children;\n        const length = children.length;\n        for (i = 0; i < visuals.length; i++) {\n            visual = visuals[i];\n            for (let j = 0; j < length; j++) {\n                if (children[j] === visual.drawingContainer()) {\n                    indices.push(j);\n                    break;\n                }\n            }\n        }\n        return indices;\n    }\n    function translateToOrigin(visual) {\n        const bbox = visual.drawingContainer().clippedBBox(null);\n        if (bbox.origin.x !== 0 || bbox.origin.y !== 0) {\n            visual.position(-bbox.origin.x, -bbox.origin.y);\n        }\n    }\n    function filterShapeDataItem(dataItem) {\n        const result = {};\n        dataItem = dataItem || {};\n        if (defined(dataItem.text) && dataItem.text !== null) {\n            result.text = dataItem.text;\n        }\n        if (defined(dataItem.x) && dataItem.x !== null) {\n            result.x = dataItem.x;\n        }\n        if (defined(dataItem.y) && dataItem.y !== null) {\n            result.y = dataItem.y;\n        }\n        if (defined(dataItem.width) && dataItem.width !== null) {\n            result.width = dataItem.width;\n        }\n        if (defined(dataItem.height) && dataItem.height !== null) {\n            result.height = dataItem.height;\n        }\n        if (defined(dataItem.type) && dataItem.type !== null) {\n            result.type = dataItem.type;\n        }\n        return result;\n    }\n    function filterConnectionDataItem(dataItem) {\n        const result = {};\n        dataItem = dataItem || {};\n        if (defined(dataItem.text) && dataItem.text !== null) {\n            result.content = dataItem.text;\n        }\n        if (defined(dataItem.type) && dataItem.type !== null) {\n            result.type = dataItem.type;\n        }\n        if (defined(dataItem.from) && dataItem.from !== null) {\n            result.from = dataItem.from;\n        }\n        if (defined(dataItem.fromConnector) && dataItem.fromConnector !== null) {\n            result.fromConnector = dataItem.fromConnector;\n        }\n        if (defined(dataItem.fromX) && dataItem.fromX !== null) {\n            result.fromX = dataItem.fromX;\n        }\n        if (defined(dataItem.fromY) && dataItem.fromY !== null) {\n            result.fromY = dataItem.fromY;\n        }\n        if (defined(dataItem.to) && dataItem.to !== null) {\n            result.to = dataItem.to;\n        }\n        if (defined(dataItem.toConnector) && dataItem.toConnector !== null) {\n            result.toConnector = dataItem.toConnector;\n        }\n        if (defined(dataItem.toX) && dataItem.toX !== null) {\n            result.toX = dataItem.toX;\n        }\n        if (defined(dataItem.toY) && dataItem.toY !== null) {\n            result.toY = dataItem.toY;\n        }\n        return result;\n    }\n    var FlowchartShapeType;\n    (function (FlowchartShapeType) {\n        FlowchartShapeType[\"Terminator\"] = \"Terminator\";\n        FlowchartShapeType[\"Process\"] = \"Process\";\n        FlowchartShapeType[\"Decision\"] = \"Decision\";\n        FlowchartShapeType[\"PredefinedProcess\"] = \"PredefinedProcess\";\n        FlowchartShapeType[\"Document\"] = \"Document\";\n        FlowchartShapeType[\"MultipleDocuments\"] = \"MultipleDocuments\";\n        FlowchartShapeType[\"ManualInputOutput\"] = \"ManualInputOutput\";\n        FlowchartShapeType[\"Preparation\"] = \"Preparation\";\n        FlowchartShapeType[\"ManualOperation\"] = \"ManualOperation\";\n        FlowchartShapeType[\"InternalStorage\"] = \"InternalStorage\";\n        FlowchartShapeType[\"Display\"] = \"Display\";\n        FlowchartShapeType[\"DirectAccessStorage\"] = \"DirectAccessStorage\";\n        FlowchartShapeType[\"Database\"] = \"Database\";\n        FlowchartShapeType[\"OnPageConnector\"] = \"OnPageConnector\";\n        FlowchartShapeType[\"OffPageConnector\"] = \"OffPageConnector\";\n        FlowchartShapeType[\"DataInputOutput\"] = \"DataInputOutput\";\n        FlowchartShapeType[\"SummingJunction\"] = \"SummingJunction\";\n        FlowchartShapeType[\"LogicalOr\"] = \"LogicalOr\";\n        FlowchartShapeType[\"Merge\"] = \"Merge\";\n        FlowchartShapeType[\"Extract\"] = \"Extract\";\n        FlowchartShapeType[\"DataStorage\"] = \"DataStorage\";\n        FlowchartShapeType[\"Delay\"] = \"Delay\";\n        FlowchartShapeType[\"Sort\"] = \"Sort\";\n        FlowchartShapeType[\"Collate\"] = \"Collate\";\n    })(FlowchartShapeType || (FlowchartShapeType = {}));\n    const documentConnectors = [\n        { name: \"top\" },\n        {\n            name: \"bottom\",\n            position: function (shape) {\n                const height = shape.bounds().height;\n                const amplitude = height * shape.shapeVisual.options.waveRatio;\n                const position = shape.getPosition('top');\n                position.y += height - (amplitude * 0.4);\n                return position;\n            }\n        },\n        { name: \"left\" },\n        { name: \"right\" },\n        { name: \"auto\" }\n    ];\n    const triangleConnectors = [\n        { name: \"top\" },\n        { name: \"bottom\" },\n        {\n            name: \"left\",\n            position: function (shape) {\n                const position = shape.getPosition('left');\n                const bounds = shape.bounds();\n                position.x += (bounds.width / 4) - shape.shapeVisual.options.cornerRadius * 0.6 * (bounds.width / bounds.height);\n                return position;\n            }\n        },\n        {\n            name: \"right\",\n            position: function (shape) {\n                const position = shape.getPosition('right');\n                const bounds = shape.bounds();\n                position.x -= bounds.width / 4 - shape.shapeVisual.options.cornerRadius * 0.6 * (bounds.width / bounds.height);\n                return position;\n            }\n        },\n        { name: \"auto\" }\n    ];\n    const connectors = {\n        [FlowchartShapeType.Extract]: triangleConnectors,\n        [FlowchartShapeType.Merge]: triangleConnectors,\n        [FlowchartShapeType.Document]: documentConnectors,\n        [FlowchartShapeType.MultipleDocuments]: documentConnectors,\n        [FlowchartShapeType.DataInputOutput]: [\n            { name: \"top\" },\n            { name: \"bottom\" },\n            {\n                name: \"left\",\n                position: function (shape) {\n                    const position = shape.getPosition('left');\n                    position.x += (shape.bounds().width * shape.shapeVisual.options.slantRatio / 2) - shape.shapeVisual.options.cornerRadius / 5;\n                    return position;\n                }\n            },\n            {\n                name: \"right\",\n                position: function (shape) {\n                    const position = shape.getPosition('right');\n                    position.x -= (shape.bounds().width * shape.shapeVisual.options.slantRatio / 2) - shape.shapeVisual.options.cornerRadius / 5;\n                    return position;\n                }\n            },\n            { name: \"auto\" }\n        ],\n        [FlowchartShapeType.ManualOperation]: [\n            { name: \"top\" },\n            { name: \"bottom\" },\n            {\n                name: \"left\",\n                position: function (shape) {\n                    const position = shape.getPosition('left');\n                    position.x += (shape.bounds().width * shape.shapeVisual.options.baseShrinkRatio / (4 + shape.shapeVisual.options.cornerRadius / 10));\n                    return position;\n                }\n            },\n            {\n                name: \"right\",\n                position: function (shape) {\n                    const position = shape.getPosition('right');\n                    position.x -= (shape.bounds().width * shape.shapeVisual.options.baseShrinkRatio / (4 + shape.shapeVisual.options.cornerRadius / 10));\n                    return position;\n                }\n            },\n            { name: \"auto\" }\n        ],\n        [FlowchartShapeType.ManualInputOutput]: [\n            {\n                name: \"top\",\n                position: function (shape) {\n                    const position = shape.getPosition('top');\n                    position.y += shape.bounds().height * shape.shapeVisual.options.topSlantRatio / 2;\n                    return position;\n                }\n            },\n            { name: \"bottom\" },\n            { name: \"left\" },\n            { name: \"right\" },\n            { name: \"auto\" }\n        ],\n        [FlowchartShapeType.DataStorage]: [\n            { name: \"top\" },\n            { name: \"bottom\" },\n            { name: \"left\" },\n            {\n                name: \"right\",\n                position: function (shape) {\n                    const width = shape.bounds().width;\n                    const position = shape.getPosition('right');\n                    position.x -= width * shape.shapeVisual.options.ellipseRadiusXRatio;\n                    return position;\n                }\n            },\n            { name: \"auto\" }\n        ]\n    };\n\n    class RotateUnit {\n        constructor(adorner, shapes, undoRotates) {\n            this.shapes = shapes;\n            this.undoRotates = undoRotates;\n            this.title = 'Rotation';\n            this.redoRotates = [];\n            this.redoAngle = adorner._angle;\n            this.adorner = adorner;\n            this.center = adorner._innerBounds.center();\n            for (let i = 0; i < this.shapes.length; i++) {\n                this.redoRotates.push(this.redoAngle);\n            }\n        }\n        undo() {\n            let i, shape;\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                shape.rotate(this.undoRotates[i], this.center, false);\n                if ('layout' in shape) {\n                    shape.layout(shape);\n                }\n                shape.updateModel();\n            }\n            if (this.adorner) {\n                this.adorner._initialize();\n                this.adorner.refresh();\n            }\n        }\n        redo() {\n            let i, shape;\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                shape.rotate(this.redoRotates[i], this.center, false);\n                if ('layout' in shape) {\n                    shape.layout(shape);\n                }\n                shape.updateModel();\n            }\n            if (this.adorner) {\n                this.adorner._initialize();\n                this.adorner.refresh();\n            }\n        }\n    }\n\n    const defaultOptions$5 = {\n        width: 7,\n        height: 7,\n        fill: {\n            color: DEFAULT_CONNECTION_BACKGROUND\n        },\n        hover: {}\n    };\n    class Connector {\n        /**\n         * Creates a new Connector instance.\n         * @param shape The shape that owns this connector\n         * @param options Configuration options for the connector\n         */\n        constructor(shape, options) {\n            this.options = deepExtend({}, defaultOptions$5, options);\n            this.connections = [];\n            this.shape = shape;\n        }\n        /**\n         * Gets the position of this connector.\n         * Uses either a custom position function from options or the shape's getPosition method.\n         * @returns The Point representing the connector's position\n         */\n        position() {\n            if (this.options.position) {\n                return this.options.position(this.shape);\n            }\n            else {\n                return this.shape.getPosition(this.options.name);\n            }\n        }\n        /**\n         * Converts the connector to a JSON representation for serialization.\n         * @returns Object containing the shape ID and connector name\n         */\n        toJSON() {\n            return {\n                shapeId: this.shape.toString(),\n                connector: this.options.name\n            };\n        }\n        /**\n         * Parses a string representation to find and return a connector from the diagram.\n         * @param diagram The diagram to search for the connector\n         * @param str String representation in format \"shapeId:connectorName\"\n         * @returns The matching Connector or undefined if not found\n         */\n        static parse(diagram, str) {\n            const tempStr = str.split(':'), id = tempStr[0], name = tempStr[1] || AUTO;\n            for (let i = 0; i < diagram.shapes.length; i++) {\n                const shape = diagram.shapes[i];\n                if (shape.options.id === id) {\n                    return shape.getConnector(name.trim());\n                }\n            }\n        }\n        ;\n    }\n\n    const DefaultConnectors = [{\n            name: TOP\n        }, {\n            name: BOTTOM\n        }, {\n            name: LEFT\n        }, {\n            name: RIGHT\n        }, {\n            name: AUTO,\n            position: function (shape) {\n                return shape.getPosition('center');\n            }\n        }];\n    const shapeDefaults = function (extra) {\n        const defaults = {\n            type: DEFAULT_SHAPE_TYPE,\n            path: '',\n            autoSize: true,\n            visual: null,\n            x: DEFAULT_SHAPE_POSITION,\n            y: DEFAULT_SHAPE_POSITION,\n            minWidth: DEFAULT_SHAPE_MINWIDTH,\n            minHeight: DEFAULT_SHAPE_MINHEIGHT,\n            width: DEFAULT_SHAPE_WIDTH,\n            height: DEFAULT_SHAPE_HEIGHT,\n            cornerRadius: 0,\n            hover: {},\n            editable: {\n                connect: true,\n                tools: []\n            },\n            connectors: DefaultConnectors,\n            rotation: {\n                angle: 0\n            }\n        };\n        simpleExtend(defaults, extra);\n        return defaults;\n    };\n\n    let current = {\n        compile: function (template, _options) {\n            return template;\n        }\n    };\n    class TemplateService {\n        static register(userImplementation) {\n            current = userImplementation;\n        }\n        static compile(template, options = {}) {\n            return current.compile(template, options);\n        }\n    }\n\n    function getTemplate(options = {}) {\n        let template;\n        if (options.visual) {\n            options.visual = template = TemplateService.compile(options.visual, options);\n        }\n        else if (options.template) {\n            options.template = template = TemplateService.compile(options.template, options);\n        }\n        else if (isFunction$1(options.content)) {\n            template = options.content;\n        }\n        return template;\n    }\n\n    function getSupportedFeatures() {\n        const os = detectOS(navigator.userAgent);\n        const support = {};\n        support.mobileOS = os;\n        return support;\n    }\n    function detectOS(ua) {\n        let os = false;\n        const agentRxs = {\n            wp: /(Windows Phone(?: OS)?)\\s(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            fire: /(Silk)\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            android: /(Android|Android.*(?:Opera|Firefox).*?\\/)\\s*(\\d+)\\.?(\\d+(\\.\\d+)?)?/,\n            iphone: /(iPhone|iPod).*OS\\s+(\\d+)[._]([\\d._]+)/,\n            ipad: /(iPad).*OS\\s+(\\d+)[._]([\\d_]+)/,\n            playbook: /(PlayBook).*?Tablet\\s*OS\\s*(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            windows: /(MSIE)\\s+(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            tizen: /(tizen).*?Version\\/(\\d+)\\.(\\d+(\\.\\d+)?)/i,\n            sailfish: /(sailfish).*rv:(\\d+)\\.(\\d+(\\.\\d+)?).*firefox/i\n        }, osRxs = {\n            ios: /^i(phone|pad|pod)$/i,\n            android: /^android|fire$/i,\n            windows: /windows/,\n            wp: /wp/,\n            flat: /sailfish|ffos|tizen/i\n        };\n        for (const agent in agentRxs) {\n            if (!Object.prototype.hasOwnProperty.call(agentRxs, agent)) {\n                continue;\n            }\n            const match = ua.match(agentRxs[agent]);\n            if (match) {\n                if (agent === 'windows' && 'plugins' in navigator) {\n                    return false;\n                } // Break if not Metro/Mobile Windows\n                os = {};\n                os.device = agent;\n                os.name = testRegex(agent, osRxs);\n                os[os.name] = true;\n                break;\n            }\n        }\n        return os;\n    }\n    function testRegex(agent, regexes, dflt) {\n        for (const regex in regexes) {\n            if (regexes[regex].test(agent)) {\n                return regex;\n            }\n        }\n        return dflt !== undefined ? dflt : agent;\n    }\n\n    const extend$1 = Object.assign;\n    const now = () => {\n        return new Date().getTime();\n    };\n    const addClass = (element, className) => {\n        element.classList.add(className);\n    };\n    const convertToHtml = (html) => {\n        const div = document.createElement('div');\n        div.innerHTML = html;\n        return div.firstChild;\n    };\n    const appendHtml = (html, element) => {\n        const div = document.createElement('div');\n        div.innerHTML = html;\n        // use childNodes instead of children\n        // to cover text nodes as well\n        while (div.childNodes.length > 0) {\n            element.appendChild(div.childNodes[0]);\n        }\n    };\n    const removeChildren = (element) => {\n        while (element.firstChild) {\n            element.removeChild(element.firstChild);\n        }\n    };\n    const prepend = (element, originElement) => {\n        originElement.insertBefore(element, originElement.firstChild);\n    };\n    const wrapInner = (parent, wrapper) => {\n        parent.appendChild(wrapper);\n        while (parent.firstChild !== wrapper) {\n            wrapper.appendChild(parent.firstChild);\n        }\n    };\n    const toHyphens = (str) => {\n        const result = str.replace(/([a-z][A-Z])/g, function (g) {\n            return g.charAt(0) + '-' + g.charAt(1).toLowerCase();\n        });\n        return result;\n    };\n    const toPixels = (value) => {\n        let result;\n        if (value && String(value).endsWith('px')) {\n            result = value;\n        }\n        else {\n            result = String(value) + 'px';\n        }\n        return result;\n    };\n    const hasNativeScrolling = () => {\n        const { mobileOS } = getSupportedFeatures();\n        return mobileOS.ios || mobileOS.android;\n    };\n    const wheelDeltaY = (e) => {\n        const deltaY = e.wheelDeltaY;\n        let delta;\n        if (e.wheelDelta) { // Webkit and IE\n            if (deltaY === undefined || deltaY) { // IE does not have deltaY, thus always scroll (horizontal scrolling is treated as vertical)\n                delta = e.wheelDelta;\n            }\n        }\n        else if (e.detail && e.axis === e.VERTICAL_AXIS) { // Firefox and Opera\n            delta = (-e.detail) * 10;\n        }\n        return delta;\n    };\n    const renderPos = (pos) => {\n        const result = [];\n        if (pos) {\n            const parts = toHyphens(pos).split('-');\n            for (let i = 0; i < parts.length; i++) {\n                result.push('k-pos-' + parts[i]);\n            }\n        }\n        return result.join(' ');\n    };\n\n    const defaultOptions$4 = {\n        hover: {},\n        cursor: Cursors.grip,\n        content: {\n            align: 'center middle'\n        },\n        selectable: true,\n        serializable: true,\n        enable: true\n    };\n    /** @hidden */\n    class DiagramElement extends Observable {\n        /**\n         * Creates a new DiagramElement instance.\n         * @param options Configuration options for the diagram element\n         */\n        constructor(options) {\n            super();\n            this.dataItem = (options || {}).dataItem;\n            this.options = deepExtend({ id: randomId() }, defaultOptions$4, options);\n            this.isSelected = false;\n            this.visual = new Group({\n                id: this.options.id,\n                autoSize: this.options.autoSize\n            });\n            this.id = this.options.id;\n            this._template();\n        }\n        /** @hidden */\n        _getCursor(point) {\n            if (this.adorner) {\n                return this.adorner._getCursor(point);\n            }\n            return this.options.cursor;\n        }\n        /**\n         * Gets or sets the visibility of the diagram element.\n         * @param value If provided, sets the visibility. If undefined, returns the current visibility.\n         * @returns The current visibility when used as a getter\n         */\n        visible(value) {\n            if (isUndefined(value)) {\n                return this.visual.visible();\n            }\n            else {\n                this.visual.visible(value);\n            }\n        }\n        /**\n         * Gets or sets the bounds of the diagram element.\n         * Base implementation returns null - should be overridden by subclasses.\n         * @param value The bounds to set. If not provided, returns the current bounds.\n         * @returns The bounds of the element or null\n         */\n        bounds(value) {\n            if (isUndefined(value)) {\n                return null;\n            }\n            return null;\n        }\n        /**\n         * Refreshes the visual representation of the diagram element.\n         * Triggers a redraw of the visual component.\n         */\n        refresh() {\n            this.visual.redraw();\n        }\n        /**\n         * Sets the position of the diagram element.\n         * @param point The new position point with x and y coordinates\n         */\n        position(point) {\n            this.options.x = point.x;\n            this.options.y = point.y;\n            this.visual.position(point);\n        }\n        /**\n         * Returns a string representation of the diagram element.\n         * @returns The ID of the element as a string\n         */\n        toString() {\n            return this.options.id;\n        }\n        /**\n         * Serializes the diagram element to a JSON object.\n         * @returns An object containing the element's options and data item information\n         */\n        serialize() {\n            // the options json object describes the shape perfectly. So this object can serve as shape serialization.\n            const json = deepExtend({}, { options: this.options });\n            if (this.dataItem) {\n                json.dataItem = this.dataItem.toString();\n            }\n            return json;\n        }\n        /** @hidden */\n        _content(content) {\n            if (content !== undefined) {\n                const options = this.options;\n                if (isString$1(content)) {\n                    options.content.text = content;\n                }\n                else {\n                    deepExtend(options.content, content);\n                }\n                const contentOptions = options.content;\n                const contentVisual = this._contentVisual;\n                if (!contentVisual) {\n                    this._createContentVisual(contentOptions);\n                }\n                else {\n                    this._updateContentVisual(contentOptions);\n                }\n            }\n            return this.options.content.text;\n        }\n        /** @hidden */\n        _createContentVisual(options) {\n            if (options.text) {\n                options.shapeSize = this.bounds();\n                const Type = options.textWrap !== 'wrap' ? TextBlock : MultiLineTextBlock;\n                this._contentVisual = new Type(options);\n                this._contentVisual._includeInBBox = false;\n                this.visual.append(this._contentVisual);\n            }\n        }\n        /** @hidden */\n        _updateContentVisual(options) {\n            this._contentVisual.redraw(options);\n        }\n        /** @hidden */\n        _hitTest(point) {\n            const bounds = this.bounds();\n            return this.visible() && bounds.contains(point) && this.options.enable;\n        }\n        /** @hidden */\n        _template() {\n            if (this.options.content.template) {\n                const data = this.dataItem || {};\n                const templateOptions = extend$1({}, this.options.content, {\n                    dataItem: this.dataItem || this.options.dataItem,\n                });\n                const elementTemplate = getTemplate(templateOptions);\n                if (isFunction$1(elementTemplate)) {\n                    this.options.content.text = elementTemplate(data);\n                }\n                else if (isString$1(elementTemplate)) {\n                    this.options.content.text = elementTemplate;\n                }\n            }\n        }\n        /** @hidden */\n        _canSelect() {\n            return this.options.selectable !== false;\n        }\n        /**\n         * Converts the diagram element to a JSON representation.\n         * @returns Object containing the element's ID\n         */\n        toJSON() {\n            return {\n                id: this.options.id\n            };\n        }\n    }\n\n    const shapes = {\n        Terminator: Terminator,\n        Process: Process,\n        Decision: Decision,\n        PredefinedProcess: PredefinedProcess,\n        Document: Document,\n        MultipleDocuments: MultipleDocuments,\n        ManualInputOutput: ManualInputOutput,\n        Preparation: Preparation,\n        ManualOperation: ManualOperation,\n        InternalStorage: InternalStorage,\n        Display: Display,\n        DirectAccessStorage: DirectAccessStorage,\n        Database: Database,\n        OnPageConnector: OnPageConnector,\n        OffPageConnector: OffPageConnector,\n        DataInputOutput: DataInputOutput,\n        SummingJunction: SummingJunction,\n        LogicalOr: LogicalOr,\n        Merge: Merge,\n        Extract: Extract,\n        DataStorage: DataStorage,\n        Delay: Delay,\n        Sort: Sort,\n        Collate: Collate\n    };\n    class Shape extends DiagramElement {\n        /**\n         * Creates a new Shape instance.\n         * @param options Configuration options for the shape\n         * @param diagram The diagram that will contain this shape\n         */\n        constructor(options, diagram) {\n            super(options);\n            /** @hidden */\n            this.name = 'Shape';\n            this.options = deepExtend({}, this.options, shapeDefaults({ connectors: undefined }), options);\n            this.diagram = diagram;\n            this.updateOptionsFromModel();\n            options = this.options;\n            this.connectors = [];\n            this.type = options.type;\n            this.createShapeVisual();\n            this.updateBounds();\n            this.content(this.content());\n            this._createConnectors();\n        }\n        /** @hidden */\n        _setOptionsFromModel(model) {\n            const modelOptions = filterShapeDataItem(model || this.dataItem);\n            this.options = deepExtend({}, this.options, modelOptions);\n            this.redrawVisual();\n        }\n        /**\n         * Updates the shape options from the model data.\n         * @param model The model data to extract options from\n         * @param field Specific field to update, if any\n         */\n        updateOptionsFromModel(model, field) {\n            if (this.diagram && this.diagram._isEditable) {\n                const modelOptions = filterShapeDataItem(model || this.dataItem);\n                if (model && field) {\n                    if (!contains(['x', 'y', 'width', 'height'], field)) {\n                        if (this.options.visual) {\n                            this._redrawVisual();\n                        }\n                        else if (modelOptions.type) {\n                            this.options = deepExtend({}, this.options, modelOptions);\n                            this._redrawVisual();\n                        }\n                        if (this.options.content) {\n                            this._template();\n                            this.content(this.options.content);\n                        }\n                    }\n                    else {\n                        const bounds = this.bounds();\n                        bounds[field] = model[field];\n                        this.bounds(bounds);\n                    }\n                }\n                else {\n                    this.options = deepExtend({}, this.options, modelOptions);\n                }\n            }\n        }\n        /** @hidden */\n        _redrawVisual() {\n            this.visual.clear();\n            this._contentVisual = null;\n            this.options.dataItem = this.dataItem;\n            this.createShapeVisual();\n            this.updateBounds();\n        }\n        /**\n         * Redraws the shape's visual representation.\n         * Updates both the visual and content if present.\n         */\n        redrawVisual() {\n            this._redrawVisual();\n            if (this.options.content) {\n                this._template();\n                this.content(this.options.content);\n            }\n        }\n        /**\n         * Updates the shape's model data and optionally synchronizes changes.\n         * @param syncChanges Whether to synchronize changes immediately\n         */\n        updateModel(syncChanges) {\n            const diagram = this.diagram;\n            if (diagram && diagram._isEditable) {\n                diagram.updateShapeModel(this, syncChanges);\n            }\n        }\n        /**\n         * Updates the shape's bounds based on its visual representation and handles rotation and content alignment.\n         */\n        updateBounds() {\n            const bounds = this.visual._measure(true);\n            const options = this.options;\n            this.bounds(new Rect(options.x, options.y, bounds.width, bounds.height));\n            this._rotate();\n            this._alignContent();\n        }\n        /**\n         * Gets or sets the content of the shape.\n         * @param content The content to set. If not provided, returns the current content.\n         * @returns The current content when used as a getter\n         */\n        content(content) {\n            const result = this._content(content);\n            this._alignContent();\n            return result;\n        }\n        /** @hidden */\n        _alignContent() {\n            const contentOptions = this.options.content || {};\n            const contentVisual = this._contentVisual;\n            if (contentVisual && contentOptions.align && contentVisual.alignable !== false) {\n                const containerRect = this.visual._measure();\n                const aligner = new RectAlign(containerRect);\n                const contentBounds = contentVisual.drawingElement.bbox(null);\n                const contentRect = new Rect(0, 0, contentBounds.width(), contentBounds.height());\n                const alignedBounds = aligner.align(contentRect, contentOptions.align);\n                contentVisual.position(alignedBounds.topLeft());\n            }\n        }\n        /** @hidden */\n        _createConnectors() {\n            const options = this.options, currentConnectors = options.connectors || connectors[options.type] || DefaultConnectors, length = currentConnectors.length, connectorDefaults = options.connectorDefaults;\n            let connector, i;\n            for (i = 0; i < length; i++) {\n                connector = new Connector(this, deepExtend({}, connectorDefaults, currentConnectors[i]));\n                this.connectors.push(connector);\n            }\n        }\n        /**\n         * Gets or sets the bounds of the shape.\n         * @param value The bounds to set, or a string constant for different bound types ('TRANSFORMED', 'ABSOLUTE', 'ROTATED'). If not provided, returns the current bounds.\n         * @returns The bounds of the shape\n         */\n        bounds(value) {\n            let bounds;\n            if (value) {\n                if (isString$1(value)) {\n                    switch (value) {\n                        case TRANSFORMED: {\n                            bounds = this._transformedBounds();\n                            break;\n                        }\n                        case ABSOLUTE: {\n                            bounds = this._transformedBounds();\n                            const pan = this.diagram._pan;\n                            bounds.x += pan.x;\n                            bounds.y += pan.y;\n                            break;\n                        }\n                        case ROTATED: {\n                            bounds = this._rotatedBounds();\n                            break;\n                        }\n                        default: {\n                            bounds = this._bounds;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    this._setBounds(value);\n                    this._triggerBoundsChange();\n                    if (!(this.diagram && this.diagram._layouting)) {\n                        this.refreshConnections();\n                    }\n                }\n            }\n            else {\n                bounds = this._bounds;\n            }\n            return bounds;\n        }\n        /** @hidden */\n        _setBounds(rect) {\n            const options = this.options;\n            const topLeft = rect.topLeft();\n            const x = options.x = topLeft.x;\n            const y = options.y = topLeft.y;\n            const width = options.width = Math.max(rect.width, options.minWidth);\n            const height = options.height = Math.max(rect.height, options.minHeight);\n            this._bounds = new Rect(x, y, width, height);\n            this.visual.redraw({\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            });\n        }\n        /**\n         * Gets or sets the position of the shape.\n         * @param point The position to set. If not provided, returns the current position.\n         * @returns The current position when used as a getter\n         */\n        position(point) {\n            if (point) {\n                this.bounds(new Rect(point.x, point.y, this._bounds.width, this._bounds.height));\n            }\n            else {\n                return this._bounds.topLeft();\n            }\n        }\n        /**\n         * Returns a clone of this shape.\n         * @returns {Shape} A new Shape instance that is a copy of this shape\n         */\n        clone() {\n            const json = this.serialize();\n            json.options.id = randomId();\n            if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n                json.options.dataItem = this.diagram.options.cloneDataItem(this.dataItem);\n            }\n            return new Shape(json.options, undefined);\n        }\n        /**\n         * Selects or deselects the shape.\n         * @param value Whether to select (true) or deselect (false) the shape. If not provided, defaults to true.\n         * @returns True if the selection state changed, false otherwise\n         */\n        select(value) {\n            const diagram = this.diagram;\n            let selected, deselected;\n            if (isUndefined(value)) {\n                value = true;\n            }\n            if (this._canSelect()) {\n                if (this.isSelected !== value) {\n                    selected = [];\n                    deselected = [];\n                    this.isSelected = value;\n                    if (this.isSelected) {\n                        diagram._selectedItems.push(this);\n                        selected.push(this);\n                    }\n                    else {\n                        remove(diagram._selectedItems, this);\n                        deselected.push(this);\n                    }\n                    if (!diagram._internalSelection) {\n                        diagram._selectionChanged(selected, deselected);\n                    }\n                    return true;\n                }\n            }\n        }\n        /**\n         * Rotates the shape by the specified angle.\n         * @param angle The rotation angle in degrees. If not provided, returns the current rotation.\n         * @param center The center point for rotation. If not provided, uses the shape's center.\n         * @param undoable Whether the rotation should be undoable. Defaults to true.\n         * @returns The current rotation when used as a getter\n         */\n        rotate(angle, center, undoable) {\n            const rotate = this.visual.rotate();\n            if (angle !== undefined) {\n                if (undoable !== false && this.diagram && this.diagram.undoRedoService && angle !== rotate.angle) {\n                    this.diagram.undoRedoService.add(new RotateUnit(this.diagram._resizingAdorner, [this], [rotate.angle]), false);\n                }\n                const b = this.bounds(), sc = new Point(b.width / 2, b.height / 2);\n                let deltaAngle, newPosition;\n                if (center) {\n                    deltaAngle = angle - rotate.angle;\n                    newPosition = b.center().rotate(deltaAngle, center).minus(sc);\n                    this._rotationOffset = this._rotationOffset.plus(newPosition.minus(b.topLeft()));\n                    this.position(newPosition);\n                }\n                this.visual.rotate(angle, sc);\n                this.options.rotation.angle = angle;\n                if (this.diagram && this.diagram._connectorsAdorner) {\n                    this.diagram._connectorsAdorner.refresh();\n                }\n                this.refreshConnections();\n                if (this.diagram) {\n                    this.diagram.trigger(ITEMROTATE, { item: this });\n                }\n            }\n            return rotate;\n        }\n        /**\n         * Gets connections of this shape based on type.\n         * @param type The type of connections to retrieve: 'in' for incoming, 'out' for outgoing, or undefined for all connections.\n         * @returns Array of connections\n         */\n        connections(type) {\n            const result = [];\n            let i, j, con, cons, ctr;\n            for (i = 0; i < this.connectors.length; i++) {\n                ctr = this.connectors[i];\n                cons = ctr.connections;\n                for (j = 0, cons; j < cons.length; j++) {\n                    con = cons[j];\n                    if (type === 'out') {\n                        const source = con.source();\n                        if (source.shape && source.shape === this) {\n                            result.push(con);\n                        }\n                    }\n                    else if (type === 'in') {\n                        const target = con.target();\n                        if (target.shape && target.shape === this) {\n                            result.push(con);\n                        }\n                    }\n                    else {\n                        result.push(con);\n                    }\n                }\n            }\n            return result;\n        }\n        /**\n         * Refreshes all connections attached to this shape.\n         * Updates the visual representation of all connected connections.\n         */\n        refreshConnections() {\n            this.connections().forEach(function (connection) {\n                connection.refresh();\n            });\n        }\n        /**\n         * Gets a connector of this shape either by the connector's supposed name or\n         * via a Point in which case the closest connector will be returned.\n         *\n         * @param nameOrPoint The name of a Connector or a Point.\n         * @returns {Connector} The connector matching the name or closest to the point\n         */\n        getConnector(nameOrPoint) {\n            let i, ctr;\n            if (isString$1(nameOrPoint)) {\n                nameOrPoint = nameOrPoint.toLocaleLowerCase();\n                for (i = 0; i < this.connectors.length; i++) {\n                    ctr = this.connectors[i];\n                    if (ctr.options.name.toLocaleLowerCase() === nameOrPoint) {\n                        return ctr;\n                    }\n                }\n            }\n            else if (nameOrPoint instanceof Point) {\n                return closestConnector(nameOrPoint, this.connectors);\n            }\n            else {\n                return this.connectors.length ? this.connectors[0] : null;\n            }\n        }\n        /**\n         * Gets the position of the shape at a specific side.\n         * @param side The side to get position for (e.g., 'top', 'bottom', 'left', 'right', 'center')\n         * @returns The position point at the specified side\n         */\n        getPosition(side) {\n            const b = this.bounds(), fnName = side.charAt(0).toLowerCase() + side.slice(1);\n            if (isFunction$1(b[fnName])) {\n                return this._transformPoint(b[fnName]());\n            }\n            return b.center();\n        }\n        /**\n         * Redraws the shape with new options.\n         * @param options The options to apply when redrawing the shape\n         */\n        redraw(options) {\n            if (options) {\n                let shapeOptions = this.options;\n                let boundsChange;\n                this.shapeVisual.redraw(this._visualOptions(options));\n                if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n                    this.bounds(new Rect(shapeOptions.x, shapeOptions.y, shapeOptions.width, shapeOptions.height));\n                    boundsChange = true;\n                }\n                if (options.connectors) {\n                    shapeOptions.connectors = options.connectors;\n                    this._updateConnectors();\n                }\n                shapeOptions = deepExtend(shapeOptions, options);\n                if (options.rotation || boundsChange) {\n                    this._rotate();\n                }\n                if (shapeOptions.content) {\n                    this.content(shapeOptions.content);\n                }\n            }\n        }\n        /** @hidden */\n        _updateConnectors() {\n            const connections = this.connections();\n            this.connectors = [];\n            this._createConnectors();\n            let connection;\n            let source;\n            let target;\n            for (let idx = 0; idx < connections.length; idx++) {\n                connection = connections[idx];\n                source = connection.source();\n                target = connection.target();\n                if (source.shape && source.shape === this) {\n                    connection.source(this.getConnector(source.options.name) || null);\n                }\n                else if (target.shape && target.shape === this) {\n                    connection.target(this.getConnector(target.options.name) || null);\n                }\n                connection.updateModel();\n            }\n        }\n        /** @hidden */\n        _diffNumericOptions(options, fields) {\n            return diffNumericOptions.call(this, options, fields);\n        }\n        /** @hidden */\n        _visualOptions(options) {\n            return {\n                cornerRadius: options.cornerRadius,\n                data: options.path,\n                source: options.source,\n                hover: options.hover,\n                fill: options.fill,\n                stroke: options.stroke,\n                dataItem: this.dataItem || (options === null || options === void 0 ? void 0 : options.dataItem)\n            };\n        }\n        /** @hidden */\n        _triggerBoundsChange() {\n            if (this.diagram) {\n                this.diagram.trigger(ITEMBOUNDSCHANGE, { item: this, bounds: this._bounds.clone() }); // the trigger modifies the arguments internally.\n            }\n        }\n        /** @hidden */\n        _transformPoint(point) {\n            const rotate = this.rotate(), bounds = this.bounds(), tl = bounds.topLeft();\n            if (rotate.angle) {\n                point.rotate(rotate.angle, rotate.center().plus(tl));\n            }\n            return point;\n        }\n        /** @hidden */\n        _transformedBounds() {\n            const bounds = this.bounds(), tl = bounds.topLeft(), br = bounds.bottomRight();\n            return Rect.fromPoints(this.diagram.modelToView(tl), this.diagram.modelToView(br));\n        }\n        /** @hidden */\n        _rotatedBounds() {\n            const bounds = this.bounds().rotatedBounds(this.rotate().angle), tl = bounds.topLeft(), br = bounds.bottomRight();\n            return Rect.fromPoints(tl, br);\n        }\n        /** @hidden */\n        _rotate() {\n            const rotation = this.options.rotation;\n            if (rotation && rotation.angle) {\n                this.rotate(rotation.angle);\n            }\n            this._rotationOffset = new Point();\n        }\n        /** @hidden */\n        _hover(value) {\n            const options = this.options, hover = options.hover;\n            let stroke = options.stroke, fill = options.fill;\n            if (value && isDefined(hover.stroke)) {\n                stroke = deepExtend({}, stroke, hover.stroke);\n            }\n            if (value && isDefined(hover.fill)) {\n                fill = hover.fill;\n            }\n            this.shapeVisual.redraw({\n                stroke: stroke,\n                fill: fill\n            });\n            if (options.editable && options.editable.connect) {\n                this.diagram._showConnectors(this, value);\n            }\n        }\n        /** @hidden */\n        _hitTest(value) {\n            if (this.visible()) {\n                const bounds = this.bounds(), angle = this.rotate().angle;\n                let rotatedPoint;\n                if (value.isEmpty && !value.isEmpty()) { // rect selection\n                    return Intersect.rects(value, bounds, angle ? angle : 0);\n                }\n                else { // point\n                    rotatedPoint = value.clone().rotate(angle, bounds.center()); // cloning is important because rotate modifies the point inline.\n                    if (bounds.contains(rotatedPoint)) {\n                        return this;\n                    }\n                }\n            }\n        }\n        /**\n         * Converts the shape to a JSON representation for serialization.\n         * @returns Object containing the shape's ID\n         */\n        toJSON() {\n            return {\n                shapeId: this.options.id\n            };\n        }\n        /**\n         * Creates the visual representation of the shape based on its type and options.\n         * Supports custom templates, predefined shapes (rectangle, circle, text, image), and custom paths.\n         */\n        createShapeVisual() {\n            const options = this.options;\n            const visualOptions = this._visualOptions(options);\n            const visualTemplate = options.visual ? TemplateService.compile(options.visual, options) : options.visual;\n            const type = (options.type + '').toLocaleLowerCase();\n            let shapeVisual;\n            visualOptions.width = options.width;\n            visualOptions.height = options.height;\n            if (isFunction$1(visualTemplate)) { // custom template\n                shapeVisual = visualTemplate.call(this, options);\n            }\n            else if (visualOptions.data) {\n                shapeVisual = new Path(visualOptions);\n                translateToOrigin(shapeVisual);\n            }\n            else if (type === 'rectangle') {\n                shapeVisual = new Rectangle(visualOptions);\n            }\n            else if (type === 'circle') {\n                shapeVisual = new Circle(visualOptions);\n            }\n            else if (type === 'text') {\n                shapeVisual = new TextBlock(visualOptions);\n            }\n            else if (type === 'image') {\n                shapeVisual = new Image(visualOptions);\n            }\n            else if (shapes[options.type]) {\n                shapeVisual = new shapes[options.type](visualOptions);\n            }\n            else {\n                shapeVisual = new Path(visualOptions);\n            }\n            this.shapeVisual = shapeVisual;\n            this.visual.append(this.shapeVisual);\n        }\n    }\n\n    class ConnectionEditAdorner extends AdornerBase {\n        constructor(connection, options) {\n            options = deepExtend({ handles: {} }, options);\n            super(connection.diagram, options);\n            this.connection = connection;\n            const diagram = this.connection.diagram;\n            this._ts = diagram.toolService;\n            const sp = this.connection.sourcePoint();\n            const tp = this.connection.targetPoint();\n            this.spVisual = new Circle(deepExtend(this.options.handles, { center: sp }));\n            this.epVisual = new Circle(deepExtend(this.options.handles, { center: tp }));\n            this.visual.append(this.spVisual);\n            this.visual.append(this.epVisual);\n        }\n        _getCursor() {\n            return Cursors.move;\n        }\n        start(p) {\n            this.handle = this._hitTest(p);\n            this.startPoint = p;\n            this._initialSource = this.connection.source();\n            this._initialTarget = this.connection.target();\n            switch (this.handle) {\n                case -1:\n                    if (this.connection.targetConnector) {\n                        this._ts._connectionManipulation(this.connection, this.connection.targetConnector.shape);\n                    }\n                    break;\n                case 1:\n                    if (this.connection.sourceConnector) {\n                        this._ts._connectionManipulation(this.connection, this.connection.sourceConnector.shape);\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        move(handle, p) {\n            switch (handle) {\n                case -1:\n                    this.connection.source(p);\n                    break;\n                case 1:\n                    this.connection.target(p);\n                    break;\n                default: {\n                    const delta = p.minus(this.startPoint);\n                    this.startPoint = p;\n                    if (!this.connection.sourceConnector) {\n                        this.connection.source(this.connection.sourcePoint().plus(delta));\n                    }\n                    if (!this.connection.targetConnector) {\n                        this.connection.target(this.connection.targetPoint().plus(delta));\n                    }\n                    break;\n                }\n            }\n            this.refresh();\n            return true;\n        }\n        stop(p) {\n            const ts = this.diagram.toolService, item = ts.hoveredItem;\n            let target;\n            if (ts._hoveredConnector) {\n                target = ts._hoveredConnector._c;\n            }\n            else if (item && item instanceof Shape) {\n                target = item.getConnector(AUTO) || item.getConnector(p);\n            }\n            else {\n                target = p;\n            }\n            if (this.handle === -1) {\n                this.connection.source(target);\n            }\n            else if (this.handle === 1) {\n                this.connection.target(target);\n            }\n            this.handle = undefined;\n            this._ts._connectionManipulation();\n            return new ConnectionEditUndoUnit(this.connection, this._initialSource, this._initialTarget);\n        }\n        _hitTest(point) {\n            const sourcePoint = this.connection.sourcePoint();\n            const targetPoint = this.connection.targetPoint();\n            const radiusX = this.options.handles.width / 2 + HIT_TEST_DISTANCE;\n            const radiusY = this.options.handles.height / 2 + HIT_TEST_DISTANCE;\n            const sourcePointDistance = sourcePoint.distanceTo(point);\n            const targetPointDistance = targetPoint.distanceTo(point);\n            const sourceHandle = new Rect(sourcePoint.x, sourcePoint.y).inflate(radiusX, radiusY).contains(point);\n            const targetHandle = new Rect(targetPoint.x, targetPoint.y).inflate(radiusX, radiusY).contains(point);\n            let handle = 0;\n            if (sourceHandle && (!targetHandle || sourcePointDistance < targetPointDistance)) {\n                handle = -1;\n            }\n            else if (targetHandle && (!sourceHandle || targetPointDistance < sourcePointDistance)) {\n                handle = 1;\n            }\n            return handle;\n        }\n        refresh() {\n            this.spVisual.redraw({ center: this.diagram.modelToLayer(this.connection.sourcePoint()) });\n            this.epVisual.redraw({ center: this.diagram.modelToLayer(this.connection.targetPoint()) });\n        }\n    }\n\n    class ConnectorVisual {\n        constructor(connector) {\n            this.options = deepExtend({}, connector.options);\n            this._c = connector;\n            this.visual = new Circle(this.options);\n            this.refresh();\n        }\n        _hover(value) {\n            const options = this.options, hover = options.hover;\n            let stroke = options.stroke, fill = options.fill;\n            if (value && isDefined(hover.stroke)) {\n                stroke = deepExtend({}, stroke, hover.stroke);\n            }\n            if (value && isDefined(hover.fill)) {\n                fill = hover.fill;\n            }\n            this.visual.redraw({\n                stroke: stroke,\n                fill: fill\n            });\n        }\n        refresh() {\n            const p = this._c.shape.diagram.modelToView(this._c.position()), relative = p.minus(this._c.shape.bounds('transformed').topLeft()), value = new Rect(p.x, p.y, 0, 0);\n            value.inflate(this.options.width / 2, this.options.height / 2);\n            this._visualBounds = value;\n            this.visual.redraw({ center: new Point(relative.x, relative.y) });\n        }\n        _hitTest(p) {\n            const tp = this._c.shape.diagram.modelToView(p);\n            return this._visualBounds.contains(tp);\n        }\n    }\n\n    class ConnectorsAdorner extends AdornerBase {\n        constructor(diagram, options) {\n            super(diagram, options);\n            this._refreshHandler = (e) => {\n                if (e.item === this.shape) {\n                    this.refresh();\n                }\n            };\n        }\n        show(shape) {\n            this._visible = true;\n            this.shape = shape;\n            this.diagram.bind(ITEMBOUNDSCHANGE, this._refreshHandler);\n            this.connectors = [];\n            this._clearVisual();\n            const len = shape.connectors.length;\n            for (let i = 0; i < len; i++) {\n                const ctr = new ConnectorVisual(shape.connectors[i]);\n                this.connectors.push(ctr);\n                this.visual.append(ctr.visual);\n            }\n            this.visual.visible(true);\n            this.refresh();\n        }\n        _clearVisual() {\n            if (this.diagram._cachedTouchTarget) {\n                this._keepCachedTouchTarget();\n            }\n            else {\n                this.visual.clear();\n            }\n        }\n        _keepCachedTouchTarget() {\n            const visualChildren = this.visual.children;\n            const childrenCount = visualChildren.length;\n            const index = inArray(this.diagram._cachedTouchTarget, visualChildren);\n            for (let i = childrenCount - 1; i >= 0; i--) {\n                if (i === index) {\n                    continue;\n                }\n                this.visual.remove(visualChildren[i]);\n            }\n        }\n        destroy() {\n            this.diagram.unbind(ITEMBOUNDSCHANGE, this._refreshHandler);\n            this.shape = undefined;\n            this._visible = undefined;\n            this.visual.visible(false);\n        }\n        _hitTest(p) {\n            let ctr, i;\n            for (i = 0; i < this.connectors.length; i++) {\n                ctr = this.connectors[i];\n                if (ctr._hitTest(p)) {\n                    ctr._hover(true);\n                    this.diagram.toolService._hoveredConnector = ctr;\n                    break;\n                }\n            }\n        }\n        refresh() {\n            if (this.shape) {\n                let bounds = this.shape.bounds();\n                bounds = this.diagram.modelToLayer(bounds);\n                this.visual.position(bounds.topLeft());\n                this.connectors.forEach(function (ctr) {\n                    ctr.refresh();\n                });\n            }\n        }\n    }\n\n    function canDrag(element) {\n        const editable = element.options.editable;\n        return editable && editable.drag !== false;\n    }\n\n    /**\n     * Holds the undoredo state when performing a rotation, translation or scaling. The adorner is optional.\n     *\n     * @type {*}\n     */\n    class TransformUnit {\n        constructor(shapes, undoStates, adorner) {\n            this.shapes = shapes;\n            this.undoStates = undoStates;\n            this.title = 'Transformation';\n            this.redoStates = [];\n            this.adorner = adorner;\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                this.redoStates.push(shape.bounds());\n            }\n        }\n        undo() {\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                shape.bounds(this.undoStates[i]);\n                if ('layout' in shape) {\n                    shape.layout(shape, this.redoStates[i], this.undoStates[i]);\n                }\n                shape.updateModel();\n            }\n            if (this.adorner) {\n                this.adorner.refreshBounds();\n                this.adorner.refresh();\n            }\n        }\n        redo() {\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                shape.bounds(this.redoStates[i]);\n                // the 'layout' property, if implemented, lets the shape itself work out what to do with the new bounds\n                if ('layout' in shape) {\n                    shape.layout(shape, this.undoStates[i], this.redoStates[i]);\n                }\n                shape.updateModel();\n            }\n            if (this.adorner) {\n                this.adorner.refreshBounds();\n                this.adorner.refresh();\n            }\n        }\n    }\n\n    function hitToOppositeSide(hit, bounds) {\n        let result;\n        if (hit.x === -1 && hit.y === -1) {\n            result = bounds.bottomRight();\n        }\n        else if (hit.x === 1 && hit.y === 1) {\n            result = bounds.topLeft();\n        }\n        else if (hit.x === -1 && hit.y === 1) {\n            result = bounds.topRight();\n        }\n        else if (hit.x === 1 && hit.y === -1) {\n            result = bounds.bottomLeft();\n        }\n        else if (hit.x === 0 && hit.y === -1) {\n            result = bounds.bottom();\n        }\n        else if (hit.x === 0 && hit.y === 1) {\n            result = bounds.top();\n        }\n        else if (hit.x === 1 && hit.y === 0) {\n            result = bounds.left();\n        }\n        else if (hit.x === -1 && hit.y === 0) {\n            result = bounds.right();\n        }\n        return result;\n    }\n    const defaultOptions$3 = {\n        handles: {\n            fill: {\n                color: '#fff'\n            },\n            stroke: {\n                color: '#282828'\n            },\n            height: 7,\n            width: 7,\n            hover: {\n                fill: {\n                    color: '#282828'\n                },\n                stroke: {\n                    color: '#282828'\n                }\n            }\n        },\n        selectable: {\n            stroke: {\n                color: '#778899',\n                width: 1,\n                dashType: 'dash'\n            },\n            fill: {\n                color: TRANSPARENT\n            }\n        },\n        offset: 10\n    };\n    class ResizingAdorner extends AdornerBase {\n        constructor(diagram, options) {\n            options = deepExtend({}, defaultOptions$3, options);\n            super(diagram, options);\n            this._manipulating = false;\n            this.map = [];\n            this.shapes = [];\n            this.shapeStates = [];\n            this._initSelection();\n            this._createHandles();\n            this.redraw();\n            this.diagram.bind('select', () => {\n                this._initialize();\n            });\n            this._refreshHandler = () => {\n                if (!this._internalChange) {\n                    this.refreshBounds();\n                    this.refresh();\n                }\n            };\n            this._rotatedHandler = () => {\n                if (this.shapes.length === 1) {\n                    this._angle = this.shapes[0].rotate().angle;\n                }\n                this._refreshHandler();\n            };\n            this.diagram.bind(ITEMBOUNDSCHANGE, this._refreshHandler).bind(ITEMROTATE, this._rotatedHandler);\n            this.refreshBounds();\n            this.refresh();\n        }\n        _initSelection() {\n            const diagram = this.diagram;\n            const selectable = diagram.options.selectable;\n            const options = deepExtend({}, this.options.selectable, selectable);\n            this.rect = new Rectangle(options);\n            this.visual.append(this.rect);\n        }\n        _resizable() {\n            return this.options.editable && this.options.editable.resize !== false;\n        }\n        _handleOptions() {\n            return (this.options.editable.resize || {}).handles || this.options.handles;\n        }\n        _createHandles() {\n            let handles, item, y, x;\n            if (this._resizable()) {\n                handles = this._handleOptions();\n                for (x = -1; x <= 1; x++) {\n                    for (y = -1; y <= 1; y++) {\n                        if ((x !== 0) || (y !== 0)) { // (0, 0) element, (-1, -1) top-left, (+1, +1) bottom-right\n                            item = new Rectangle(handles);\n                            item.drawingElement._hover = this._hover.bind(this);\n                            this.map.push({ x: x, y: y, visual: item });\n                            this.visual.append(item);\n                        }\n                    }\n                }\n            }\n        }\n        bounds(value) {\n            if (value) {\n                this._innerBounds = value.clone();\n                this._bounds = this.diagram.modelToLayer(value).inflate(this.options.offset, this.options.offset);\n            }\n            else {\n                return this._bounds;\n            }\n        }\n        _hitTest(p) {\n            const handlesCount = this.map.length;\n            let tp = this.diagram.modelToLayer(p), i, hit, handleBounds, handle;\n            if (this._angle) {\n                tp = tp.clone().rotate(this._angle, this._bounds.center());\n            }\n            if (this._resizable()) {\n                for (i = 0; i < handlesCount; i++) {\n                    handle = this.map[i];\n                    hit = new Point(handle.x, handle.y);\n                    handleBounds = this._getHandleBounds(hit); // local coordinates\n                    handleBounds.offset(this._bounds.x, this._bounds.y);\n                    if (handleBounds.contains(tp)) {\n                        return hit;\n                    }\n                }\n            }\n            if (this._bounds.contains(tp)) {\n                return new Point(0, 0);\n            }\n        }\n        _getHandleBounds(p) {\n            if (this._resizable()) {\n                const handles = this._handleOptions(), w = handles.width, h = handles.height, r = new Rect(0, 0, w, h);\n                if (p.x < 0) {\n                    r.x = -w / 2;\n                }\n                else if (p.x === 0) {\n                    r.x = Math.floor(this._bounds.width / 2) - w / 2;\n                }\n                else if (p.x > 0) {\n                    r.x = this._bounds.width + 1.0 - w / 2;\n                }\n                if (p.y < 0) {\n                    r.y = -h / 2;\n                }\n                else if (p.y === 0) {\n                    r.y = Math.floor(this._bounds.height / 2) - h / 2;\n                }\n                else if (p.y > 0) {\n                    r.y = this._bounds.height + 1.0 - h / 2;\n                }\n                return r;\n            }\n        }\n        _getCursor(point) {\n            let hit = this._hitTest(point);\n            if (hit && (hit.x >= -1) && (hit.x <= 1) && (hit.y >= -1) && (hit.y <= 1) && this._resizable()) {\n                const angle = this._angle;\n                if (angle) {\n                    hit.rotate(angle, new Point(0, 0));\n                    hit = new Point(Math.round(hit.x), Math.round(hit.y));\n                }\n                if (hit.x === -1 && hit.y === -1) {\n                    return 'nw-resize';\n                }\n                if (hit.x === 1 && hit.y === 1) {\n                    return 'se-resize';\n                }\n                if (hit.x === -1 && hit.y === 1) {\n                    return 'sw-resize';\n                }\n                if (hit.x === 1 && hit.y === -1) {\n                    return 'ne-resize';\n                }\n                if (hit.x === 0 && hit.y === -1) {\n                    return 'n-resize';\n                }\n                if (hit.x === 0 && hit.y === 1) {\n                    return 's-resize';\n                }\n                if (hit.x === 1 && hit.y === 0) {\n                    return 'e-resize';\n                }\n                if (hit.x === -1 && hit.y === 0) {\n                    return 'w-resize';\n                }\n            }\n            return this._manipulating ? Cursors.move : Cursors.select;\n        }\n        _initialize() {\n            let i, item;\n            const items = this.diagram.select();\n            this.shapes = [];\n            for (i = 0; i < items.length; i++) {\n                item = items[i];\n                if (item instanceof Shape) {\n                    this.shapes.push(item);\n                    item._rotationOffset = new Point();\n                }\n            }\n            this._angle = this.shapes.length === 1 ? this.shapes[0].rotate().angle : 0;\n            this._startAngle = this._angle;\n            this._rotates();\n            this._positions();\n            this.refreshBounds();\n            this.refresh();\n            this.redraw();\n        }\n        _rotates() {\n            let i, shape;\n            this.initialRotates = [];\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                this.initialRotates.push(shape.rotate().angle);\n            }\n        }\n        _positions() {\n            let i, shape;\n            this.initialStates = [];\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                this.initialStates.push(shape.bounds());\n            }\n        }\n        _hover(value, element) {\n            if (this._resizable()) {\n                const handleOptions = this._handleOptions(), hover = handleOptions.hover;\n                let stroke = handleOptions.stroke, fill = handleOptions.fill;\n                if (value && isDefined(hover.stroke)) {\n                    stroke = deepExtend({}, stroke, hover.stroke);\n                }\n                if (value && isDefined(hover.fill)) {\n                    fill = hover.fill;\n                }\n                element.stroke(stroke.color, stroke.width, stroke.opacity);\n                element.fill(fill.color, fill.opacity);\n            }\n        }\n        start(p) {\n            this._sp = p;\n            this._cp = p;\n            this._lp = p;\n            this._manipulating = true;\n            this._internalChange = true;\n            this.shapeStates = [];\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                this.shapeStates.push(shape.bounds());\n            }\n        }\n        redraw() {\n            let i, handle;\n            const visibleHandles = this._resizable();\n            for (i = 0; i < this.map.length; i++) {\n                handle = this.map[i];\n                handle.visual.visible(visibleHandles);\n            }\n        }\n        angle(value) {\n            if (defined(value)) {\n                this._angle = value;\n            }\n            return this._angle;\n        }\n        rotate() {\n            const center = this._innerBounds.center();\n            let currentAngle = this.angle();\n            this._internalChange = true;\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                currentAngle = (currentAngle + this.initialRotates[i] - this._startAngle) % 360;\n                shape.rotate(currentAngle, center);\n            }\n            this.refresh();\n        }\n        move(handle, p) {\n            let delta, dragging, dtl = new Point(), dbr = new Point(), bounds, center, shape, i, angle, newBounds, changed = 0, staticPoint, scaleX, scaleY;\n            if (handle.y === -2 && handle.x === -1) {\n                center = this._innerBounds.center();\n                this._angle = this._truncateAngle(findAngle(center, p));\n                for (i = 0; i < this.shapes.length; i++) {\n                    shape = this.shapes[i];\n                    angle = (this._angle + this.initialRotates[i] - this._startAngle) % 360;\n                    shape.rotate(angle, center);\n                    if (Object.prototype.hasOwnProperty.call(shape, 'layout')) {\n                        shape.layout(shape);\n                    }\n                    this._rotating = true;\n                }\n                this.refresh();\n            }\n            else {\n                if (this.shouldSnap()) {\n                    const thr = this._truncateDistance(p.minus(this._lp));\n                    // threshold\n                    if (thr.x === 0 && thr.y === 0) {\n                        this._cp = p;\n                        return;\n                    }\n                    delta = thr;\n                    this._lp = new Point(this._lp.x + thr.x, this._lp.y + thr.y);\n                }\n                else {\n                    delta = p.minus(this._cp);\n                }\n                if (this.isDragHandle(handle)) {\n                    dbr = dtl = delta; // dragging\n                    dragging = true;\n                }\n                else {\n                    if (this._angle) { // adjust the delta so this resizers resize in the correct direction after rotation.\n                        delta.rotate(this._angle, new Point(0, 0));\n                    }\n                    if (handle.x === -1) {\n                        dtl.x = delta.x;\n                    }\n                    else if (handle.x === 1) {\n                        dbr.x = delta.x;\n                    }\n                    if (handle.y === -1) {\n                        dtl.y = delta.y;\n                    }\n                    else if (handle.y === 1) {\n                        dbr.y = delta.y;\n                    }\n                }\n                if (!dragging) {\n                    staticPoint = hitToOppositeSide(handle, this._innerBounds);\n                    scaleX = (this._innerBounds.width + delta.x * handle.x) / this._innerBounds.width;\n                    scaleY = (this._innerBounds.height + delta.y * handle.y) / this._innerBounds.height;\n                }\n                for (i = 0; i < this.shapes.length; i++) {\n                    shape = this.shapes[i];\n                    bounds = shape.bounds();\n                    if (dragging) {\n                        if (!canDrag(shape)) {\n                            continue;\n                        }\n                        newBounds = this._displaceBounds(bounds, dtl, dbr, dragging);\n                    }\n                    else {\n                        newBounds = bounds.clone();\n                        newBounds.scale(scaleX, scaleY, staticPoint, this._innerBounds.center(), shape.rotate().angle);\n                        const newCenter = newBounds.center(); // fixes the new rotation center.\n                        newCenter.rotate(-this._angle, bounds.center());\n                        newBounds = new Rect(newCenter.x - newBounds.width / 2, newCenter.y - newBounds.height / 2, newBounds.width, newBounds.height);\n                    }\n                    if (newBounds.width >= shape.options.minWidth && newBounds.height >= shape.options.minHeight) { // if we up-size very small shape\n                        const oldBounds = bounds;\n                        shape.bounds(newBounds);\n                        if (Object.prototype.hasOwnProperty.call(shape, 'layout')) {\n                            shape.layout(shape, oldBounds, newBounds);\n                        }\n                        if (oldBounds.width !== newBounds.width || oldBounds.height !== newBounds.height) {\n                            shape.rotate(shape.rotate().angle); // forces the rotation to update it's rotation center\n                        }\n                        changed += 1;\n                    }\n                }\n                if (changed) {\n                    if (changed === i) {\n                        newBounds = this._displaceBounds(this._innerBounds, dtl, dbr, dragging);\n                        this.bounds(newBounds);\n                    }\n                    else {\n                        this.refreshBounds();\n                    }\n                    this.refresh();\n                }\n                this._positions();\n            }\n            this._cp = p;\n        }\n        isDragHandle(handle) {\n            return handle.x === 0 && handle.y === 0;\n        }\n        cancel() {\n            const shapes = this.shapes;\n            const states = this.shapeStates;\n            for (let idx = 0; idx < shapes.length; idx++) {\n                shapes[idx].bounds(states[idx]);\n            }\n            this.refreshBounds();\n            this.refresh();\n            this._manipulating = undefined;\n            this._internalChange = undefined;\n            this._rotating = undefined;\n        }\n        _truncatePositionToGuides(bounds) {\n            if (this.diagram.ruler) {\n                return this.diagram.ruler.truncatePositionToGuides(bounds);\n            }\n            return bounds;\n        }\n        _truncateSizeToGuides(bounds) {\n            if (this.diagram.ruler) {\n                return this.diagram.ruler.truncateSizeToGuides(bounds);\n            }\n            return bounds;\n        }\n        _truncateAngle(a) {\n            const snap = this.snapOptions();\n            const snapAngle = Math.max(snap.angle || DEFAULT_SNAP_ANGLE, MIN_SNAP_ANGLE);\n            return snap ? Math.floor((a % 360) / snapAngle) * snapAngle : (a % 360);\n        }\n        _truncateDistance(d) {\n            if (d instanceof Point) {\n                return new Point(this._truncateDistance(d.x), this._truncateDistance(d.y));\n            }\n            else {\n                const snap = this.snapOptions() || {};\n                const snapSize = Math.max(snap.size || DEFAULT_SNAP_SIZE, MIN_SNAP_SIZE);\n                return snap ? Math.floor(d / snapSize) * snapSize : d;\n            }\n        }\n        snapOptions() {\n            const editable = this.diagram.options.editable;\n            const snap = ((editable || {}).drag || {}).snap || {};\n            return snap;\n        }\n        shouldSnap() {\n            const editable = this.diagram.options.editable;\n            const drag = (editable || {}).drag;\n            const snap = (drag || {}).snap;\n            return editable !== false && drag !== false && snap !== false;\n        }\n        _displaceBounds(bounds, dtl, dbr, dragging) {\n            const tl = bounds.topLeft().plus(dtl), br = bounds.bottomRight().plus(dbr);\n            let newBounds = Rect.fromPoints(tl, br), newCenter;\n            if (!dragging) {\n                newCenter = newBounds.center();\n                newCenter.rotate(-this._angle, bounds.center());\n                newBounds = new Rect(newCenter.x - newBounds.width / 2, newCenter.y - newBounds.height / 2, newBounds.width, newBounds.height);\n            }\n            return newBounds;\n        }\n        stop() {\n            let unit, i, shape;\n            if (this._cp !== this._sp) {\n                if (this._rotating) {\n                    unit = new RotateUnit(this, this.shapes, this.initialRotates);\n                    this._rotating = false;\n                }\n                else if (this._diffStates()) {\n                    if (this.diagram.ruler) {\n                        for (i = 0; i < this.shapes.length; i++) {\n                            shape = this.shapes[i];\n                            let bounds = shape.bounds();\n                            bounds = this._truncateSizeToGuides(this._truncatePositionToGuides(bounds));\n                            shape.bounds(bounds);\n                            this.refreshBounds();\n                            this.refresh();\n                        }\n                    }\n                    for (i = 0; i < this.shapes.length; i++) {\n                        shape = this.shapes[i];\n                        shape.updateModel();\n                    }\n                    unit = new TransformUnit(this.shapes, this.shapeStates, this);\n                    this.diagram._syncShapeChanges();\n                }\n            }\n            this._manipulating = undefined;\n            this._internalChange = undefined;\n            this._rotating = undefined;\n            return unit;\n        }\n        _diffStates() {\n            const shapes = this.shapes;\n            const states = this.shapeStates;\n            for (let idx = 0; idx < shapes.length; idx++) {\n                if (!shapes[idx].bounds().equals(states[idx])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        refreshBounds() {\n            const bounds = this.shapes.length === 1 ?\n                this.shapes[0].bounds().clone() :\n                this.diagram.boundingBox(this.shapes, true);\n            this.bounds(bounds);\n        }\n        refresh() {\n            let b, bounds;\n            if (this.shapes.length > 0) {\n                bounds = this.bounds();\n                this.visual.visible(true);\n                this.visual.position(bounds.topLeft());\n                this.map.forEach((m) => {\n                    b = this._getHandleBounds(new Point(m.x, m.y));\n                    m.visual.position(b.topLeft());\n                });\n                this.visual.position(bounds.topLeft());\n                const center = new Point(bounds.width / 2, bounds.height / 2);\n                this.visual.rotate(this._angle, center);\n                this.rect.redraw({ width: bounds.width, height: bounds.height });\n                if (this.rotationThumb) {\n                    const thumb = this.options.editable.rotate.thumb;\n                    this._rotationThumbBounds = new Rect(bounds.center().x, bounds.y + thumb.y, 0, 0).inflate(thumb.width);\n                    this.rotationThumb.redraw({ x: bounds.width / 2 - thumb.width / 2 });\n                }\n            }\n            else {\n                this.visual.visible(false);\n            }\n        }\n    }\n\n    const defaultOptions$2 = {\n        stroke: {\n            color: '#778899',\n            width: 1,\n            dashType: 'dash'\n        },\n        fill: {\n            color: TRANSPARENT\n        }\n    };\n    class Selector {\n        constructor(diagram) {\n            const selectable = diagram.options.selectable;\n            this.options = deepExtend({}, defaultOptions$2, selectable);\n            this.visual = new Rectangle(this.options);\n            this.diagram = diagram;\n        }\n        start(p) {\n            this._sp = this._ep = p;\n            this.refresh();\n            this.diagram._adorn(this, true);\n        }\n        end() {\n            this._sp = this._ep = undefined;\n            this.diagram._adorn(this, false);\n        }\n        bounds(value) {\n            if (value) {\n                this._bounds = value;\n            }\n            return this._bounds;\n        }\n        move(p) {\n            this._ep = p;\n            this.refresh();\n        }\n        refresh() {\n            if (this._sp) {\n                const visualBounds = Rect.fromPoints(this.diagram.modelToLayer(this._sp), this.diagram.modelToLayer(this._ep));\n                this.bounds(Rect.fromPoints(this._sp, this._ep));\n                this.visual.position(visualBounds.topLeft());\n                this.visual.redraw({ height: visualBounds.height + 1, width: visualBounds.width + 1 });\n            }\n        }\n    }\n\n    /**\n     * Base class for connection routers.\n     */\n    class ConnectionRouterBase {\n        constructor() { }\n    }\n\n    /**\n     * Base class for polyline and cascading routing.\n     */\n    class LinearConnectionRouter extends ConnectionRouterBase {\n        constructor(connection) {\n            super();\n            this.connection = connection;\n        }\n        /**\n         * Hit testing for polyline paths.\n         */\n        hitTest(p) {\n            const rec = this.getBounds().inflate(HIT_TEST_DISTANCE);\n            if (!rec.contains(p)) {\n                return false;\n            }\n            return Geometry.distanceToPolyline(p, this.connection.allPoints()) < HIT_TEST_DISTANCE;\n        }\n        /**\n         * Bounds of a polyline.\n         *\n         * @returns {kendo.dataviz.diagram.Rect}\n         */\n        getBounds() {\n            const points = this.connection.allPoints(), s = points[0], e = points[points.length - 1];\n            let right = Math.max(s.x, e.x), left = Math.min(s.x, e.x), top = Math.min(s.y, e.y), bottom = Math.max(s.y, e.y);\n            for (let i = 1; i < points.length - 1; ++i) {\n                right = Math.max(right, points[i].x);\n                left = Math.min(left, points[i].x);\n                top = Math.min(top, points[i].y);\n                bottom = Math.max(bottom, points[i].y);\n            }\n            return new Rect(left, top, right - left, bottom - top);\n        }\n    }\n\n    const topLeft = 'topLeft';\n    const bottomRight = 'bottomRight';\n    class CascadingRouter extends LinearConnectionRouter {\n        constructor(connection) {\n            super(connection);\n            this.SAME_SIDE_DISTANCE_RATIO = 5;\n            this._connectorSides = [{\n                    name: TOP,\n                    axis: Y,\n                    boundsPoint: topLeft,\n                    secondarySign: 1\n                }, {\n                    name: LEFT,\n                    axis: X,\n                    boundsPoint: topLeft,\n                    secondarySign: 1\n                }, {\n                    name: BOTTOM,\n                    axis: Y,\n                    boundsPoint: bottomRight,\n                    secondarySign: -1\n                }, {\n                    name: RIGHT,\n                    axis: X,\n                    boundsPoint: bottomRight,\n                    secondarySign: -1\n                }];\n            this.connection = connection;\n        }\n        routePoints(start, end, sourceConnector, targetConnector) {\n            let result;\n            if (sourceConnector && targetConnector) {\n                result = this._connectorPoints(start, end, sourceConnector, targetConnector);\n            }\n            else {\n                result = this._floatingPoints(start, end, sourceConnector);\n            }\n            return result;\n        }\n        route() {\n            const sourceConnector = this.connection._resolvedSourceConnector;\n            const targetConnector = this.connection._resolvedTargetConnector;\n            const start = this.connection.sourcePoint();\n            const end = this.connection.targetPoint();\n            const points = this.routePoints(start, end, sourceConnector, targetConnector);\n            this.connection.points(points);\n        }\n        _connectorSide(connector, targetPoint) {\n            const position = connector.position();\n            const shapeBounds = connector.shape.bounds(ROTATED);\n            const bounds = {\n                topLeft: shapeBounds.topLeft(),\n                bottomRight: shapeBounds.bottomRight()\n            };\n            const sides = this._connectorSides;\n            let min = Number.MAX_VALUE;\n            let sideDistance;\n            let minSide;\n            let axis;\n            let side;\n            for (let idx = 0; idx < sides.length; idx++) {\n                side = sides[idx];\n                axis = side.axis;\n                sideDistance = Math.round(Math.abs(position[axis] - bounds[side.boundsPoint][axis]));\n                if (sideDistance < min) {\n                    min = sideDistance;\n                    minSide = side;\n                }\n                else if (sideDistance === min &&\n                    (position[axis] - targetPoint[axis]) * side.secondarySign > (position[minSide.axis] - targetPoint[minSide.axis]) * minSide.secondarySign) {\n                    minSide = side;\n                }\n            }\n            return minSide.name;\n        }\n        _sameSideDistance(connector) {\n            const bounds = connector.shape.bounds(ROTATED);\n            return Math.min(bounds.width, bounds.height) / this.SAME_SIDE_DISTANCE_RATIO;\n        }\n        _connectorPoints(start, end, sourceConnector, targetConnector) {\n            const sourceConnectorSide = this._connectorSide(sourceConnector, end);\n            const targetConnectorSide = this._connectorSide(targetConnector, start);\n            const deltaX = end.x - start.x;\n            const deltaY = end.y - start.y;\n            const sameSideDistance = this._sameSideDistance(sourceConnector);\n            let result = [];\n            let pointX, pointY;\n            if (sourceConnectorSide === TOP || sourceConnectorSide === BOTTOM) {\n                if (targetConnectorSide === TOP || targetConnectorSide === BOTTOM) {\n                    if (sourceConnectorSide === targetConnectorSide) {\n                        if (sourceConnectorSide === TOP) {\n                            pointY = Math.min(start.y, end.y) - sameSideDistance;\n                        }\n                        else {\n                            pointY = Math.max(start.y, end.y) + sameSideDistance;\n                        }\n                        result = [new Point(start.x, pointY), new Point(end.x, pointY)];\n                    }\n                    else {\n                        result = [new Point(start.x, start.y + deltaY / 2), new Point(end.x, start.y + deltaY / 2)];\n                    }\n                }\n                else {\n                    result = [new Point(start.x, end.y)];\n                }\n            }\n            else {\n                if (targetConnectorSide === LEFT || targetConnectorSide === RIGHT) {\n                    if (sourceConnectorSide === targetConnectorSide) {\n                        if (sourceConnectorSide === LEFT) {\n                            pointX = Math.min(start.x, end.x) - sameSideDistance;\n                        }\n                        else {\n                            pointX = Math.max(start.x, end.x) + sameSideDistance;\n                        }\n                        result = [new Point(pointX, start.y), new Point(pointX, end.y)];\n                    }\n                    else {\n                        result = [new Point(start.x + deltaX / 2, start.y), new Point(start.x + deltaX / 2, start.y + deltaY)];\n                    }\n                }\n                else {\n                    result = [new Point(end.x, start.y)];\n                }\n            }\n            return result;\n        }\n        _floatingPoints(start, end, sourceConnector) {\n            const sourceConnectorSide = sourceConnector ? this._connectorSide(sourceConnector, end) : null;\n            const cascadeStartHorizontal = this._startHorizontal(start, end, sourceConnectorSide);\n            const points = [start, start, end, end];\n            const deltaX = end.x - start.x;\n            const deltaY = end.y - start.y;\n            const length = points.length;\n            let idx = 1;\n            let shiftX;\n            let shiftY;\n            // note that this is more generic than needed for only two intermediate points.\n            for (; idx < length - 1; ++idx) {\n                if (cascadeStartHorizontal) {\n                    if (idx % 2 !== 0) {\n                        shiftX = deltaX / (length / 2);\n                        shiftY = 0;\n                    }\n                    else {\n                        shiftX = 0;\n                        shiftY = deltaY / ((length - 1) / 2);\n                    }\n                }\n                else {\n                    if (idx % 2 !== 0) {\n                        shiftX = 0;\n                        shiftY = deltaY / (length / 2);\n                    }\n                    else {\n                        shiftX = deltaX / ((length - 1) / 2);\n                        shiftY = 0;\n                    }\n                }\n                points[idx] = new Point(points[idx - 1].x + shiftX, points[idx - 1].y + shiftY);\n            }\n            // need to fix the wrong 1.5 factor of the last intermediate point\n            idx--;\n            if ((cascadeStartHorizontal && (idx % 2 !== 0)) || (!cascadeStartHorizontal && (idx % 2 === 0))) {\n                points[length - 2] = new Point(points[length - 1].x, points[length - 2].y);\n            }\n            else {\n                points[length - 2] = new Point(points[length - 2].x, points[length - 1].y);\n            }\n            return [points[1], points[2]];\n        }\n        _startHorizontal(start, end, sourceSide) {\n            let horizontal;\n            if (sourceSide !== null && (sourceSide === RIGHT || sourceSide === LEFT)) {\n                horizontal = true;\n            }\n            else {\n                horizontal = Math.abs(start.x - end.x) > Math.abs(start.y - end.y);\n            }\n            return horizontal;\n        }\n    }\n\n    /**\n     * A simple poly-linear routing which does not alter the intermediate points.\n     * Does hold the underlying hit, bounds....logic.\n     *\n     * @type {*|Object|void|extend|Zepto.extend|b.extend}\n     */\n    class PolylineRouter extends LinearConnectionRouter {\n        constructor(connection) {\n            super(connection);\n            this.connection = connection;\n        }\n        route() {\n            // just keep the points as is\n        }\n    }\n\n    class ConnectionEditTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n            this.type = 'ConnectionTool';\n        }\n        tryActivate(_p, meta) {\n            const toolService = this.toolService, diagram = toolService.diagram, selectable = diagram.options.selectable, item = toolService.hoveredItem, isActive = selectable !== false &&\n                item && item.path && !(item.isSelected && meta.ctrlKey);\n            if (isActive) {\n                this._c = item;\n            }\n            return isActive;\n        }\n        start(point, meta, nativeEvent) {\n            const toolService = this.toolService;\n            const connection = this._c;\n            toolService.selectSingle(connection, meta);\n            const adorner = connection.adorner;\n            let handle, name;\n            if (adorner) {\n                handle = adorner._hitTest(point);\n                name = HANDLE_NAMES[handle];\n            }\n            if (canDrag(connection) && adorner && !toolService.diagram.trigger(DRAG_START, { shapes: [], connections: [connection], connectionHandle: name, point, meta, nativeEvent })) {\n                this.handle = handle;\n                this.handleName = name;\n                adorner.start(point);\n            }\n            else {\n                toolService.startPoint = point;\n                toolService.end(point, meta, nativeEvent);\n            }\n        }\n        move(point, meta, nativeEvent) {\n            const adorner = this._c.adorner;\n            if (canDrag(this._c) && adorner) {\n                adorner.move(this.handle, point);\n                this.toolService.diagram.trigger(DRAG, { shapes: [], connections: [this._c], connectionHandle: this.handleName, point, meta, nativeEvent });\n                return true;\n            }\n        }\n        end(point, meta, nativeEvent) {\n            const connection = this._c;\n            const adorner = connection.adorner;\n            const toolService = this.toolService;\n            const diagram = toolService.diagram;\n            if (adorner) {\n                if (canDrag(connection)) {\n                    const unit = adorner.stop(point);\n                    if (!diagram.trigger(DRAG_END, { shapes: [], connections: [connection], connectionHandle: this.handleName, point, meta, nativeEvent })) {\n                        diagram.undoRedoService.add(unit, false);\n                        connection.updateModel();\n                        diagram._syncConnectionChanges();\n                    }\n                    else {\n                        unit.undo();\n                    }\n                }\n            }\n        }\n        getCursor() {\n            return Cursors.move;\n        }\n    }\n\n    class ConnectionTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n            this.type = 'ConnectionTool';\n        }\n        tryActivate() {\n            return this.toolService._hoveredConnector;\n        }\n        start(point, meta, nativeEvent) {\n            const toolService = this.toolService, diagram = toolService.diagram, connector = toolService._hoveredConnector, connection = diagram._createConnection({}, connector._c, point);\n            if (canDrag(connection) && !diagram.trigger(DRAG_START, { shapes: [], connections: [connection], connectionHandle: TARGET, point, meta, nativeEvent }) && diagram._addConnection(connection)) {\n                toolService._connectionManipulation(connection, connector._c.shape, true);\n                toolService._removeHover();\n                toolService.selectSingle(toolService.activeConnection, meta);\n                if (meta.type === 'touchmove') {\n                    diagram._cachedTouchTarget = connector.visual;\n                }\n            }\n            else {\n                connection.source(null);\n                toolService.end(point, meta, nativeEvent);\n            }\n        }\n        move(point, meta, nativeEvent) {\n            const toolService = this.toolService;\n            const connection = toolService.activeConnection;\n            connection.target(point);\n            toolService.diagram.trigger(DRAG, { shapes: [], connections: [connection], connectionHandle: TARGET, point, meta, nativeEvent });\n            return true;\n        }\n        end(point, meta, nativeEvent) {\n            const toolService = this.toolService, diagram = toolService.diagram, connection = toolService.activeConnection, hoveredItem = toolService.hoveredItem, connector = toolService._hoveredConnector, cachedTouchTarget = diagram._cachedTouchTarget;\n            let target;\n            if (!connection) {\n                return;\n            }\n            if (connector && connector._c !== connection.sourceConnector) {\n                target = connector._c;\n            }\n            else if (hoveredItem && hoveredItem instanceof Shape) {\n                target = hoveredItem.getConnector(AUTO) || hoveredItem.getConnector(point);\n            }\n            else {\n                target = point;\n            }\n            connection.target(target);\n            if (!diagram.trigger(DRAG_END, { shapes: [], connections: [connection], connectionHandle: TARGET, point, meta, nativeEvent })) {\n                connection.updateModel();\n                diagram._syncConnectionChanges();\n            }\n            else {\n                diagram.remove(connection, false);\n                diagram.undoRedoService.pop();\n            }\n            toolService._connectionManipulation();\n            if (cachedTouchTarget) {\n                diagram._connectorsAdorner.visual.remove(cachedTouchTarget);\n                diagram._cachedTouchTarget = null;\n            }\n        }\n        getCursor() {\n            return Cursors.arrow;\n        }\n    }\n\n    class EmptyTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n        }\n        start() {\n        }\n        move() {\n        }\n        end() {\n        }\n        tryActivate() {\n            return false;\n        }\n        getCursor() {\n            return Cursors.arrow;\n        }\n    }\n\n    function noMeta(meta) {\n        return meta.ctrlKey === false && meta.altKey === false && meta.shiftKey === false;\n    }\n\n    /**\n     * The tool handling the transformations via the adorner.\n     *\n     * @type {*}\n     */\n    class PointerTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n        }\n        tryActivate() {\n            return true; // the pointer tool is last and handles all others requests.\n        }\n        start(point, meta, nativeEvent) {\n            const toolService = this.toolService, diagram = toolService.diagram, hoveredItem = toolService.hoveredItem;\n            if (hoveredItem) {\n                toolService.selectSingle(hoveredItem, meta);\n                if (hoveredItem.adorner) { // connection\n                    this.adorner = hoveredItem.adorner;\n                    this.handle = this.adorner._hitTest(point);\n                }\n            }\n            if (!this.handle) {\n                this.handle = diagram._resizingAdorner._hitTest(point);\n                if (this.handle) {\n                    this.adorner = diagram._resizingAdorner;\n                }\n            }\n            if (this.adorner) {\n                if (!this.adorner.isDragHandle(this.handle) || !diagram.trigger(DRAG_START, { shapes: this.adorner.shapes, connections: [], point, nativeEvent, meta })) {\n                    this.adorner.start(point);\n                }\n                else {\n                    toolService.startPoint = point;\n                    toolService.end(point, meta, nativeEvent);\n                }\n            }\n        }\n        move(point, meta, nativeEvent) {\n            if (this.adorner) {\n                this.adorner.move(this.handle, point);\n                if (this.adorner.isDragHandle(this.handle)) {\n                    this.toolService.diagram.trigger(DRAG, { shapes: this.adorner.shapes, connections: [], point, meta, nativeEvent });\n                }\n            }\n        }\n        end(point, meta, nativeEvent) {\n            const diagram = this.toolService.diagram, adorner = this.adorner;\n            let unit;\n            if (adorner) {\n                if (!adorner.isDragHandle(this.handle) || !diagram.trigger(DRAG_END, { shapes: adorner.shapes, connections: [], point, meta, nativeEvent })) {\n                    unit = adorner.stop();\n                    if (unit) {\n                        diagram.undoRedoService.add(unit, false);\n                    }\n                }\n                else {\n                    adorner.cancel();\n                }\n            }\n            this.adorner = undefined;\n            this.handle = undefined;\n        }\n        getCursor(p) {\n            return this.toolService.hoveredItem ? this.toolService.hoveredItem._getCursor(p) : Cursors.arrow;\n        }\n    }\n\n    const eventMap = {\n        down: 'pointerdown',\n        move: 'pointermove',\n        up: 'pointerup',\n        cancel: 'pointercancel pointerleave'\n    };\n    function queryEventMap(e) {\n        return eventMap[e] || e;\n    }\n    const applyEventMap = (events) => {\n        const eventRegEx = /([^ ]+)/g;\n        const appliedEvents = events.replace(eventRegEx, queryEventMap);\n        return appliedEvents;\n    };\n\n    const elementOffset$1 = kendo_drawing_cmn_chunk_js.w;\n    const translate = function (x, y, scale) {\n        return 'translate3d(' + x + 'px,' + y + 'px,0) scale(' + scale + ')';\n    };\n    class TapCapture extends Observable {\n        constructor(element, options) {\n            super();\n            const domElement = element[0] || element;\n            this.element = domElement;\n            this.capture = false;\n            this._pressHandler = this._press.bind(this);\n            this._releaseHandler = this._release.bind(this);\n            eventMap.down.split(' ').forEach((event) => {\n                domElement.addEventListener(event, this._pressHandler, true);\n            });\n            eventMap.up.split(' ').forEach((event) => {\n                domElement.addEventListener(event, this._releaseHandler, true);\n            });\n            this.bind([\n                'press',\n                'release'\n            ], options || {});\n        }\n        captureNext() {\n            this.capture = true;\n        }\n        cancelCapture() {\n            this.capture = false;\n        }\n        _press(e) {\n            this.trigger('press');\n            if (this.capture) {\n                e.preventDefault();\n            }\n        }\n        _release(e) {\n            this.trigger('release');\n            if (this.capture) {\n                e.preventDefault();\n                this.cancelCapture();\n            }\n        }\n        destroy() {\n            const domElement = this.element;\n            eventMap.down.split(' ').forEach((event) => {\n                domElement.removeEventListener(event, this._pressHandler, true);\n            });\n            eventMap.up.split(' ').forEach((event) => {\n                domElement.removeEventListener(event, this._releaseHandler, true);\n            });\n        }\n    }\n    class PaneDimension extends Observable {\n        constructor(options) {\n            super();\n            this.forcedEnabled = false;\n            extend$1(this, options);\n            this.scale = 1;\n            if (this.horizontal) {\n                this.measure = 'offsetWidth';\n                this.scrollSize = 'scrollWidth';\n                this.axis = 'x';\n            }\n            else {\n                this.measure = 'offsetHeight';\n                this.scrollSize = 'scrollHeight';\n                this.axis = 'y';\n            }\n        }\n        makeVirtual() {\n            extend$1(this, {\n                virtual: true,\n                forcedEnabled: true,\n                _virtualMin: 0,\n                _virtualMax: 0\n            });\n        }\n        virtualSize(min, max) {\n            if (this._virtualMin !== min || this._virtualMax !== max) {\n                this._virtualMin = min;\n                this._virtualMax = max;\n                this.update();\n            }\n        }\n        outOfBounds(offset) {\n            return offset > this.max || offset < this.min;\n        }\n        forceEnabled() {\n            this.forcedEnabled = true;\n        }\n        getSize() {\n            return this.container[this.measure];\n        }\n        getTotal() {\n            return this.element[this.scrollSize];\n        }\n        rescale(scale) {\n            this.scale = scale;\n        }\n        update(silent) {\n            const total = this.virtual ? this._virtualMax : this.getTotal(), scaledTotal = total * this.scale, size = this.getSize();\n            if (total === 0 && !this.forcedEnabled) {\n                return;\n            }\n            this.max = this.virtual ? -this._virtualMin : 0;\n            this.size = size;\n            this.total = scaledTotal;\n            this.min = Math.min(this.max, size - scaledTotal);\n            this.minScale = size / total;\n            this.centerOffset = (scaledTotal - size) / 2;\n            this.enabled = this.forcedEnabled || scaledTotal > size;\n            if (!silent) {\n                this.trigger(CHANGE$1, this);\n            }\n        }\n    }\n    class PaneDimensions extends Observable {\n        constructor(options) {\n            super();\n            this.x = new PaneDimension(extend$1({\n                horizontal: true\n            }, options));\n            this.y = new PaneDimension(extend$1({\n                horizontal: false\n            }, options));\n            this.container = options.container;\n            this.forcedMinScale = options.minScale;\n            this.maxScale = options.maxScale || 100;\n            this.bind(CHANGE$1, options);\n        }\n        rescale(newScale) {\n            this.x.rescale(newScale);\n            this.y.rescale(newScale);\n            this.refresh();\n        }\n        centerCoordinates() {\n            return {\n                x: Math.min(0, -this.x.centerOffset),\n                y: Math.min(0, -this.y.centerOffset)\n            };\n        }\n        refresh() {\n            this.x.update();\n            this.y.update();\n            this.enabled = this.x.enabled || this.y.enabled;\n            this.minScale = this.forcedMinScale || Math.min(this.x.minScale, this.y.minScale);\n            this.fitScale = Math.max(this.x.minScale, this.y.minScale);\n            this.trigger(CHANGE$1);\n        }\n    }\n    class PaneAxis extends Observable {\n        constructor(options) {\n            super();\n            extend$1(this, options);\n        }\n        outOfBounds() {\n            return this.dimension.outOfBounds(this.movable[this.axis]);\n        }\n        dragMove(delta) {\n            const dimension = this.dimension, axis = this.axis, movable = this.movable, position = movable[axis] + delta;\n            if (!dimension.enabled) {\n                return;\n            }\n            let dragDelta = delta;\n            if (position < dimension.min && delta < 0 || position > dimension.max && delta > 0) {\n                dragDelta *= this.resistance;\n            }\n            movable.translateAxis(axis, dragDelta);\n            this.trigger(CHANGE$1, this);\n        }\n    }\n    class Pane {\n        constructor(options) {\n            let x, y;\n            extend$1(this, {\n                elastic: true\n            }, options);\n            const resistance = this.elastic ? 0.5 : 0;\n            const movable = this.movable;\n            this.x = x = new PaneAxis({\n                axis: 'x',\n                dimension: this.dimensions.x,\n                resistance: resistance,\n                movable: movable\n            });\n            this.y = y = new PaneAxis({\n                axis: 'y',\n                dimension: this.dimensions.y,\n                resistance: resistance,\n                movable: movable\n            });\n            this.userEvents.bind([\n                'press',\n                'move',\n                'end',\n                'gesturestart',\n                'gesturechange'\n            ], {\n                gesturestart(e) {\n                    this.gesture = e;\n                    this.offset = elementOffset$1(this.dimensions.container);\n                },\n                press(e) {\n                    const closestAnchor = e.event.target.closest('a');\n                    if (closestAnchor && closestAnchor.matches('[data-navigate-on-press=true]')) {\n                        e.sender.cancel();\n                    }\n                },\n                gesturechange(e) {\n                    const previousGesture = this.gesture, previousCenter = previousGesture.center, center = e.center, minScale = this.dimensions.minScale, maxScale = this.dimensions.maxScale;\n                    let scaleDelta = e.distance / previousGesture.distance;\n                    if (movable.scale <= minScale && scaleDelta < 1) {\n                        scaleDelta += (1 - scaleDelta) * 0.8;\n                    }\n                    if (movable.scale * scaleDelta >= maxScale) {\n                        scaleDelta = maxScale / movable.scale;\n                    }\n                    const offsetX = movable.x + this.offset.left, offsetY = movable.y + this.offset.top;\n                    const coordinates = {\n                        x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,\n                        y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY\n                    };\n                    movable.scaleWith(scaleDelta);\n                    x.dragMove(coordinates.x);\n                    y.dragMove(coordinates.y);\n                    this.dimensions.rescale(movable.scale);\n                    this.gesture = e;\n                    e.preventDefault();\n                },\n                move(e) {\n                    if (e.event.target.tagName.match(/textarea|input/i)) {\n                        return;\n                    }\n                    if (x.dimension.enabled || y.dimension.enabled) {\n                        x.dragMove(e.x.delta);\n                        y.dragMove(e.y.delta);\n                        e.preventDefault();\n                    }\n                    else {\n                        e.touch.skip();\n                    }\n                },\n                end(e) {\n                    e.preventDefault();\n                }\n            });\n        }\n    }\n    class Movable extends Observable {\n        constructor(element) {\n            super();\n            this.element = element;\n            this.element.style.transformOrigin = 'left top';\n            this.x = 0;\n            this.y = 0;\n            this.scale = 1;\n            const coordinates = translate(this.x, this.y, this.scale);\n            this.element.style.transform = coordinates;\n            this._saveCoordinates(coordinates);\n        }\n        translateAxis(axis, by) {\n            this[axis] += by;\n            this.refresh();\n        }\n        scaleTo(scale) {\n            this.scale = scale;\n            this.refresh();\n        }\n        scaleWith(scaleDelta) {\n            this.scale *= scaleDelta;\n            this.refresh();\n        }\n        translate(coordinates) {\n            this.x += coordinates.x;\n            this.y += coordinates.y;\n            this.refresh();\n        }\n        moveAxis(axis, value) {\n            this[axis] = value;\n            this.refresh();\n        }\n        moveTo(coordinates) {\n            extend$1(this, coordinates);\n            this.refresh();\n        }\n        refresh() {\n            let x = this.x, y = this.y;\n            if (this.round) {\n                x = Math.round(x);\n                y = Math.round(y);\n            }\n            const newCoordinates = translate(x, y, this.scale);\n            if (newCoordinates !== this.coordinates) {\n                this.element.style.transform = newCoordinates;\n                this._saveCoordinates(newCoordinates);\n                this.trigger(CHANGE$1);\n            }\n        }\n        _saveCoordinates(coordinates) {\n            this.coordinates = coordinates;\n        }\n    }\n\n    function animationFrame(callback) {\n        window.requestAnimationFrame(callback);\n    }\n    class Animation {\n        constructor() {\n            this._tickProxy = () => this._tick();\n            this._started = false;\n        }\n        tick() { }\n        done() { return false; }\n        onEnd() { }\n        onCancel() { }\n        start() {\n            if (!this.enabled()) {\n                return;\n            }\n            if (!this.done()) {\n                this._started = true;\n                animationFrame(this._tickProxy);\n            }\n            else {\n                this.onEnd();\n            }\n        }\n        enabled() {\n            return true;\n        }\n        cancel() {\n            this._started = false;\n            this.onCancel();\n        }\n        _tick() {\n            if (!this._started) {\n                return;\n            }\n            this.tick();\n            if (!this.done()) {\n                animationFrame(this._tickProxy);\n            }\n            else {\n                this._started = false;\n                this.onEnd();\n            }\n        }\n    }\n    class Transition extends Animation {\n        constructor(options) {\n            super();\n            extend$1(this, options);\n        }\n        done() {\n            return this.timePassed() >= this.duration;\n        }\n        timePassed() {\n            return Math.min(this.duration, now() - this.startDate);\n        }\n        moveTo(options) {\n            const movable = this.movable;\n            this.initial = movable[this.axis];\n            this.delta = options.location - this.initial;\n            this.duration = typeof options.duration === 'number' ? options.duration : 300;\n            this.tick = this._easeProxy(options.ease);\n            this.startDate = now();\n            this.start();\n        }\n        _easeProxy(ease) {\n            return function () {\n                this.movable.moveAxis(this.axis, ease(this.timePassed(), this.initial, this.delta, this.duration));\n            };\n        }\n        static easeOutExpo(t, b, c, d) {\n            return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n        }\n    }\n\n    function guid() {\n        let id = '';\n        let i;\n        let random;\n        for (i = 0; i < 32; i++) {\n            random = Math.floor(Math.random() * 16);\n            if (i === 8 || i === 12 || i === 16 || i === 20) {\n                id += '-';\n            }\n            id += (i === 12 ? 4 : (i === 16 ? ((random % 4) + 8) : random)).toString(16);\n        }\n        return id;\n    }\n\n    const elementEventHandlers = new WeakMap();\n    const ID = Symbol('id');\n    function on(element, events, filter, handler, useCapture) {\n        addEventListeners(element, events, filter, handler, useCapture);\n    }\n    function off(element, events, handler, useCapture) {\n        removeEventListeners(element, events, handler, useCapture);\n    }\n    function isString(value) {\n        return typeof (value) === 'string';\n    }\n    function addEventListeners(element, events, filter, handler, useCapture) {\n        const eventNames = Array.isArray(events) ? events : (events || '').split(' ');\n        eventNames.forEach(function (eventName) {\n            addEventListener(element, eventName, filter, handler, useCapture);\n        });\n    }\n    function addEventListener(element, event, filter, handler, useCapture) {\n        let eventHandler = handler;\n        let eventFilter;\n        if (filter && isFunction$1(filter) && !handler) {\n            eventHandler = filter;\n        }\n        else if (filter && isString(filter) && isFunction$1(eventHandler)) {\n            eventFilter = filter;\n        }\n        const attachedHandler = function (e) {\n            const closestMatchingTarget = e.target ? e.target.closest(eventFilter) : null;\n            if (!eventFilter ||\n                (eventFilter && e.target && closestMatchingTarget)) {\n                const currentTarget = eventFilter ? closestMatchingTarget : e.currentTarget;\n                // reassign the property as it is a getters only\n                Object.defineProperty(e, 'currentTarget', { value: currentTarget });\n                // keep a reference to the top-level target\n                Object.defineProperty(e, 'delegateTarget', { value: element });\n                eventHandler(e);\n            }\n        };\n        if (!eventHandler[ID]) {\n            eventHandler[ID] = guid();\n        }\n        let eventHandlers = elementEventHandlers.get(element);\n        if (!eventHandlers) {\n            eventHandlers = new Map();\n            elementEventHandlers.set(element, eventHandlers);\n        }\n        eventHandlers.set(event + eventHandler[ID], attachedHandler);\n        element.addEventListener(event, attachedHandler, Boolean(useCapture));\n    }\n    function removeEventListeners(element, events, handler, useCapture) {\n        const eventNames = Array.isArray(events) ? events : (events || '').split(' ');\n        eventNames.forEach(function (eventName) {\n            removeEventListener(element, eventName, handler, useCapture);\n        });\n    }\n    function removeEventListener(element, event, handler, useCapture) {\n        const eventHandlers = elementEventHandlers.get(element);\n        if (eventHandlers && handler && handler[ID]) {\n            const handlerId = event + handler[ID];\n            const attachedHandler = eventHandlers.get(handlerId);\n            eventHandlers.delete(handlerId);\n            if (attachedHandler) {\n                element.removeEventListener(event, attachedHandler, Boolean(useCapture));\n            }\n        }\n    }\n\n    function grep(array, callback) {\n        const length = array.length;\n        const result = [];\n        for (let idx = 0; idx < length; idx++) {\n            if (callback(array[idx])) {\n                result.push(array[idx]);\n            }\n        }\n        return result;\n    }\n\n    const preventDefault$1 = (e) => {\n        e.preventDefault();\n    };\n    const noop = () => { };\n    const CLICK_DELAY = 300, PRESS = 'press', HOLD = 'hold', SELECT = 'select', START = 'start', MOVE = 'move', END = 'end', CANCEL = 'cancel', TAP = 'tap', DOUBLETAP = 'doubleTap', RELEASE = 'release', GESTURESTART = 'gesturestart', GESTURECHANGE = 'gesturechange', GESTUREEND = 'gestureend', GESTURETAP = 'gesturetap';\n    const THRESHOLD = {\n        'api': 0,\n        'touch': 0,\n        'mouse': 9,\n        'pointer': 9\n    };\n    let DEFAULT_MIN_HOLD = 800, DEFAULT_THRESHOLD = 0;\n    function touchDelta(touch1, touch2) {\n        const x1 = touch1.x.location, y1 = touch1.y.location, x2 = touch2.x.location, y2 = touch2.y.location, dx = x1 - x2, dy = y1 - y2;\n        return {\n            center: {\n                x: (x1 + x2) / 2,\n                y: (y1 + y2) / 2\n            },\n            distance: Math.sqrt(dx * dx + dy * dy)\n        };\n    }\n    function getTouches(e) {\n        const touches = [], originalEvent = e.originalEvent || e, currentTarget = e.currentTarget;\n        if (e.api) {\n            touches.push({\n                id: 2, // hardcoded ID for API call\n                event: e,\n                target: e.target,\n                currentTarget: e.target,\n                location: e,\n                type: 'api'\n            });\n        }\n        else {\n            touches.push({\n                location: originalEvent,\n                event: e,\n                target: e.target,\n                currentTarget: currentTarget,\n                id: originalEvent.pointerId,\n                type: 'pointer'\n            });\n        }\n        return touches;\n    }\n    class TouchAxis {\n        constructor(axis, location) {\n            this.support = getSupportedFeatures();\n            this.invalidZeroEvents = this.support.mobileOS && this.support.mobileOS.android;\n            this.axis = axis;\n            this._updateLocationData(location);\n            this.startLocation = this.location;\n            this.velocity = this.delta = 0;\n            this.timeStamp = now();\n        }\n        move(location) {\n            const offset = location['page' + this.axis], timeStamp = now(), timeDelta = timeStamp - this.timeStamp || 1;\n            if (!offset && this.invalidZeroEvents) {\n                return;\n            }\n            this.delta = offset - this.location;\n            this._updateLocationData(location);\n            this.initialDelta = offset - this.startLocation;\n            this.velocity = this.delta / timeDelta;\n            this.timeStamp = timeStamp;\n        }\n        _updateLocationData(location) {\n            const axis = this.axis;\n            this.location = location['page' + axis];\n            this.client = location['client' + axis];\n            this.screen = location['screen' + axis];\n        }\n    }\n    class Touch {\n        constructor(userEvents, target, touchInfo) {\n            extend$1(this, {\n                x: new TouchAxis('X', touchInfo.location),\n                y: new TouchAxis('Y', touchInfo.location),\n                type: touchInfo.type,\n                threshold: userEvents.threshold || THRESHOLD[touchInfo.type],\n                userEvents: userEvents,\n                target: target,\n                currentTarget: touchInfo.currentTarget,\n                initialTouch: touchInfo.target,\n                id: touchInfo.id,\n                pressEvent: touchInfo,\n                _clicks: userEvents._clicks,\n                supportDoubleTap: userEvents.supportDoubleTap,\n                _moved: false,\n                _finished: false\n            });\n        }\n        press() {\n            this._holdTimeout = setTimeout(() => this._hold(), this.userEvents.minHold);\n            this._trigger(PRESS, this.pressEvent);\n        }\n        _tap(touchInfo) {\n            this.userEvents._clicks++;\n            if (this.userEvents._clicks === 1) {\n                this._clickTimeout = setTimeout(() => {\n                    if (this.userEvents._clicks === 1) {\n                        this._trigger(TAP, touchInfo);\n                    }\n                    else {\n                        this._trigger(DOUBLETAP, touchInfo);\n                    }\n                    this.userEvents._clicks = 0;\n                }, CLICK_DELAY);\n            }\n        }\n        _hold() {\n            this._trigger(HOLD, this.pressEvent);\n        }\n        move(touchInfo) {\n            const preventMove = touchInfo.type !== 'api' && this.userEvents._shouldNotMove;\n            if (this._finished || preventMove) {\n                return;\n            }\n            this.x.move(touchInfo.location);\n            this.y.move(touchInfo.location);\n            if (!this._moved) {\n                if (this._withinIgnoreThreshold()) {\n                    return;\n                }\n                if (!UserEvents.current || UserEvents.current === this.userEvents) {\n                    this._start(touchInfo);\n                }\n                else {\n                    return this.dispose();\n                }\n            }\n            if (!this._finished) {\n                this._trigger(MOVE, touchInfo);\n            }\n        }\n        end(touchInfo) {\n            this.endTime = now();\n            if (this._finished) {\n                return;\n            }\n            this._finished = true;\n            this._trigger(RELEASE, touchInfo);\n            if (this._moved) {\n                this._trigger(END, touchInfo);\n            }\n            else {\n                if (this.supportDoubleTap) {\n                    this._tap(touchInfo);\n                }\n                else {\n                    this._trigger(TAP, touchInfo);\n                }\n            }\n            clearTimeout(this._holdTimeout);\n            this.dispose();\n        }\n        dispose() {\n            const userEvents = this.userEvents, activeTouches = userEvents.touches || [];\n            this._finished = true;\n            this.pressEvent = null;\n            clearTimeout(this._holdTimeout);\n            // activeTouches.splice($.inArray(this, activeTouches), 1);\n            const activeTouchIndex = activeTouches.indexOf(this);\n            activeTouches.splice(activeTouchIndex, 1);\n        }\n        skip() {\n            this.dispose();\n        }\n        cancel() {\n            this.dispose();\n        }\n        isMoved() {\n            return this._moved;\n        }\n        _start(touchInfo) {\n            clearTimeout(this._holdTimeout);\n            this.startTime = now();\n            this._moved = true;\n            this._trigger(START, touchInfo);\n        }\n        _trigger(name, touchInfo) {\n            const e = touchInfo.event;\n            const data = {\n                touch: this,\n                x: this.x,\n                y: this.y,\n                target: this.target,\n                event: e\n            };\n            if (this.userEvents.notify(name, data)) {\n                e.preventDefault();\n            }\n        }\n        _withinIgnoreThreshold() {\n            const xDelta = this.x.initialDelta, yDelta = this.y.initialDelta;\n            return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;\n        }\n    }\n    function withEachUpEvent(callback) {\n        const downEvents = eventMap.up.split(' '), length = downEvents.length;\n        for (let idx = 0; idx < length; idx++) {\n            callback(downEvents[idx]);\n        }\n    }\n    class UserEvents extends Observable {\n        constructor(element, options) {\n            super();\n            const support = getSupportedFeatures();\n            this.support = support;\n            options = options || {};\n            this.options = options;\n            const filter = this.filter = options.filter;\n            this.threshold = options.threshold || DEFAULT_THRESHOLD;\n            this.minHold = options.minHold || DEFAULT_MIN_HOLD;\n            this.touches = [];\n            this._maxTouches = options.multiTouch ? 2 : 1;\n            this.allowSelection = options.allowSelection;\n            this.captureUpIfMoved = options.captureUpIfMoved;\n            this._clicks = 0;\n            this.supportDoubleTap = options.supportDoubleTap;\n            extend$1(this, {\n                element: element,\n                surface: options.surface || element,\n                stopPropagation: options.stopPropagation,\n                pressed: false\n            });\n            this._surfaceMoveHandler = this._move.bind(this);\n            on(this.surface, applyEventMap('move'), this._surfaceMoveHandler);\n            this._surfaceEndHandler = this._end.bind(this);\n            on(this.surface, applyEventMap('up cancel'), this._surfaceEndHandler);\n            this._elementStartHandler = this._start.bind(this);\n            on(element, applyEventMap('down'), filter, this._elementStartHandler);\n            element.style['touch-action'] = options.touchAction || 'none';\n            if (options.preventDragEvent) {\n                this._elementDragStartHandler = preventDefault$1;\n                on(element, applyEventMap('dragstart'), this._elementDragStartHandler);\n            }\n            // element.on(kendo.applyEventMap('mousedown'), filter, {\n            //     root: element\n            // } '_select');\n            // todo: use root\n            this._elementSelectHandler = this._select.bind(this);\n            on(element, applyEventMap('mousedown'), filter, this._elementSelectHandler);\n            if (this.captureUpIfMoved) {\n                const surfaceElement = this.surface;\n                this.preventIfMovingProxy = this.preventIfMoving.bind(this);\n                withEachUpEvent((eventName) => {\n                    surfaceElement.addEventListener(eventName, this.preventIfMovingProxy, true);\n                });\n            }\n            this.bind([\n                PRESS,\n                HOLD,\n                TAP,\n                DOUBLETAP,\n                START,\n                MOVE,\n                END,\n                RELEASE,\n                CANCEL,\n                GESTURESTART,\n                GESTURECHANGE,\n                GESTUREEND,\n                GESTURETAP,\n                SELECT\n            ], options);\n        }\n        preventIfMoving(e) {\n            if (this._isMoved()) {\n                e.preventDefault();\n            }\n        }\n        destroy() {\n            const options = this.options;\n            const element = this.element;\n            if (this._destroyed) {\n                return;\n            }\n            this._destroyed = true;\n            if (this.captureUpIfMoved) {\n                const surfaceElement = this.surface;\n                withEachUpEvent((eventName) => {\n                    surfaceElement.removeEventListener(eventName, this.preventIfMovingProxy, true);\n                });\n            }\n            off(this.surface, applyEventMap('move'), this._surfaceMoveHandler);\n            off(this.surface, applyEventMap('up cancel'), this._surfaceEndHandler);\n            off(element, applyEventMap('down'), this._elementStartHandler);\n            if (options.preventDragEvent) {\n                off(element, applyEventMap('dragstart'), this._elementDragStartHandler);\n            }\n            off(element, applyEventMap('mousedown'), this._elementSelectHandler);\n            this._disposeAll();\n            this.unbind();\n            delete this.surface;\n            delete this.element;\n            delete this.currentTarget;\n        }\n        capture() {\n            UserEvents.current = this;\n        }\n        cancel() {\n            this._disposeAll();\n            this.trigger(CANCEL);\n        }\n        notify(event, data) {\n            const touches = this.touches;\n            let eventName = event;\n            if (this._isMultiTouch()) {\n                switch (eventName) {\n                    case MOVE:\n                        eventName = GESTURECHANGE;\n                        break;\n                    case END:\n                        eventName = GESTUREEND;\n                        break;\n                    case TAP:\n                        eventName = GESTURETAP;\n                        break;\n                    default:\n                        break;\n                }\n                extend$1(data, {\n                    touches: touches\n                }, touchDelta(touches[0], touches[1]));\n            }\n            return this.trigger(eventName, extend$1(data, {\n                type: eventName\n            }));\n        }\n        press(x, y, target) {\n            this._apiCall('_start', x, y, target);\n        }\n        move(x, y) {\n            this._apiCall('_move', x, y);\n        }\n        end(x, y) {\n            this._apiCall('_end', x, y);\n        }\n        _isMultiTouch() {\n            return this.touches.length > 1;\n        }\n        _maxTouchesReached() {\n            return this.touches.length >= this._maxTouches;\n        }\n        _disposeAll() {\n            const touches = this.touches;\n            while (touches.length > 0) {\n                touches.pop().dispose();\n            }\n        }\n        _isMoved() {\n            return grep(this.touches, function (touch) {\n                return touch.isMoved();\n            }).length;\n        }\n        _select(e) {\n            if (!this.allowSelection || this.trigger(SELECT, { event: e })) {\n                e.preventDefault();\n            }\n        }\n        _start(e) {\n            if (e.which && e.which > 1 || this._maxTouchesReached()) {\n                return;\n            }\n            UserEvents.current = null;\n            this.currentTarget = e.currentTarget;\n            if (this.stopPropagation) {\n                e.stopPropagation();\n            }\n            let target;\n            const eventTouches = getTouches(e);\n            for (let idx = 0; idx < eventTouches.length; idx++) {\n                if (this._maxTouchesReached()) {\n                    break;\n                }\n                const eventTouch = eventTouches[idx];\n                if (this.filter) {\n                    target = eventTouch.currentTarget;\n                }\n                else {\n                    target = this.element;\n                }\n                if (target && target.length === 0) {\n                    continue;\n                }\n                const touch = new Touch(this, target, eventTouch);\n                this.touches.push(touch);\n                touch.press();\n                if (this._isMultiTouch()) {\n                    this.notify('gesturestart', {});\n                }\n            }\n        }\n        _move(e) {\n            this._eachTouch('move', e);\n        }\n        _end(e) {\n            this._eachTouch('end', e);\n        }\n        _eachTouch(methodName, e) {\n            const dict = {}, touches = getTouches(e), activeTouches = this.touches;\n            let idx, touch, touchInfo, matchingTouch;\n            for (idx = 0; idx < activeTouches.length; idx++) {\n                touch = activeTouches[idx];\n                dict[touch.id] = touch;\n            }\n            for (idx = 0; idx < touches.length; idx++) {\n                touchInfo = touches[idx];\n                matchingTouch = dict[touchInfo.id];\n                if (matchingTouch) {\n                    const shouldCapture = methodName === 'move' && touchInfo.type === 'pointer' && !this.surface.hasPointerCapture(touchInfo.id);\n                    if (shouldCapture) {\n                        this.surface.setPointerCapture(touchInfo.id);\n                    }\n                    matchingTouch[methodName](touchInfo);\n                }\n            }\n        }\n        _apiCall(type, x, y, target) {\n            this[type]({\n                api: true,\n                pageX: x,\n                pageY: y,\n                clientX: x,\n                clientY: y,\n                target: target || this.element,\n                stopPropagation: noop,\n                preventDefault: noop\n            });\n        }\n        static defaultThreshold(value) {\n            DEFAULT_THRESHOLD = value;\n        }\n        static minHold(value) {\n            DEFAULT_MIN_HOLD = value;\n        }\n    }\n\n    const extend = Object.assign, abs = Math.abs, SNAPBACK_DURATION = 500, SCROLLBAR_OPACITY = 0.7, FRICTION = 0.96, VELOCITY_MULTIPLIER = 10, MAX_VELOCITY = 55, OUT_OF_BOUNDS_FRICTION = 0.5, ANIMATED_SCROLLER_PRECISION = 5, \n    // SCROLLER_RELEASE_CLASS = 'km-scroller-release',\n    // SCROLLER_REFRESH_CLASS = 'km-scroller-refresh',\n    PULL = 'pull', CHANGE = 'change', RESIZE = 'resize', SCROLL = 'scroll', MOUSE_WHEEL_ID = 2;\n    class ZoomSnapBack extends Animation {\n        constructor(options) {\n            super();\n            extend(this, options);\n            this.userEvents.bind('gestureend', this.start.bind(this));\n            this.tapCapture.bind('press', this.cancel.bind(this));\n        }\n        enabled() {\n            return this.movable.scale < this.dimensions.minScale;\n        }\n        done() {\n            return this.dimensions.minScale - this.movable.scale < 0.01;\n        }\n        tick() {\n            const movable = this.movable;\n            movable.scaleWith(1.1);\n            this.dimensions.rescale(movable.scale);\n        }\n        onEnd() {\n            const movable = this.movable;\n            movable.scaleTo(this.dimensions.minScale);\n            this.dimensions.rescale(movable.scale);\n        }\n    }\n    class DragInertia extends Animation {\n        constructor(options) {\n            super();\n            extend(this, options, {\n                transition: new Transition({\n                    axis: options.axis,\n                    movable: options.movable,\n                    onEnd: () => {\n                        this._end();\n                    }\n                })\n            });\n            this.tapCapture.bind('press', () => {\n                this.cancel();\n            });\n            this.userEvents.bind('end', () => this.start());\n            this.userEvents.bind('gestureend', () => this.start());\n            this.userEvents.bind('tap', () => this.onEnd());\n        }\n        onCancel() {\n            this.transition.cancel();\n        }\n        freeze(location) {\n            this.cancel();\n            this._moveTo(location);\n        }\n        onEnd() {\n            if (this.paneAxis.outOfBounds()) {\n                this._snapBack();\n            }\n            else {\n                this._end();\n            }\n        }\n        done() {\n            return abs(this.velocity) < 1;\n        }\n        start(e) {\n            let velocity;\n            if (!this.dimension.enabled) {\n                return;\n            }\n            if (this.paneAxis.outOfBounds()) {\n                if (this.transition._started) {\n                    this.transition.cancel();\n                    this.velocity = Math.min(e.touch[this.axis].velocity * this.velocityMultiplier, MAX_VELOCITY);\n                    super.start();\n                }\n                else {\n                    this._snapBack();\n                }\n            }\n            else {\n                velocity = e ? (e.touch.id === MOUSE_WHEEL_ID ? 0 : e.touch[this.axis].velocity) : 0;\n                this.velocity = Math.max(Math.min(velocity * this.velocityMultiplier, MAX_VELOCITY), -MAX_VELOCITY);\n                this.tapCapture.captureNext();\n                super.start();\n            }\n        }\n        tick() {\n            const dimension = this.dimension, friction = this.paneAxis.outOfBounds() ? OUT_OF_BOUNDS_FRICTION : this.friction, delta = this.velocity *= friction;\n            let location = this.movable[this.axis] + delta;\n            if (!this.elastic && dimension.outOfBounds(location)) {\n                location = Math.max(Math.min(location, dimension.max), dimension.min);\n                this.velocity = 0;\n            }\n            this.movable.moveAxis(this.axis, location);\n        }\n        _end() {\n            this.tapCapture.cancelCapture();\n            this.end();\n        }\n        end() { }\n        _snapBack() {\n            const dimension = this.dimension, snapBack = this.movable[this.axis] > dimension.max ? dimension.max : dimension.min;\n            this._moveTo(snapBack);\n        }\n        _moveTo(location) {\n            this.transition.moveTo({\n                location: location,\n                duration: SNAPBACK_DURATION,\n                ease: (...args) => {\n                    Transition.easeOutExpo.apply(null, args);\n                }\n            });\n        }\n    }\n    class AnimatedScroller extends Animation {\n        constructor(options) {\n            super();\n            extend(this, options, {\n                origin: {},\n                destination: {},\n                offset: {}\n            });\n        }\n        moveTo(_to) { }\n        tick() {\n            this._updateCoordinates();\n            this.moveTo(this.origin);\n        }\n        done() {\n            return abs(this.offset.y) < ANIMATED_SCROLLER_PRECISION && abs(this.offset.x) < ANIMATED_SCROLLER_PRECISION;\n        }\n        onEnd() {\n            this.moveTo(this.destination);\n            if (this.callback) {\n                this.callback.call();\n            }\n        }\n        setCoordinates(from, to) {\n            this.offset = {};\n            this.origin = from;\n            this.destination = to;\n        }\n        setCallback(callback) {\n            if (callback && isFunction$1(callback)) {\n                this.callback = callback;\n            }\n            else {\n                callback = undefined;\n            }\n        }\n        _updateCoordinates() {\n            this.offset = {\n                x: (this.destination.x - this.origin.x) / 4,\n                y: (this.destination.y - this.origin.y) / 4\n            };\n            this.origin = {\n                y: this.origin.y + this.offset.y,\n                x: this.origin.x + this.offset.x\n            };\n        }\n    }\n    class ScrollBar {\n        constructor(options) {\n            const horizontal = options.axis === 'x';\n            const orientation = (horizontal ? 'horizontal' : 'vertical');\n            const element = convertToHtml('<div class=\"km-touch-scrollbar km-' + orientation + '-scrollbar\" />');\n            extend(this, options, {\n                element: element,\n                elementSize: 0,\n                movable: new Movable(element),\n                scrollMovable: options.movable,\n                alwaysVisible: options.alwaysVisible,\n                size: horizontal ? 'width' : 'height'\n            });\n            this.scrollMovable.bind(CHANGE, this.refresh.bind(this));\n            this.container.appendChild(element);\n            if (options.alwaysVisible) {\n                this.show();\n            }\n        }\n        refresh() {\n            const axis = this.axis, dimension = this.dimension, paneSize = dimension.size, scrollMovable = this.scrollMovable, sizeRatio = paneSize / dimension.total;\n            let size = Math.round(paneSize * sizeRatio), position = Math.round(-scrollMovable[axis] * sizeRatio);\n            if (sizeRatio >= 1) {\n                this.element.style.display = 'none';\n            }\n            else {\n                this.element.style.display = '';\n            }\n            if (position + size > paneSize) {\n                size = paneSize - position;\n            }\n            else if (position < 0) {\n                size += position;\n                position = 0;\n            }\n            if (this.elementSize !== size) {\n                this.element.style[this.size] = size + 'px';\n                this.elementSize = size;\n            }\n            this.movable.moveAxis(axis, position);\n        }\n        show() {\n            this.element.style.opacity = SCROLLBAR_OPACITY;\n            this.element.style.visibility = 'visible';\n        }\n        hide() {\n            if (!this.alwaysVisible) {\n                this.element.style.opacity = 0;\n            }\n        }\n    }\n    const defaultScrollerOptions = {\n        name: 'Scroller',\n        zoom: false,\n        pullOffset: 140,\n        visibleScrollHints: false,\n        elastic: true,\n        useNative: false,\n        mousewheelScrolling: true,\n        avoidScrolling: () => false,\n        pullToRefresh: false,\n        messages: {\n            pullTemplate: 'Pull to refresh',\n            releaseTemplate: 'Release to refresh',\n            refreshTemplate: 'Refreshing'\n        }\n    };\n    // export class Scroller extends Class {\n    class Scroller extends Observable {\n        constructor(element, options) {\n            super();\n            this.element = element = element[0] || element;\n            this._initOptions(options);\n            this.events.push(PULL, SCROLL, RESIZE);\n            const hasScrolling = hasNativeScrolling();\n            this._native = this.options.useNative && hasScrolling;\n            const scrollHeader = convertToHtml('<div class=\"km-scroll-header\"/>');\n            if (this._native) {\n                addClass(element, 'km-native-scroller');\n                prepend(scrollHeader, element);\n                extend(this, {\n                    scrollElement: element,\n                    fixedContainer: element.children[0]\n                });\n                return;\n            }\n            element.style.overflow = 'hidden';\n            addClass(element, 'km-scroll-wrapper');\n            const scrollContainer = convertToHtml('<div class=\"km-scroll-container\"/>');\n            wrapInner(element, scrollContainer);\n            prepend(scrollHeader, element);\n            const inner = element.children[1], tapCapture = new TapCapture(element), movable = new Movable(inner), dimensions = new PaneDimensions({\n                element: inner,\n                container: element,\n                forcedEnabled: this.options.zoom\n            }), avoidScrolling = this.options.avoidScrolling, userEvents = new UserEvents(element, {\n                touchAction: 'none',\n                allowSelection: true,\n                preventDragEvent: true,\n                captureUpIfMoved: true,\n                multiTouch: this.options.zoom,\n                supportDoubleTap: this.options.supportDoubleTap,\n                start: (e) => {\n                    dimensions.refresh();\n                    const velocityX = abs(e.x.velocity), velocityY = abs(e.y.velocity), horizontalSwipe = velocityX * 2 >= velocityY, originatedFromFixedContainer = this.fixedContainer.contains(e.event.target), verticalSwipe = velocityY * 2 >= velocityX;\n                    if (!originatedFromFixedContainer && !avoidScrolling(e) && this.enabled && (dimensions.x.enabled && horizontalSwipe || dimensions.y.enabled && verticalSwipe)) {\n                        userEvents.capture();\n                    }\n                    else {\n                        userEvents.cancel();\n                    }\n                }\n            }), pane = new Pane({\n                movable: movable,\n                dimensions: dimensions,\n                userEvents: userEvents,\n                elastic: this.options.elastic\n            }), zoomSnapBack = new ZoomSnapBack({\n                movable: movable,\n                dimensions: dimensions,\n                userEvents: userEvents,\n                tapCapture: tapCapture\n            }), animatedScroller = new AnimatedScroller({\n                moveTo: (coordinates) => {\n                    this.scrollTo(coordinates.x, coordinates.y);\n                }\n            });\n            movable.bind(CHANGE, () => {\n                this.scrollTop = -movable.y;\n                this.scrollLeft = -movable.x;\n                this.trigger(SCROLL, {\n                    scrollTop: this.scrollTop,\n                    scrollLeft: this.scrollLeft\n                });\n            });\n            if (this.options.mousewheelScrolling) {\n                this._wheelScrollHandler = this._wheelScroll.bind(this);\n                on(element, 'wheel', this._wheelScrollHandler);\n            }\n            extend(this, {\n                movable: movable,\n                dimensions: dimensions,\n                zoomSnapBack: zoomSnapBack,\n                animatedScroller: animatedScroller,\n                userEvents: userEvents,\n                pane: pane,\n                tapCapture: tapCapture,\n                pulled: false,\n                enabled: true,\n                scrollElement: inner,\n                scrollTop: 0,\n                scrollLeft: 0,\n                fixedContainer: element.children[0]\n            });\n            this._initAxis('x');\n            this._initAxis('y');\n            this._wheelEnd = () => {\n                this._wheel = false;\n                this.userEvents.end(0, this._wheelY);\n            };\n            dimensions.refresh();\n            if (this.options.pullToRefresh) {\n                this._initPullToRefresh();\n            }\n            this.bind(this.events, this.options);\n        }\n        _initOptions(options) {\n            this.options = deepExtend({}, this.options, defaultScrollerOptions, options);\n        }\n        _wheelScroll(e) {\n            if (e.ctrlKey) {\n                return;\n            }\n            if (!this._wheel) {\n                this._wheel = true;\n                this._wheelY = 0;\n                this.userEvents.press(0, this._wheelY);\n            }\n            clearTimeout(this._wheelTimeout);\n            this._wheelTimeout = setTimeout(() => this._wheelEnd(), 50);\n            const delta = wheelDeltaY(e);\n            if (delta) {\n                this._wheelY += delta;\n                this.userEvents.move(0, this._wheelY);\n            }\n            e.preventDefault();\n        }\n        makeVirtual() {\n            this.dimensions.y.makeVirtual();\n        }\n        virtualSize(min, max) {\n            this.dimensions.y.virtualSize(min, max);\n        }\n        height() {\n            return this.dimensions.y.size;\n        }\n        scrollHeight() {\n            return this.scrollElement.scrollHeight;\n        }\n        scrollWidth() {\n            return this.scrollElement.scrollWidth;\n        }\n        _resize() {\n            if (!this._native) {\n                this.contentResized();\n            }\n        }\n        setOptions(options) {\n            this._initOptions(options);\n            if (options.pullToRefresh) {\n                this._initPullToRefresh();\n            }\n        }\n        reset() {\n            if (this._native) {\n                this.scrollElement.scrollTop(0);\n            }\n            else {\n                this.movable.moveTo({\n                    x: 0,\n                    y: 0\n                });\n                this._scale(1);\n            }\n        }\n        contentResized() {\n            this.dimensions.refresh();\n            if (this.pane.x.outOfBounds()) {\n                this.movable.moveAxis('x', this.dimensions.x.min);\n            }\n            if (this.pane.y.outOfBounds()) {\n                this.movable.moveAxis('y', this.dimensions.y.min);\n            }\n        }\n        zoomOut() {\n            const dimensions = this.dimensions;\n            dimensions.refresh();\n            this._scale(dimensions.fitScale);\n            this.movable.moveTo(dimensions.centerCoordinates());\n        }\n        enable() {\n            this.enabled = true;\n        }\n        disable() {\n            this.enabled = false;\n        }\n        scrollTo(x, y) {\n            if (this._native) {\n                this.scrollElement.scrollLeft(abs(x));\n                this.scrollElement.scrollTop(abs(y));\n            }\n            else {\n                this.dimensions.refresh();\n                this.movable.moveTo({\n                    x: x,\n                    y: y\n                });\n            }\n        }\n        animatedScrollTo(x, y, callback) {\n            let from, to;\n            if (this._native) {\n                this.scrollTo(x, y);\n            }\n            else {\n                from = {\n                    x: this.movable.x,\n                    y: this.movable.y\n                };\n                to = {\n                    x: x,\n                    y: y\n                };\n                this.animatedScroller.setCoordinates(from, to);\n                this.animatedScroller.setCallback(callback);\n                this.animatedScroller.start();\n            }\n        }\n        // kept for API compatibility, not used\n        pullHandled() {\n            // let this = this;\n            // removeClass(this.refreshHint, SCROLLER_REFRESH_CLASS);\n            // this.hintContainer.innerHTML = this.pullTemplate({}));\n            // this.yinertia.onEnd();\n            // this.xinertia.onEnd();\n            // this.userEvents.cancel();\n        }\n        destroy() {\n            const element = this.element;\n            off(element, 'wheel', this._wheelScrollHandler);\n            if (this.userEvents) {\n                this.userEvents.destroy();\n            }\n            if (this.tapCapture) {\n                this.tapCapture.destroy();\n            }\n        }\n        _scale(scale) {\n            this.dimensions.rescale(scale);\n            this.movable.scaleTo(scale);\n        }\n        _initPullToRefresh() {\n        }\n        // kept for API compatibility, not used\n        _dragEnd() {\n            // let this = this;\n            // if (!this.pulled) {\n            //     return;\n            // }\n            // this.pulled = false;\n            // removeClass(this.refreshHint, SCROLLER_RELEASE_CLASS);\n            // addClass(this.refreshHint, SCROLLER_REFRESH_CLASS);\n            // this.hintContainer.innerHTML = this.refreshTemplate({});\n            // this.yinertia.freeze(this.options.pullOffset / 2);\n            // this.trigger('pull');\n        }\n        // kept for API compatibility, not used\n        _paneChange() {\n            // let this = this;\n            // if (this.movable.y / OUT_OF_BOUNDS_FRICTION > this.options.pullOffset) {\n            //     if (!this.pulled) {\n            //         this.pulled = true;\n            //         this.refreshHint.removeClass(SCROLLER_REFRESH_CLASS).addClass(SCROLLER_RELEASE_CLASS);\n            //         this.hintContainer.html(this.releaseTemplate({}));\n            //         this.hintContainer.html(this.releaseTemplate({}));\n            //     }\n            // } else if (this.pulled) {\n            //     this.pulled = false;\n            //     this.refreshHint.removeClass(SCROLLER_RELEASE_CLASS);\n            //     this.hintContainer.html(this.pullTemplate({}));\n            // }\n        }\n        _initAxis(axis) {\n            const movable = this.movable, dimension = this.dimensions[axis], tapCapture = this.tapCapture, paneAxis = this.pane[axis], scrollBar = new ScrollBar({\n                axis: axis,\n                movable: movable,\n                dimension: dimension,\n                container: this.element,\n                alwaysVisible: this.options.visibleScrollHints\n            });\n            dimension.bind(CHANGE, () => {\n                scrollBar.refresh();\n            });\n            paneAxis.bind(CHANGE, () => {\n                scrollBar.show();\n            });\n            this[axis + 'inertia'] = new DragInertia({\n                axis: axis,\n                paneAxis: paneAxis,\n                movable: movable,\n                tapCapture: tapCapture,\n                userEvents: this.userEvents,\n                dimension: dimension,\n                elastic: this.options.elastic,\n                friction: this.options.friction || FRICTION,\n                velocityMultiplier: this.options.velocityMultiplier || VELOCITY_MULTIPLIER,\n                end: () => {\n                    scrollBar.hide();\n                    this.trigger('scrollEnd', {\n                        axis: axis,\n                        scrollTop: this.scrollTop,\n                        scrollLeft: this.scrollLeft\n                    });\n                }\n            });\n        }\n    }\n\n    function macOS() {\n        var _a;\n        return /Macintosh|iPhone|iPad/i.test(((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) || '');\n    }\n\n    class ScrollerTool extends EmptyTool {\n        constructor(toolService) {\n            super(toolService);\n            const diagram = this.toolService.diagram, canvas = diagram.canvas;\n            const friction = diagram._mobileOS() ? FRICTION_MOBILE : FRICTION$1;\n            const scroller = diagram.scroller = this.scroller = new Scroller(diagram.scrollable, {\n                friction: friction,\n                velocityMultiplier: VELOCITY_MULTIPLIER$1,\n                mousewheelScrolling: false,\n                zoom: false,\n                scroll: this._move.bind(this)\n            });\n            if (canvas.translate) {\n                this.movableCanvas = new Movable(canvas.element);\n            }\n            const virtualScroll = function (dimension, min, max) {\n                dimension.makeVirtual();\n                dimension.virtualSize(min || SCROLL_MIN, max || SCROLL_MAX);\n            };\n            virtualScroll(scroller.dimensions.x);\n            virtualScroll(scroller.dimensions.y);\n            scroller.disable();\n        }\n        tryActivate(_p, meta) {\n            const toolService = this.toolService;\n            const options = toolService.diagram.options.pannable;\n            const macCmd = meta.metaKey && macOS();\n            let enabled = meta.ctrlKey || macCmd;\n            if (defined(options.key)) {\n                if (!options.key || options.key === 'none') {\n                    enabled = noMeta(meta) && !defined(toolService.hoveredItem);\n                }\n                else {\n                    enabled = meta[options.key + 'Key'];\n                    enabled = enabled || (options.key === 'ctrl' && macCmd);\n                }\n            }\n            return options !== false && enabled && !defined(toolService.hoveredAdorner) && !defined(toolService._hoveredConnector);\n        }\n        start() {\n            this.scroller.enable();\n        }\n        move() {\n        } // the tool itself should not handle the scrolling. Let kendo scroller take care of this part. Check _move\n        _move(args) {\n            const diagram = this.toolService.diagram, canvas = diagram.canvas;\n            let scrollPos = new Point(args.scrollLeft, args.scrollTop);\n            if (canvas.translate) {\n                diagram._storePan(scrollPos.times(-1));\n                this.movableCanvas.moveTo(scrollPos);\n                canvas.translate(scrollPos.x, scrollPos.y);\n            }\n            else {\n                scrollPos = scrollPos.plus(diagram._pan.times(-1));\n            }\n            diagram.trigger(PAN, { pan: scrollPos });\n        }\n        end() {\n            this.scroller.disable();\n        }\n        getCursor() {\n            return Cursors.move;\n        }\n    }\n\n    class SelectionTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n        }\n        tryActivate(_p, meta) {\n            const toolService = this.toolService;\n            const selectable = toolService.diagram.options.selectable;\n            let enabled = selectable && selectable.multiple !== false;\n            if (enabled) {\n                if (selectable.key && selectable.key !== 'none') {\n                    enabled = meta[selectable.key + 'Key'];\n                }\n                else {\n                    enabled = noMeta(meta);\n                }\n            }\n            return enabled && !defined(toolService.hoveredItem) && !defined(toolService.hoveredAdorner);\n        }\n        start(p) {\n            const diagram = this.toolService.diagram;\n            diagram.deselect();\n            diagram.selector.start(p);\n        }\n        move(p) {\n            const diagram = this.toolService.diagram;\n            diagram.selector.move(p);\n        }\n        end(_p, meta) {\n            const diagram = this.toolService.diagram, hoveredItem = this.toolService.hoveredItem;\n            const rect = diagram.selector.bounds();\n            if ((!hoveredItem || !hoveredItem.isSelected) && !meta.ctrlKey) {\n                diagram.deselect();\n            }\n            if (!rect.isEmpty()) {\n                diagram.selectArea(rect);\n            }\n            diagram.selector.end();\n        }\n        getCursor() {\n            return Cursors.arrow;\n        }\n    }\n\n    function testKey(key, str) {\n        return str.charCodeAt(0) === key || str.toUpperCase().charCodeAt(0) === key;\n    }\n\n    class ConnectionEditUnit {\n        constructor(item, redoSource, redoTarget) {\n            this.item = item;\n            this._redoSource = redoSource;\n            this._redoTarget = redoTarget;\n            if (defined(redoSource)) {\n                this._undoSource = item.source();\n            }\n            if (defined(redoTarget)) {\n                this._undoTarget = item.target();\n            }\n            this.title = ConnectionEditing;\n        }\n        undo() {\n            if (this._undoSource !== undefined) {\n                this.item._updateConnector(this._undoSource, SOURCE);\n            }\n            if (this._undoTarget !== undefined) {\n                this.item._updateConnector(this._undoTarget, TARGET);\n            }\n            this.item.updateModel();\n        }\n        redo() {\n            if (this._redoSource !== undefined) {\n                this.item._updateConnector(this._redoSource, SOURCE);\n            }\n            if (this._redoTarget !== undefined) {\n                this.item._updateConnector(this._redoTarget, TARGET);\n            }\n            this.item.updateModel();\n        }\n    }\n\n    const defaultOptions$1 = {\n        hover: {\n            stroke: {}\n        },\n        startCap: NONE,\n        endCap: NONE,\n        points: [],\n        selectable: true,\n        fromConnector: AUTO,\n        toConnector: AUTO\n    };\n    /**\n     * The visual link between two Shapes through the intermediate of Connectors.\n     */\n    class Connection extends DiagramElement {\n        /**\n         * Creates a new Connection instance.\n         * @param from The source endpoint (Shape, Connector, or Point)\n         * @param to The target endpoint (Shape, Connector, or Point)\n         * @param options Configuration options for the connection\n         */\n        constructor(from, to, options) {\n            options = deepExtend({}, defaultOptions$1, options);\n            super(options);\n            /** @hidden */\n            this.name = 'Connection';\n            this.updateOptionsFromModel();\n            this._initRouter();\n            this.path = new Polyline(this.options);\n            this.path.fill(TRANSPARENT);\n            this.visual.append(this.path);\n            this._sourcePoint = this._targetPoint = new Point();\n            this._setSource(from);\n            this._setTarget(to);\n            this.content(this.options.content);\n            this.definers = [];\n            if (defined(options) && options.points) {\n                this.points(options.points);\n            }\n        }\n        /** @hidden */\n        _setOptionsFromModel(model) {\n            this.updateOptionsFromModel(model || this.dataItem);\n        }\n        /**\n         * Updates the connection options from the model data.\n         * @param model The model data to extract options from\n         */\n        updateOptionsFromModel(model) {\n            if (this.diagram && this.diagram._isEditable) {\n                const dataMap = this.diagram._dataMap;\n                const options = filterConnectionDataItem(model || this.dataItem);\n                if (model) {\n                    if (defined(options.from)) {\n                        let from = dataMap[options.from];\n                        if (from && defined(options.fromConnector)) {\n                            from = from.getConnector(options.fromConnector);\n                        }\n                        this.source(from);\n                    }\n                    else if (defined(options.fromX) && defined(options.fromY)) {\n                        this.source(new Point(options.fromX, options.fromY));\n                    }\n                    if (defined(options.to)) {\n                        let to = dataMap[options.to];\n                        if (to && defined(options.toConnector)) {\n                            to = to.getConnector(options.toConnector);\n                        }\n                        this.target(to);\n                    }\n                    else if (defined(options.toX) && defined(options.toY)) {\n                        this.target(new Point(options.toX, options.toY));\n                    }\n                    if (defined(options.type) && this.type() !== options.type) {\n                        this.points([]);\n                        this.type(options.type);\n                    }\n                    this.dataItem = model;\n                    this._template();\n                    this.redraw(this.options);\n                }\n                else {\n                    this.options = deepExtend({}, options, this.options);\n                }\n            }\n        }\n        /**\n         * Updates the connection's model data and optionally synchronizes changes.\n         * @param syncChanges Whether to synchronize changes immediately\n         */\n        updateModel(syncChanges) {\n            if (this.diagram && this.diagram._isEditable) {\n                this.diagram.updateConnectionModel(this, syncChanges);\n            }\n        }\n        /**\n         * Gets the Point where the source of the connection resides.\n         * If the endpoint is Auto-connector the location of the resolved connector will be returned.\n         * If the endpoint is floating the location of the endpoint is returned.\n         * @returns The source point of the connection\n         */\n        sourcePoint() {\n            return this._resolvedSourceConnector ? this._resolvedSourceConnector.position() : this._sourcePoint;\n        }\n        /** @hidden */\n        _setSource(source) {\n            const shapeSource = source instanceof Shape;\n            const defaultConnector = this.options.fromConnector || AUTO;\n            let dataItem;\n            if (shapeSource && !source.getConnector(defaultConnector)) {\n                return;\n            }\n            if (source !== undefined) {\n                this.from = source;\n            }\n            this._removeFromSourceConnector();\n            if (source === null) { // detach\n                if (this.sourceConnector) {\n                    this._sourcePoint = (this._resolvedSourceConnector || this.sourceConnector).position();\n                    this._clearSourceConnector();\n                    this._setFromOptions(null, this._sourcePoint);\n                }\n            }\n            else if (source instanceof Connector) {\n                dataItem = source.shape.dataItem;\n                if (dataItem) {\n                    this._setFromOptions(dataItem.id);\n                }\n                this.sourceConnector = source;\n                this.sourceConnector.connections.push(this);\n            }\n            else if (source instanceof Point) {\n                this._setFromOptions(null, source);\n                this._sourcePoint = source;\n                if (this.sourceConnector) {\n                    this._clearSourceConnector();\n                }\n            }\n            else if (shapeSource) {\n                dataItem = source.dataItem;\n                if (dataItem) {\n                    this._setFromOptions(dataItem.id);\n                }\n                this.sourceConnector = source.getConnector(defaultConnector);\n                this.sourceConnector.connections.push(this);\n            }\n        }\n        /**\n         * Gets or sets the source endpoint of the connection.\n         * @param source The source endpoint (Shape, Connector, or Point) to set. If not provided, returns the current source.\n         * @param undoable Whether this operation should be undoable\n         * @returns The current source when used as a getter\n         */\n        source(source, undoable) {\n            if (isDefined(source)) {\n                if (undoable && this.diagram) {\n                    this.diagram.undoRedoService.addCompositeItem(new ConnectionEditUnit(this, source));\n                }\n                this._setSource(source);\n                this.refresh();\n            }\n            return this.sourceConnector ? this.sourceConnector : this._sourcePoint;\n        }\n        /** @hidden */\n        _setFromOptions(from, fromPoint) {\n            this.options.from = from;\n            if (fromPoint) {\n                this.options.fromX = fromPoint.x;\n                this.options.fromY = fromPoint.y;\n            }\n            else {\n                this.options.fromX = null;\n                this.options.fromY = null;\n            }\n        }\n        /**\n         * Gets or sets the PathDefiner of the sourcePoint.\n         * The left part of this definer is always null since it defines the source tangent.\n         * @param value The PathDefiner to set. If not provided, returns the current source definer.\n         * @returns The source definer when used as a getter\n         */\n        sourceDefiner(value) {\n            if (value) {\n                if (value instanceof PathDefiner) {\n                    value.left = null;\n                    this._sourceDefiner = value;\n                    this.source(value.point); // refresh implicit here\n                }\n                else {\n                    throw new Error('The sourceDefiner needs to be a PathDefiner.');\n                }\n            }\n            else {\n                if (!this._sourceDefiner) {\n                    this._sourceDefiner = new PathDefiner(this.sourcePoint(), null, null);\n                }\n                return this._sourceDefiner;\n            }\n        }\n        /**\n         * Gets the Point where the target of the connection resides.\n         * @returns The target point of the connection\n         */\n        targetPoint() {\n            return this._resolvedTargetConnector ? this._resolvedTargetConnector.position() : this._targetPoint;\n        }\n        /** @hidden */\n        _setTarget(target) {\n            const shapeTarget = target instanceof Shape;\n            const defaultConnector = this.options.toConnector || AUTO;\n            let dataItem;\n            if (shapeTarget && !target.getConnector(defaultConnector)) {\n                return;\n            }\n            if (target !== undefined) {\n                this.to = target;\n            }\n            this._removeFromTargetConnector();\n            if (target === null) { // detach\n                if (this.targetConnector) {\n                    this._targetPoint = (this._resolvedTargetConnector || this.targetConnector).position();\n                    this._clearTargetConnector();\n                    this._setToOptions(null, this._targetPoint);\n                }\n            }\n            else if (target instanceof Connector) {\n                dataItem = target.shape.dataItem;\n                if (dataItem) {\n                    this._setToOptions(dataItem.id);\n                }\n                this.targetConnector = target;\n                this.targetConnector.connections.push(this);\n            }\n            else if (target instanceof Point) {\n                this._setToOptions(null, target);\n                this._targetPoint = target;\n                if (this.targetConnector) {\n                    this._clearTargetConnector();\n                }\n            }\n            else if (shapeTarget) {\n                dataItem = target.dataItem;\n                if (dataItem) {\n                    this._setToOptions(dataItem.id);\n                }\n                this.targetConnector = target.getConnector(defaultConnector);\n                this.targetConnector.connections.push(this);\n            }\n        }\n        /**\n         * Gets or sets the target endpoint of the connection.\n         * @param target The target endpoint (Shape, Connector, or Point) to set. If not provided, returns the current target.\n         * @param undoable Whether this operation should be undoable\n         * @returns The current target when used as a getter\n         */\n        target(target, undoable) {\n            if (isDefined(target)) {\n                if (undoable && this.diagram) {\n                    this.diagram.undoRedoService.addCompositeItem(new ConnectionEditUnit(this, undefined, target));\n                }\n                this._setTarget(target);\n                this.refresh();\n            }\n            return this.targetConnector ? this.targetConnector : this._targetPoint;\n        }\n        /** @hidden */\n        _setToOptions(to, toPoint) {\n            this.options.to = to;\n            if (toPoint) {\n                this.options.toX = toPoint.x;\n                this.options.toY = toPoint.y;\n            }\n            else {\n                this.options.toX = null;\n                this.options.toY = null;\n            }\n        }\n        /**\n         * Gets or sets the PathDefiner of the targetPoint.\n         * The right part of this definer is always null since it defines the target tangent.\n         * @param value The PathDefiner to set. If not provided, returns the current target definer.\n         * @returns The target definer when used as a getter\n         */\n        targetDefiner(value) {\n            if (value) {\n                if (value instanceof PathDefiner) {\n                    value.right = null;\n                    this._targetDefiner = value;\n                    this.target(value.point); // refresh implicit here\n                }\n                else {\n                    throw new Error('The sourceDefiner needs to be a PathDefiner.');\n                }\n            }\n            else {\n                if (!this._targetDefiner) {\n                    this._targetDefiner = new PathDefiner(this.targetPoint(), null, null);\n                }\n                return this._targetDefiner;\n            }\n        }\n        /** @hidden */\n        _updateConnectors() {\n            this._updateConnector(this.source(), 'source');\n            this._updateConnector(this.target(), 'target');\n        }\n        /** @hidden */\n        _updateConnector(instance, name) {\n            const diagram = this.diagram;\n            if (instance instanceof Connector && !diagram.getShapeById(instance.shape.id)) {\n                const dataItem = instance.shape.dataItem;\n                const connectorName = instance.options.name;\n                const setNewTarget = () => {\n                    const shape = diagram._dataMap[dataItem.id];\n                    instance = shape.getConnector(connectorName);\n                    this[name](instance, false);\n                    this.updateModel();\n                };\n                if (diagram._dataMap[dataItem.id]) {\n                    setNewTarget();\n                }\n                else {\n                    const inactiveItem = diagram._inactiveShapeItems.getByUid(dataItem.uid);\n                    if (inactiveItem) {\n                        diagram._deferredConnectionUpdates.push(inactiveItem.onActivate(setNewTarget));\n                    }\n                }\n            }\n            else {\n                this[name](instance, false);\n            }\n        }\n        /**\n         * Gets or sets the content of the connection.\n         * @param content The content to set. If not provided, returns the current content.\n         * @returns The current content when used as a getter\n         */\n        content(content) {\n            const current = this.options.content.text;\n            const result = this._content(content);\n            if (defined(content)) {\n                if (current !== result) {\n                    this._contentVisual._measured = false;\n                }\n                this._alignContent();\n            }\n            return result;\n        }\n        /** @hidden */\n        _createContentVisual(options) {\n            let visual;\n            const hasVisual = options.visual;\n            const hasTemplate = options.template;\n            const templateOptions = extend$1({}, options, {\n                dataItem: this.dataItem || options.dataItem,\n            });\n            const template = getTemplate(templateOptions);\n            if (hasVisual) {\n                const visualResult = isFunction$1(template) ?\n                    template.call(this, templateOptions) :\n                    null;\n                visual = visualResult;\n            }\n            else if (hasTemplate) {\n                const templateResult = isFunction$1(template) ?\n                    template.call(this, templateOptions.dataItem) :\n                    null;\n                if (isFunction$1(templateResult)) {\n                    visual = templateResult;\n                }\n                else if (isString$1(templateResult)) {\n                    visual = new TextBlock(extend$1({}, templateOptions, {\n                        text: templateResult\n                    }));\n                }\n            }\n            else if (options.text) {\n                visual = new TextBlock(templateOptions);\n            }\n            if (visual) {\n                this._contentVisual = visual;\n                visual._includeInBBox = false;\n                this.visual.append(visual);\n            }\n            return visual;\n        }\n        /** @hidden */\n        _updateContentVisual(options) {\n            if (isFunction$1(options.visual)) {\n                this.visual.remove(this._contentVisual);\n                this._createContentVisual(options);\n            }\n            else {\n                this._contentVisual.redraw(options);\n            }\n        }\n        /** @hidden */\n        _alignContent() {\n            if (this._contentVisual) {\n                let offset = CONNECTION_CONTENT_OFFSET;\n                const points = this.allPoints();\n                let endIdx = Math.floor(points.length / 2);\n                let startIdx = endIdx - 1;\n                while (startIdx > 0 && points[startIdx].equals(points[endIdx])) {\n                    startIdx--;\n                    endIdx++;\n                }\n                let endPoint = points[endIdx];\n                let startPoint = points[startIdx];\n                const boundingBox = this._contentVisual._measure();\n                const width = boundingBox.width;\n                const height = boundingBox.height;\n                let alignToPath = points.length % 2 === 0;\n                const distance = startPoint.distanceTo(endPoint);\n                if (alignToPath && points.length > 2 && distance > 0 &&\n                    ((startPoint.y === endPoint.y && distance < width) || (startPoint.x === endPoint.x && distance < height))) {\n                    alignToPath = false;\n                    offset = 0;\n                }\n                let point;\n                if (alignToPath) {\n                    const angle = kendo_drawing_cmn_chunk_js.q(Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x));\n                    point = new Point((endPoint.x - startPoint.x) / 2 + startPoint.x, (endPoint.y - startPoint.y) / 2 + startPoint.y);\n                    if (Math.abs(angle) === 90) {\n                        point.x += offset;\n                        point.y -= height / 2;\n                    }\n                    else if (angle % 180 === 0) {\n                        point.x -= width / 2;\n                        point.y -= height + offset;\n                    }\n                    else if (angle < -90 || (0 < angle && angle < 90)) {\n                        point.y -= height;\n                    }\n                    else if (angle < 0 || angle > 90) {\n                        point.x -= width;\n                        point.y -= height;\n                    }\n                }\n                else {\n                    const midIdx = Math.floor(points.length / 2);\n                    point = points[midIdx].clone();\n                    startPoint = points[midIdx - 1];\n                    endPoint = points[midIdx + 1];\n                    const offsetX = startPoint.x <= point.x && endPoint.x <= point.x ? offset : -boundingBox.width - offset;\n                    const offsetY = startPoint.y <= point.y && endPoint.y <= point.y ? offset : -boundingBox.height - offset;\n                    point.x += offsetX;\n                    point.y += offsetY;\n                }\n                this._contentVisual.position(point);\n            }\n        }\n        /**\n         * Selects or deselects this connection.\n         * @param value True to select, false to deselect the connection\n         * @returns True if the selection state changed, false otherwise\n         */\n        select(value) {\n            const diagram = this.diagram;\n            let selected, deselected;\n            if (this._canSelect()) {\n                if (this.isSelected !== value) {\n                    this.isSelected = value;\n                    selected = [];\n                    deselected = [];\n                    if (this.isSelected) {\n                        this.adorner = new ConnectionEditAdorner(this, this.options.selection);\n                        diagram._adorn(this.adorner, true);\n                        diagram._selectedItems.push(this);\n                        selected.push(this);\n                    }\n                    else {\n                        if (this.adorner) {\n                            diagram._adorn(this.adorner, false);\n                            remove(diagram._selectedItems, this);\n                            this.adorner = undefined;\n                            deselected.push(this);\n                        }\n                    }\n                    if (this.adorner) {\n                        this.adorner.refresh();\n                    }\n                    if (!diagram._internalSelection) {\n                        diagram._selectionChanged(selected, deselected);\n                    }\n                    return true;\n                }\n            }\n        }\n        /**\n         * Gets or sets the bounds of this connection.\n         * @param value A Rect object to set as bounds. If not provided, returns the current bounds.\n         * @returns The bounds of the connection\n         * @remarks This is automatically set in the refresh() method.\n         */\n        bounds(value) {\n            if (value && !isString$1(value)) {\n                this._bounds = value;\n            }\n            else {\n                return this._bounds;\n            }\n        }\n        /**\n         * Gets or sets the connection type (see ConnectionType enumeration).\n         * @param value A ConnectionType value to set. If not provided, returns the current type.\n         * @returns The connection type\n         */\n        type(value) {\n            const options = this.options;\n            if (value) {\n                if (value !== options.type) {\n                    options.type = value;\n                    this._initRouter();\n                    this.refresh();\n                }\n            }\n            else {\n                return options.type;\n            }\n        }\n        /** @hidden */\n        _initRouter() {\n            const type = (this.options.type || '').toLowerCase();\n            if (type === CASCADING) {\n                this._router = new CascadingRouter(this);\n            }\n            else {\n                this._router = new PolylineRouter(this);\n            }\n        }\n        /**\n         * Gets or sets the collection of intermediate points.\n         * The 'allPoints()' property will return all the points.\n         * The 'definers' property returns the definers of the intermediate points.\n         * The 'sourceDefiner' and 'targetDefiner' return the definers of the endpoints.\n         * @param value Array of Points or point-like objects to set as intermediate points. If not provided, returns the current points.\n         * @returns Array of intermediate points when used as a getter\n         */\n        points(value) {\n            if (value) {\n                this.definers = [];\n                for (let i = 0; i < value.length; i++) {\n                    const definition = value[i];\n                    if (definition instanceof Point) {\n                        this.definers.push(new PathDefiner(definition));\n                    }\n                    else if (Object.prototype.hasOwnProperty.call(definition, 'x') && Object.prototype.hasOwnProperty.call(definition, 'y')) { // e.g. Clipboard does not preserve the Point definition and turned into an Object\n                        this.definers.push(new PathDefiner(new Point(definition.x, definition.y)));\n                    }\n                    else {\n                        throw new Error('A Connection point needs to be a Point or an object with x and y properties.');\n                    }\n                }\n            }\n            else {\n                const pts = [];\n                if (isDefined(this.definers)) {\n                    for (let k = 0; k < this.definers.length; k++) {\n                        pts.push(this.definers[k].point);\n                    }\n                }\n                return pts;\n            }\n        }\n        /**\n         * Gets all the points of this connection. This is the combination of the sourcePoint, the points and the targetPoint.\n         * @returns Array of all points including source, intermediate, and target points\n         */\n        allPoints() {\n            const pts = [this.sourcePoint()];\n            if (this.definers) {\n                for (let k = 0; k < this.definers.length; k++) {\n                    pts.push(this.definers[k].point);\n                }\n            }\n            pts.push(this.targetPoint());\n            return pts;\n        }\n        /**\n         * Refreshes the connection's visual representation.\n         * Resolves connectors, refreshes the path, aligns content, and updates adorners.\n         */\n        refresh() {\n            this._resolveConnectors();\n            this._refreshPath();\n            this._alignContent();\n            if (this.adorner) {\n                this.adorner.refresh();\n            }\n        }\n        /** @hidden */\n        _resolveConnectors() {\n            let sourcePoint, targetPoint, sourceConnectors, targetConnectors;\n            const source = this.source(), target = this.target();\n            if (source instanceof Point) {\n                sourcePoint = source;\n            }\n            else if (source instanceof Connector) {\n                if (isAutoConnector(source)) {\n                    sourceConnectors = source.shape.connectors;\n                }\n                else {\n                    sourceConnectors = [source];\n                }\n            }\n            if (target instanceof Point) {\n                targetPoint = target;\n            }\n            else if (target instanceof Connector) {\n                if (isAutoConnector(target)) {\n                    targetConnectors = target.shape.connectors;\n                }\n                else {\n                    targetConnectors = [target];\n                }\n            }\n            if (sourcePoint) {\n                if (targetConnectors) {\n                    this._resolvedTargetConnector = closestConnector(sourcePoint, targetConnectors);\n                }\n            }\n            else if (sourceConnectors) {\n                if (targetPoint) {\n                    this._resolvedSourceConnector = closestConnector(targetPoint, sourceConnectors);\n                }\n                else if (targetConnectors) {\n                    this._resolveAutoConnectors(sourceConnectors, targetConnectors);\n                }\n            }\n        }\n        /** @hidden */\n        _resolveAutoConnectors(sourceConnectors, targetConnectors) {\n            let minNonConflict = MAXINT;\n            let minDist = MAXINT;\n            let minNonConflictSource, minNonConflictTarget;\n            let sourcePoint, targetPoint;\n            let minSource, minTarget;\n            let sourceConnector, targetConnector;\n            let sourceIdx, targetIdx;\n            let dist;\n            for (sourceIdx = 0; sourceIdx < sourceConnectors.length; sourceIdx++) {\n                sourceConnector = sourceConnectors[sourceIdx];\n                if (!isAutoConnector(sourceConnector)) {\n                    sourcePoint = sourceConnector.position();\n                    for (targetIdx = 0; targetIdx < targetConnectors.length; targetIdx++) {\n                        targetConnector = targetConnectors[targetIdx];\n                        if (!isAutoConnector(targetConnector)) {\n                            targetPoint = targetConnector.position();\n                            dist = Math.round(sourcePoint.distanceTo(targetPoint));\n                            if (dist < minNonConflict && this.diagram && this._testRoutePoints(sourcePoint, targetPoint, sourceConnector, targetConnector)) {\n                                minNonConflict = dist;\n                                minNonConflictSource = sourceConnector;\n                                minNonConflictTarget = targetConnector;\n                            }\n                            if (dist < minDist) {\n                                minSource = sourceConnector;\n                                minTarget = targetConnector;\n                                minDist = dist;\n                            }\n                        }\n                    }\n                }\n            }\n            if (minNonConflictSource) {\n                minSource = minNonConflictSource;\n                minTarget = minNonConflictTarget;\n            }\n            this._resolvedSourceConnector = minSource;\n            this._resolvedTargetConnector = minTarget;\n        }\n        /** @hidden */\n        _testRoutePoints(sourcePoint, targetPoint, sourceConnector, targetConnector) {\n            const router = this._router;\n            let passRoute = true;\n            if (router instanceof CascadingRouter) {\n                const points = router.routePoints(sourcePoint, targetPoint, sourceConnector, targetConnector), exclude = this._getRouteExclude(sourcePoint, targetPoint, sourceConnector.shape, targetConnector.shape);\n                let start, end, rect;\n                points.unshift(sourcePoint);\n                points.push(targetPoint);\n                for (let idx = 1; idx < points.length; idx++) {\n                    start = points[idx - 1];\n                    end = points[idx];\n                    rect = new Rect(Math.min(start.x, end.x), Math.min(start.y, end.y), Math.abs(start.x - end.x), Math.abs(start.y - end.y));\n                    if (rect.width > 0) {\n                        rect.x++;\n                        rect.width -= 2;\n                    }\n                    if (rect.height > 0) {\n                        rect.y++;\n                        rect.height -= 2;\n                    }\n                    if (!rect.isEmpty() && this.diagram._shapesQuadTree.hitTestRect(rect, exclude)) {\n                        passRoute = false;\n                        break;\n                    }\n                }\n            }\n            return passRoute;\n        }\n        /** @hidden */\n        _getRouteExclude(sourcePoint, targetPoint, sourceShape, targetShape) {\n            const exclude = [];\n            if (this._isPointInsideShape(sourcePoint, sourceShape)) {\n                exclude.push(sourceShape);\n            }\n            if (this._isPointInsideShape(targetPoint, targetShape)) {\n                exclude.push(targetShape);\n            }\n            return exclude;\n        }\n        /** @hidden */\n        _isPointInsideShape(point, shape) {\n            const bounds = shape.bounds(), angle = shape.rotate().angle, boundsX = bounds.x, boundsY = bounds.y;\n            const rotatedPoint = point.clone().rotate(angle, bounds.center());\n            const pointX = rotatedPoint.x;\n            const pointY = rotatedPoint.y;\n            return pointX > boundsX && pointX < (boundsX + bounds.width) && pointY > boundsY && pointY < (boundsY + bounds.height);\n        }\n        /**\n         * Redraws the connection with new options.\n         * @param options The options to apply when redrawing the connection\n         */\n        redraw(options) {\n            if (options) {\n                this.options = deepExtend({}, this.options, options);\n                const points = this.options.points;\n                if (defined(points) && points.length > 0) {\n                    this.points(points);\n                    this._refreshPath();\n                }\n                if ((options && options.content) || options.text) {\n                    this.content(options.content);\n                }\n                this.path.redraw({\n                    fill: options.fill,\n                    stroke: options.stroke,\n                    startCap: options.startCap,\n                    endCap: options.endCap\n                });\n            }\n        }\n        /**\n         * Returns a clone of this connection.\n         * @returns A new Connection instance that is a copy of this connection\n         */\n        clone() {\n            const json = this.serialize();\n            if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n                json.options.dataItem = this.diagram.options.cloneDataItem(this.dataItem);\n            }\n            return new Connection(this.from, this.to, json.options);\n        }\n        /**\n         * Returns a serialized connection in JSON format. Consists of the options and the dataItem.\n         * @returns Serialized connection object containing options, endpoints, and data\n         */\n        serialize() {\n            const from = this.from.toJSON ? this.from.toJSON : this.from.toString(), to = this.to.toJSON ? this.to.toJSON : this.to.toString();\n            const json = deepExtend({}, {\n                options: this.options,\n                from: from,\n                to: to\n            });\n            if (defined(this.dataItem)) {\n                json.dataItem = this.dataItem.toString();\n            }\n            json.options.points = this.points();\n            return json;\n        }\n        /**\n         * @hidden\n         *\n         * Returns whether the given Point or Rect hits this connection.\n         *\n         * @param value\n         * @returns {Connection}\n         * @private\n         */\n        _hitTest(value) {\n            if (this.visible()) {\n                const p = new Point(value.x, value.y), from = this.sourcePoint(), to = this.targetPoint();\n                if (value.isEmpty && !value.isEmpty() && value.contains(from) && value.contains(to)) {\n                    return this;\n                }\n                if (this._router.hitTest(p)) {\n                    return this;\n                }\n            }\n        }\n        /** @hidden */\n        _hover(value) {\n            let color = (this.options.stroke || {}).color;\n            if (value && isDefined(this.options.hover.stroke.color)) {\n                color = this.options.hover.stroke.color;\n            }\n            this.path.redraw({\n                stroke: {\n                    color: color\n                }\n            });\n        }\n        /** @hidden */\n        _refreshPath() {\n            if (!defined(this.path)) {\n                return;\n            }\n            this._drawPath();\n            this.bounds(this._router.getBounds());\n        }\n        /** @hidden */\n        _drawPath() {\n            if (this._router) {\n                this._router.route(); // sets the intermediate points\n            }\n            const source = this.sourcePoint();\n            const target = this.targetPoint();\n            const points = this.points();\n            this.path.redraw({\n                points: [source].concat(points, [target])\n            });\n        }\n        /** @hidden */\n        _clearSourceConnector() {\n            this.sourceConnector = undefined;\n            this._resolvedSourceConnector = undefined;\n        }\n        /** @hidden */\n        _clearTargetConnector() {\n            this.targetConnector = undefined;\n            this._resolvedTargetConnector = undefined;\n        }\n        /** @hidden */\n        _removeFromSourceConnector() {\n            if (this.sourceConnector) {\n                remove(this.sourceConnector.connections, this);\n            }\n        }\n        /** @hidden */\n        _removeFromTargetConnector() {\n            if (this.targetConnector) {\n                remove(this.targetConnector.connections, this);\n            }\n        }\n        /**\n         * Converts the connection to a JSON representation for serialization.\n         * @returns Object containing the connection's endpoints information\n         */\n        toJSON() {\n            let from, to, point;\n            if (this.from && this.from.toJSON) {\n                from = this.from.toJSON();\n            }\n            else {\n                point = this._sourcePoint;\n                from = {\n                    x: point.x,\n                    y: point.y\n                };\n            }\n            if (this.to && this.to.toJSON) {\n                to = this.to.toJSON();\n            }\n            else {\n                point = this._targetPoint;\n                to = {\n                    x: point.x,\n                    y: point.y\n                };\n            }\n            return {\n                from: from,\n                to: to\n            };\n        }\n    }\n\n    const round = kendo_drawing_cmn_chunk_js.r;\n    function hitTestShapeConnectors(shape, point) {\n        let connector, position, rect;\n        for (let idx = 0; idx < shape.connectors.length; idx++) {\n            connector = shape.connectors[idx];\n            position = connector.position();\n            rect = new Rect(position.x, position.y);\n            rect.inflate(HIT_TEST_DISTANCE, HIT_TEST_DISTANCE);\n            if (rect.contains(point)) {\n                return connector;\n            }\n        }\n    }\n    /**\n     * The service managing the tools.\n     *\n     * @type {*}\n     */\n    class ToolService {\n        constructor(diagram) {\n            this.diagram = diagram;\n            this.tools = [\n                new ScrollerTool(this),\n                new ConnectionEditTool(this),\n                new ConnectionTool(this),\n                new SelectionTool(this),\n                new PointerTool(this)\n            ]; // the order matters.\n            this.activeTool = undefined;\n        }\n        start(p, meta, nativeEvent) {\n            meta = deepExtend({}, meta);\n            if (this.activeTool) {\n                this.activeTool.end(p, meta);\n            }\n            this._updateHoveredItem(p, meta, nativeEvent);\n            this._activateTool(p, meta);\n            this.activeTool.start(p, meta, nativeEvent);\n            this._updateCursor(p);\n            this.diagram.focus();\n            this.diagram.canvas.surface.suspendTracking();\n            this.startPoint = p;\n            return true;\n        }\n        move(p, meta, nativeEvent) {\n            meta = deepExtend({}, meta);\n            let updateHovered = true;\n            if (this.activeTool) {\n                updateHovered = this.activeTool.move(p, meta, nativeEvent);\n            }\n            if (updateHovered) {\n                this._updateHoveredItem(p, meta, nativeEvent);\n            }\n            this._updateCursor(p);\n            return true;\n        }\n        end(point, meta, nativeEvent) {\n            meta = deepExtend({}, meta);\n            if (this.activeTool) {\n                this.activeTool.end(point, meta, nativeEvent);\n            }\n            this.diagram.canvas.surface.resumeTracking();\n            this.activeTool = undefined;\n            this._updateCursor(point);\n            return true;\n        }\n        keyDown(key, meta) {\n            const diagram = this.diagram;\n            meta = deepExtend({ ctrlKey: false, metaKey: false, altKey: false }, meta);\n            if ((meta.ctrlKey || meta.metaKey) && !meta.altKey) { // ctrl or option\n                if (testKey(key, 'a')) { // A: select all\n                    diagram.selectAll();\n                    diagram._destroyToolBar();\n                    return true;\n                }\n                else if (testKey(key, 'z')) { // Z: undo\n                    diagram.undo();\n                    diagram._destroyToolBar();\n                    return true;\n                }\n                else if (testKey(key, 'y')) { // y: redo\n                    diagram.redo();\n                    diagram._destroyToolBar();\n                    return true;\n                }\n                else if (testKey(key, 'c')) {\n                    diagram.copy();\n                    diagram._destroyToolBar();\n                }\n                else if (testKey(key, 'x')) {\n                    diagram.cut();\n                    diagram._destroyToolBar();\n                }\n                else if (testKey(key, 'v')) {\n                    diagram.paste();\n                    diagram._destroyToolBar();\n                }\n                else if (testKey(key, 'l')) {\n                    diagram.layout();\n                    diagram._destroyToolBar();\n                }\n                else if (testKey(key, 'd')) {\n                    diagram._destroyToolBar();\n                    diagram.copy();\n                    diagram.paste();\n                }\n            }\n            else if (key === 46 || key === 8) { // del: deletion\n                const toRemove = this.diagram._triggerRemove(diagram.select());\n                if (toRemove.length) {\n                    this.diagram.remove(toRemove, true);\n                    this.diagram._syncChanges();\n                    this.diagram._destroyToolBar();\n                }\n                return true;\n            }\n            else if (key === 27) { // ESC: stop any action\n                this._discardNewConnection();\n                diagram.deselect();\n                diagram._destroyToolBar();\n                return true;\n            }\n        }\n        wheel(p, meta, nativeEvent) {\n            const diagram = this.diagram;\n            let z = diagram.zoom();\n            const delta = meta.delta, options = diagram.options, zoomRate = options.zoomRate, zoomOptions = { point: p, meta: meta, zoom: z, nativeEvent };\n            if (diagram.trigger(ZOOM_START, zoomOptions)) {\n                return;\n            }\n            if (delta < 0) {\n                z += zoomRate;\n            }\n            else {\n                z -= zoomRate;\n            }\n            z = round(Math.max(options.zoomMin, Math.min(options.zoomMax, z)), 2);\n            zoomOptions.zoom = z;\n            diagram.zoom(z, zoomOptions);\n            diagram.trigger(ZOOM_END, zoomOptions);\n            return true;\n        }\n        setTool(tool, index) {\n            tool.toolService = this;\n            this.tools[index] = tool;\n        }\n        selectSingle(item, meta) {\n            const diagram = this.diagram;\n            const selectable = diagram.options.selectable;\n            if (selectable && !item.isSelected && item.options.selectable !== false) {\n                const addToSelection = meta.ctrlKey && selectable.multiple !== false;\n                diagram.select(item, { addToSelection: addToSelection });\n            }\n        }\n        _discardNewConnection() {\n            if (this.newConnection) {\n                this.diagram.remove(this.newConnection);\n                this.newConnection = undefined;\n            }\n        }\n        _activateTool(p, meta) {\n            for (let i = 0; i < this.tools.length; i++) {\n                const tool = this.tools[i];\n                if (tool.tryActivate(p, meta)) {\n                    this.activeTool = tool;\n                    break; // activating the first available tool in the loop.\n                }\n            }\n        }\n        _updateCursor(p) {\n            const element = this.diagram.element;\n            const cursor = this.activeTool ? this.activeTool.getCursor(p) : (this.hoveredAdorner ? this.hoveredAdorner._getCursor(p) : (this.hoveredItem ? this.hoveredItem._getCursor(p) : Cursors.arrow));\n            element.style.cursor = cursor;\n        }\n        _connectionManipulation(connection, disabledShape, isNew) {\n            this.activeConnection = connection;\n            this.disabledShape = disabledShape;\n            if (isNew) {\n                this.newConnection = this.activeConnection;\n            }\n            else {\n                this.newConnection = undefined;\n            }\n        }\n        _updateHoveredItem(point, meta, nativeEvent) {\n            const hit = this._hitTest(point);\n            const diagram = this.diagram;\n            if (hit !== this.hoveredItem && (!this.disabledShape || hit !== this.disabledShape)) {\n                if (this.hoveredItem) {\n                    diagram.trigger(MOUSE_LEAVE, { item: this.hoveredItem, nativeEvent, point, meta });\n                    this.hoveredItem._hover(false);\n                }\n                if (hit && hit.options.enable) {\n                    diagram.trigger(MOUSE_ENTER, { item: hit, nativeEvent, point, meta });\n                    this.hoveredItem = hit; // Shape, connection or connector\n                    this.hoveredItem._hover(true);\n                }\n                else {\n                    this.hoveredItem = undefined;\n                }\n            }\n        }\n        _removeHover() {\n            if (this.hoveredItem) {\n                this.hoveredItem._hover(false);\n                this.hoveredItem = undefined;\n            }\n        }\n        _hitTest(point) {\n            const d = this.diagram;\n            let hit, item, i;\n            // connectors\n            if (this._hoveredConnector) {\n                this._hoveredConnector._hover(false);\n                this._hoveredConnector = undefined;\n            }\n            if (d._connectorsAdorner._visible) {\n                hit = d._connectorsAdorner._hitTest(point);\n                if (hit) {\n                    return hit;\n                }\n            }\n            hit = this.diagram._resizingAdorner._hitTest(point);\n            if (hit) {\n                this.hoveredAdorner = d._resizingAdorner;\n                if (hit.x !== 0 || hit.y !== 0) { // hit testing for resizers or rotator, otherwise if (0,0) than pass through.\n                    return;\n                }\n                hit = undefined;\n            }\n            else {\n                this.hoveredAdorner = undefined;\n            }\n            if (!this.activeTool || this.activeTool.type !== 'ConnectionTool') {\n                const selectedConnections = []; // only the connections should have higher presence because the connection edit point is on top of connector.\n                // TODO: This should be reworked. The connection adorner should be one for all selected connections and should be hit tested prior the connections and shapes itself.\n                for (i = 0; i < d._selectedItems.length; i++) {\n                    item = d._selectedItems[i];\n                    if (item instanceof Connection) {\n                        selectedConnections.push(item);\n                    }\n                }\n                hit = this._hitTestItems(selectedConnections, point);\n            }\n            return hit || this._hitTestElements(point);\n        }\n        _hitTestElements(point) {\n            const diagram = this.diagram;\n            const shapeHit = this._hitTestItems(diagram.shapes, point);\n            const connectionHit = this._hitTestItems(diagram.connections, point);\n            let hit;\n            if ((!this.activeTool || this.activeTool.type !== 'ConnectionTool') && shapeHit && connectionHit && !hitTestShapeConnectors(shapeHit, point)) {\n                const mainLayer = diagram.mainLayer;\n                const shapeIdx = inArray(shapeHit.visual, mainLayer.children);\n                const connectionIdx = inArray(connectionHit.visual, mainLayer.children);\n                hit = shapeIdx > connectionIdx ? shapeHit : connectionHit;\n            }\n            return hit || shapeHit || connectionHit;\n        }\n        _hitTestItems(array, point) {\n            let i, item, hit;\n            for (i = array.length - 1; i >= 0; i--) {\n                item = array[i];\n                hit = item._hitTest(point);\n                if (hit) {\n                    return hit;\n                }\n            }\n        }\n    }\n\n    class AddConnectionUnit {\n        constructor(connection, diagram) {\n            this.connection = connection;\n            this.diagram = diagram;\n            this.title = 'New connection';\n        }\n        undo() {\n            this.diagram.remove(this.connection, false);\n        }\n        redo() {\n            this.diagram._addConnection(this.connection, false);\n        }\n    }\n\n    class AddShapeUnit {\n        constructor(shape, diagram) {\n            this.shape = shape;\n            this.diagram = diagram;\n            this.title = 'New shape';\n        }\n        undo() {\n            this.diagram.deselect();\n            this.diagram.remove(this.shape, false);\n        }\n        redo() {\n            this.diagram._addShape(this.shape, false);\n        }\n    }\n\n    class CompositeUnit {\n        constructor(unit) {\n            this.units = [];\n            this.title = 'Composite unit';\n            if (unit !== undefined) {\n                this.units.push(unit);\n            }\n        }\n        add(undoUnit) {\n            this.units.push(undoUnit);\n        }\n        undo() {\n            for (let i = 0; i < this.units.length; i++) {\n                this.units[i].undo();\n            }\n        }\n        redo() {\n            for (let i = 0; i < this.units.length; i++) {\n                this.units[i].redo();\n            }\n        }\n    }\n\n    class DeleteConnectionUnit {\n        constructor(connection) {\n            this.connection = connection;\n            this.diagram = connection.diagram;\n            this.targetConnector = connection.targetConnector;\n            this.title = 'Delete connection';\n        }\n        undo() {\n            this.diagram._addConnection(this.connection, false);\n        }\n        redo() {\n            this.diagram.remove(this.connection, false);\n        }\n    }\n\n    class DeleteShapeUnit {\n        constructor(shape) {\n            this.shape = shape;\n            this.diagram = shape.diagram;\n            this.title = 'Deletion';\n        }\n        undo() {\n            this.diagram._addShape(this.shape, false);\n            this.shape.select(false);\n        }\n        redo() {\n            this.shape.select(false);\n            this.diagram.remove(this.shape, false);\n        }\n    }\n\n    class EditContentUnit {\n        constructor(shape, text) {\n            this.shape = shape;\n            this.nextText = text;\n            this.prevText = shape.content();\n            this.diagram = shape.diagram;\n            this.title = `Edit ${shape.name} Content`;\n        }\n        undo() {\n            this.shape.content({ text: this.prevText });\n        }\n        redo() {\n            this.shape.content({ text: this.nextText });\n        }\n    }\n\n    class PositionAdapter {\n        constructor(layoutState) {\n            this.layoutState = layoutState;\n            this.diagram = layoutState.diagram;\n        }\n        initState() {\n            this.froms = [];\n            this.tos = [];\n            this.subjects = [];\n            const pusher = (id, bounds) => {\n                const shape = this.diagram.getShapeById(id);\n                if (shape) {\n                    this.subjects.push(shape);\n                    this.froms.push(shape.bounds().topLeft());\n                    this.tos.push(bounds.topLeft());\n                }\n            };\n            this.layoutState.nodeMap.forEach(pusher, this);\n        }\n        update(tick) {\n            if (this.subjects.length <= 0) {\n                return;\n            }\n            for (let i = 0; i < this.subjects.length; i++) {\n                // todo: define a Lerp function instead\n                this.subjects[i].position(new Point(this.froms[i].x + (this.tos[i].x - this.froms[i].x) * tick, this.froms[i].y + (this.tos[i].y - this.froms[i].y) * tick));\n            }\n        }\n    }\n\n    class LayoutUndoUnit {\n        constructor(initialState, finalState, animate) {\n            if (isUndefined(animate)) {\n                this.animate = false;\n            }\n            else {\n                this.animate = Boolean(animate);\n            }\n            this._initialState = initialState;\n            this._finalState = finalState;\n            this.title = 'Diagram layout';\n        }\n        undo() {\n            this.setState(this._initialState);\n        }\n        redo() {\n            this.setState(this._finalState);\n        }\n        setState(state) {\n            const diagram = state.diagram;\n            if (this.animate) {\n                state.linkMap.forEach(function (id, points) {\n                    const conn = diagram.getShapeById(id);\n                    conn.visible(false);\n                    if (conn) {\n                        conn.points(points);\n                    }\n                });\n                const ticker = new Ticker();\n                ticker.addAdapter(new PositionAdapter(state));\n                ticker.onComplete(function () {\n                    state.linkMap.forEach(function (id) {\n                        const conn = diagram.getShapeById(id);\n                        conn.visible(true);\n                    });\n                });\n                ticker.play();\n            }\n            else {\n                state.nodeMap.forEach(function (id, bounds) {\n                    const shape = diagram.getShapeById(id);\n                    if (shape) {\n                        shape.position(bounds.topLeft());\n                    }\n                });\n                state.linkMap.forEach(function (id, points) {\n                    const conn = diagram.getShapeById(id);\n                    if (conn) {\n                        conn.points(points);\n                    }\n                });\n            }\n        }\n    }\n\n    class PanUndoUnit {\n        constructor(initialPosition, finalPosition, diagram) {\n            this.initial = initialPosition;\n            this.finalPos = finalPosition;\n            this.diagram = diagram;\n            this.title = 'Pan Unit';\n        }\n        undo() {\n            this.diagram.pan(this.initial);\n        }\n        redo() {\n            this.diagram.pan(this.finalPos);\n        }\n    }\n\n    class ToBackUnit {\n        constructor(diagram, items, initialIndices) {\n            this.diagram = diagram;\n            this.indices = initialIndices;\n            this.items = items;\n            this.title = 'Rotate Unit';\n        }\n        undo() {\n            this.diagram._toIndex(this.items, this.indices);\n        }\n        redo() {\n            this.diagram.toBack(this.items, false);\n        }\n    }\n\n    class ToFrontUnit {\n        constructor(diagram, items, initialIndices) {\n            this.diagram = diagram;\n            this.indices = initialIndices;\n            this.items = items;\n            this.title = 'Rotate Unit';\n        }\n        undo() {\n            this.diagram._toIndex(this.items, this.indices);\n        }\n        redo() {\n            this.diagram.toFront(this.items, false);\n        }\n    }\n\n    /**\n     * Undo-redo service.\n     */\n    class UndoRedoService extends Observable {\n        constructor(options = {}) {\n            super();\n            this.events = ['undone', 'redone'];\n            this.bind(this.events, options);\n            this.stack = [];\n            this.index = 0;\n            this.capacity = 100;\n        }\n        /**\n         * Starts the collection of units. Add those with\n         * the addCompositeItem method and call commit. Or cancel to forget about it.\n         */\n        begin() {\n            this.composite = new CompositeUnit();\n        }\n        /**\n         * Cancels the collection process of unit started with 'begin'.\n         */\n        cancel() {\n            this.composite = undefined;\n        }\n        /**\n         * Commits a batch of units.\n         */\n        commit(execute) {\n            if (this.composite.units.length > 0) {\n                this._restart(this.composite, execute);\n            }\n            this.composite = undefined;\n        }\n        /**\n         * Adds a unit as part of the begin-commit batch.\n         *\n         * @param undoUnit\n         */\n        addCompositeItem(undoUnit) {\n            if (this.composite) {\n                this.composite.add(undoUnit);\n            }\n            else {\n                this.add(undoUnit);\n            }\n        }\n        /**\n         * Standard addition of a unit. See also the batch version; begin-addCompositeUnit-commit methods.\n         *\n         * @param undoUnit The unit to be added.\n         * @param execute If false, the unit will be added but not executed.\n         */\n        add(undoUnit, execute) {\n            this._restart(undoUnit, execute);\n        }\n        /**\n         * Returns the number of undoable unit in the stack.\n         *\n         * @returns {Number}\n         */\n        pop() {\n            if (this.index > 0) {\n                this.stack.pop();\n                this.index--;\n            }\n        }\n        count() {\n            return this.stack.length;\n        }\n        /**\n         * Rollback of the unit on top of the stack.\n         */\n        undo() {\n            if (this.index > 0 && !this.trigger('undo', { unit: this.stack[this.index - 1] })) {\n                this.index--;\n                this.stack[this.index].undo();\n                this.trigger('undone');\n            }\n        }\n        /**\n         * Redo of the last undone action.\n         */\n        redo() {\n            if (this.stack.length > 0 && this.index < this.stack.length && !this.trigger('redo', { unit: this.stack[this.index] })) {\n                this.stack[this.index].redo();\n                this.index++;\n                this.trigger('redone');\n            }\n        }\n        _restart(composite, execute) {\n            // throw away anything beyond this point if this is a new branch\n            this.stack.splice(this.index, this.stack.length - this.index);\n            this.stack.push(composite);\n            if (execute !== false) {\n                this.redo();\n            }\n            else {\n                this.index++;\n            }\n            // check the capacity\n            if (this.stack.length > this.capacity) {\n                this.stack.splice(0, this.stack.length - this.capacity);\n                this.index = this.capacity; // points to the end of the stack\n            }\n        }\n        /**\n         * Clears the stack.\n         */\n        clear() {\n            this.stack = [];\n            this.index = 0;\n        }\n    }\n\n    class InactiveItem {\n        constructor(dataItem) {\n            this.dataItem = dataItem;\n            this.callbacks = [];\n        }\n        onActivate(callback) {\n            return new Promise((resolve) => {\n                this.callbacks.push({\n                    callback,\n                    resolve\n                });\n            });\n        }\n        activate() {\n            const callbacks = this.callbacks;\n            let item;\n            for (let idx = 0; idx < callbacks.length; idx++) {\n                item = this.callbacks[idx];\n                item.callback(this.dataItem);\n                item.resolve();\n            }\n            this.callbacks = [];\n        }\n    }\n    class InactiveItemsCollection {\n        constructor() {\n            this.items = {};\n        }\n        add(items) {\n            for (let idx = 0; idx < items.length; idx++) {\n                this.items[items[idx].uid] = new InactiveItem(items[idx]);\n            }\n        }\n        forEach(callback) {\n            for (const uid in this.items) {\n                if (Object.prototype.hasOwnProperty.call(this.items, uid)) {\n                    callback(this.items[uid]);\n                }\n            }\n        }\n        getByUid(uid) {\n            return this.items[uid];\n        }\n        remove(item) {\n            delete this.items[item.uid];\n        }\n        destroy() {\n            this.items = {};\n        }\n    }\n\n    class QuadRoot {\n        constructor() {\n            this.shapes = [];\n        }\n        _add(shape, bounds) {\n            this.shapes.push({\n                bounds: bounds,\n                shape: shape\n            });\n            shape._quadNode = this;\n        }\n        insert(shape, bounds) {\n            this._add(shape, bounds);\n        }\n        remove(shape) {\n            const shapes = this.shapes;\n            const length = shapes.length;\n            for (let idx = 0; idx < length; idx++) {\n                if (shapes[idx].shape === shape) {\n                    shapes.splice(idx, 1);\n                    break;\n                }\n            }\n        }\n        hitTestRect(rect, exclude) {\n            const shapes = this.shapes;\n            const length = shapes.length;\n            for (let i = 0; i < length; i++) {\n                if (this._testRect(shapes[i].shape, rect) && !contains(exclude, shapes[i].shape)) {\n                    return true;\n                }\n            }\n        }\n        _testRect(shape, rect) {\n            const angle = shape.rotate().angle;\n            const bounds = shape.bounds();\n            let hit;\n            if (!angle) {\n                hit = bounds.overlaps(rect);\n            }\n            else {\n                hit = Intersect.rects(rect, bounds, -angle);\n            }\n            return hit;\n        }\n    }\n\n    class QuadNode extends QuadRoot {\n        constructor(rect) {\n            super();\n            this.children = [];\n            this.rect = rect;\n        }\n        inBounds(rect) {\n            const nodeRect = this.rect;\n            const nodeBottomRight = nodeRect.bottomRight();\n            const bottomRight = rect.bottomRight();\n            const inBounds = nodeRect.x <= rect.x && nodeRect.y <= rect.y && bottomRight.x <= nodeBottomRight.x &&\n                bottomRight.y <= nodeBottomRight.y;\n            return inBounds;\n        }\n        overlapsBounds(rect) {\n            return this.rect.overlaps(rect);\n        }\n        insert(shape, bounds) {\n            let inserted = false;\n            const children = this.children;\n            const length = children.length;\n            if (this.inBounds(bounds)) {\n                if (!length && this.shapes.length < 4) {\n                    this._add(shape, bounds);\n                }\n                else {\n                    if (!length) {\n                        this._initChildren();\n                    }\n                    for (let idx = 0; idx < children.length; idx++) {\n                        if (children[idx].insert(shape, bounds)) {\n                            inserted = true;\n                            break;\n                        }\n                    }\n                    if (!inserted) {\n                        this._add(shape, bounds);\n                    }\n                }\n                inserted = true;\n            }\n            return inserted;\n        }\n        _initChildren() {\n            const rect = this.rect, children = this.children, shapes = this.shapes, center = rect.center(), halfWidth = rect.width / 2, halfHeight = rect.height / 2;\n            let childIdx, shapeIdx;\n            children.push(new QuadNode(new Rect(rect.x, rect.y, halfWidth, halfHeight)), new QuadNode(new Rect(center.x, rect.y, halfWidth, halfHeight)), new QuadNode(new Rect(rect.x, center.y, halfWidth, halfHeight)), new QuadNode(new Rect(center.x, center.y, halfWidth, halfHeight)));\n            for (shapeIdx = shapes.length - 1; shapeIdx >= 0; shapeIdx--) {\n                for (childIdx = 0; childIdx < children.length; childIdx++) {\n                    if (children[childIdx].insert(shapes[shapeIdx].shape, shapes[shapeIdx].bounds)) {\n                        shapes.splice(shapeIdx, 1);\n                        break;\n                    }\n                }\n            }\n        }\n        hitTestRect(rect, exclude) {\n            let idx;\n            const children = this.children;\n            const length = children.length;\n            let hit = false;\n            if (this.overlapsBounds(rect)) {\n                if (super.hitTestRect(rect, exclude)) {\n                    hit = true;\n                }\n                else {\n                    for (idx = 0; idx < length; idx++) {\n                        if (children[idx].hitTestRect(rect, exclude)) {\n                            hit = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            return hit;\n        }\n    }\n\n    class ShapesQuadTree {\n        constructor(diagram) {\n            this.ROOT_SIZE = 1000;\n            const boundsChangeHandler = this._boundsChange.bind(this);\n            diagram.bind(ITEMBOUNDSCHANGE, boundsChangeHandler);\n            diagram.bind(ITEMROTATE, boundsChangeHandler);\n            this.initRoots();\n        }\n        initRoots() {\n            this.rootMap = {};\n            this.root = new QuadRoot();\n        }\n        clear() {\n            this.initRoots();\n        }\n        _boundsChange(e) {\n            if (e.item._quadNode) {\n                e.item._quadNode.remove(e.item);\n            }\n            this.insert(e.item);\n        }\n        insert(shape) {\n            const bounds = shape.bounds(ROTATED);\n            const rootSize = this.ROOT_SIZE;\n            const sectors = this.getSectors(bounds);\n            const x = sectors[0][0];\n            const y = sectors[1][0];\n            if (this.inRoot(sectors)) {\n                this.root.insert(shape, bounds);\n            }\n            else {\n                if (!this.rootMap[x]) {\n                    this.rootMap[x] = {};\n                }\n                if (!this.rootMap[x][y]) {\n                    this.rootMap[x][y] = new QuadNode(new Rect(x * rootSize, y * rootSize, rootSize, rootSize));\n                }\n                this.rootMap[x][y].insert(shape, bounds);\n            }\n        }\n        remove(shape) {\n            if (shape._quadNode) {\n                shape._quadNode.remove(shape);\n            }\n        }\n        inRoot(sectors) {\n            return sectors[0].length > 1 || sectors[1].length > 1;\n        }\n        getSectors(rect) {\n            const rootSize = this.ROOT_SIZE;\n            const bottomRight = rect.bottomRight();\n            const bottomX = Math.floor(bottomRight.x / rootSize);\n            const bottomY = Math.floor(bottomRight.y / rootSize);\n            const sectors = [[], []];\n            for (let x = Math.floor(rect.x / rootSize); x <= bottomX; x++) {\n                sectors[0].push(x);\n            }\n            for (let y = Math.floor(rect.y / rootSize); y <= bottomY; y++) {\n                sectors[1].push(y);\n            }\n            return sectors;\n        }\n        hitTestRect(rect, exclude) {\n            const sectors = this.getSectors(rect);\n            let xIdx, yIdx, x, y;\n            let root;\n            if (this.root.hitTestRect(rect, exclude)) {\n                return true;\n            }\n            for (xIdx = 0; xIdx < sectors[0].length; xIdx++) {\n                x = sectors[0][xIdx];\n                for (yIdx = 0; yIdx < sectors[1].length; yIdx++) {\n                    y = sectors[1][yIdx];\n                    root = (this.rootMap[x] || {})[y];\n                    if (root && root.hitTestRect(rect, exclude)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n\n    function copyDefaultOptions(mainOptions, elementOptions, fields) {\n        let field;\n        for (let idx = 0; idx < fields.length; idx++) {\n            field = fields[idx];\n            if (elementOptions && !defined(elementOptions[field])) {\n                elementOptions[field] = mainOptions[field];\n            }\n        }\n    }\n    const defaultOptions = {\n        name: 'Diagram',\n        theme: 'sass',\n        layout: '',\n        zoomRate: 0.1,\n        zoom: 1,\n        zoomMin: 0,\n        zoomMax: 2,\n        dataSource: {},\n        draggable: true,\n        template: '',\n        autoBind: true,\n        editable: {\n            rotate: {},\n            resize: {},\n            text: true,\n            tools: [],\n            drag: {\n                snap: {\n                    size: 10,\n                    angle: 10\n                }\n            },\n            remove: true\n        },\n        pannable: {},\n        selectable: {\n            key: 'none'\n        },\n        tooltip: { enabled: true, format: '{0}' },\n        copy: {\n            enabled: true,\n            offsetX: 20,\n            offsetY: 20\n        },\n        shapeDefaults: shapeDefaults({ undoable: true, connectors: undefined }),\n        connectionDefaults: {\n            editable: {\n                tools: []\n            },\n            type: CASCADING\n        },\n        shapes: [],\n        connections: []\n    };\n    const domEvents = ['contextmenu', 'dblclick', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerleave', 'touchstart', 'touchmove', 'touchend', 'touchcancel'];\n    const events = [\n        ZOOM_END,\n        ZOOM_START,\n        PAN, SELECT$1,\n        ITEMROTATE,\n        ITEMBOUNDSCHANGE,\n        CHANGE$1,\n        CLICK,\n        MOUSE_ENTER,\n        MOUSE_LEAVE,\n        'toolBarClick',\n        'save',\n        'cancel',\n        'edit',\n        'remove',\n        'undo',\n        'redo',\n        'add',\n        'dataBound',\n        ...domEvents,\n        DRAG_START,\n        DRAG,\n        DRAG_END\n    ];\n    function splitDiagramElements(elements) {\n        const connections = [];\n        const shapes = [];\n        let element, idx;\n        for (idx = 0; idx < elements.length; idx++) {\n            element = elements[idx];\n            if (element instanceof Shape) {\n                shapes.push(element);\n            }\n            else {\n                connections.push(element);\n            }\n        }\n        return {\n            shapes: shapes,\n            connections: connections\n        };\n    }\n    function preventDefault(e) {\n        e.preventDefault();\n    }\n    function elementOffset(element) {\n        const rect = element.getBoundingClientRect();\n        const doc = element.ownerDocument;\n        const scrollLeft = doc.defaultView.scrollX || doc.documentElement.scrollLeft || 0;\n        const scrollTop = doc.defaultView.scrollY || doc.documentElement.scrollTop || 0;\n        return {\n            top: rect.top + scrollTop,\n            left: rect.left + scrollLeft\n        };\n    }\n    function outerWidth(element, includeMargins = false) {\n        let widthValue = element.offsetWidth; // Width of the element with padding and border\n        if (includeMargins) {\n            const style = getComputedStyle(element);\n            const marginLeft = parseFloat(style.marginLeft);\n            const marginRight = parseFloat(style.marginRight);\n            widthValue += marginLeft + marginRight;\n        }\n        return widthValue;\n    }\n    function outerHeight(element, includeMargins = false) {\n        let heightValue = element.offsetHeight;\n        if (includeMargins) {\n            const style = getComputedStyle(element);\n            const marginTop = parseFloat(style.marginTop);\n            const marginBottom = parseFloat(style.marginBottom);\n            heightValue += marginTop + marginBottom;\n        }\n        return heightValue;\n    }\n    function elementWidth(element) {\n        const style = getComputedStyle(element);\n        const widthValue = element.clientWidth; // Includes content + padding\n        const paddingLeft = parseFloat(style.paddingLeft);\n        const paddingRight = parseFloat(style.paddingRight);\n        return widthValue - paddingLeft - paddingRight; // Only content\n    }\n    function elementHeight(element) {\n        const style = getComputedStyle(element);\n        const heightValue = element.clientHeight;\n        const paddingTop = parseFloat(style.paddingTop);\n        const paddingBottom = parseFloat(style.paddingBottom);\n        return heightValue - paddingTop - paddingBottom;\n    }\n\n    class Diagram extends Observable {\n        /**\n         * Creates a new Diagram instance.\n         * @param element The HTML element that will contain the diagram\n         * @param userOptions Configuration options for the diagram\n         * @param themeOptions Theme-specific options\n         */\n        constructor(element, userOptions, themeOptions) {\n            super();\n            /** @hidden */\n            this._clipboard = [];\n            /** @hidden */\n            this._connectionsDataMap = {};\n            /** @hidden */\n            this._dataMap = {};\n            /** @hidden */\n            this._inactiveShapeItems = new InactiveItemsCollection();\n            /** @hidden */\n            this._selectedItems = [];\n            /** Array of all shapes in the diagram. */\n            this.shapes = [];\n            /** Array of all connections in the diagram. */\n            this.connections = [];\n            /** @hidden */\n            this._deferredConnectionUpdates = [];\n            /** @hidden */\n            this._domEvent = (nativeEvent) => {\n                const meta = this._meta(nativeEvent);\n                const point = this._eventPositions(nativeEvent);\n                const item = this.toolService._hitTest(point);\n                this.trigger(nativeEvent.type, { nativeEvent, item, point, meta });\n            };\n            this.element = element;\n            this.options = deepExtend({ createToolBar: noop$1, destroyToolBar: noop$1 }, defaultOptions, userOptions);\n            this.events = events;\n            this._initTheme(themeOptions);\n            this._initElements();\n            this._extendLayoutOptions(this.options);\n            this._initDefaults(userOptions);\n            this._interactionDefaults();\n            this._initCanvas();\n            this.mainLayer = new Group({\n                id: 'main-layer'\n            });\n            this.canvas.append(this.mainLayer);\n            this._shapesQuadTree = new ShapesQuadTree(this);\n            this._pan = new Point();\n            this._adorners = [];\n            this.adornerLayer = new Group({\n                id: 'adorner-layer'\n            });\n            this.canvas.append(this.adornerLayer);\n            this._createHandlers();\n            this._initialize();\n            this._resizingAdorner = new ResizingAdorner(this, { editable: this.options.editable });\n            this._connectorsAdorner = new ConnectorsAdorner(this);\n            this._adorn(this._resizingAdorner, true);\n            this._adorn(this._connectorsAdorner, true);\n            this.selector = new Selector(this);\n            // TODO: We may consider using real Clipboard API once is supported by the standard.\n            this._clipboard.length = 0;\n            this.pauseMouseHandlers = false;\n        }\n        /** @hidden */\n        _createShape(dataItem, options) {\n            options = deepExtend({}, this.options.shapeDefaults, options);\n            options.dataItem = dataItem;\n            const shape = new Shape(options, this);\n            return shape;\n        }\n        /** @hidden */\n        _createConnection(dataItem, source, target) {\n            const options = deepExtend({}, this.options.connectionDefaults);\n            options.dataItem = dataItem;\n            const connection = new Connection(source || new Point(), target || new Point(), options);\n            return connection;\n        }\n        /** @hidden */\n        _initElements() {\n            this.element.innerHTML = '';\n            this.element.style.position = 'relative';\n            this.element.setAttribute('tabindex', '0');\n            this.element.classList.add('k-diagram');\n            this.scrollable = document.createElement('div');\n            this.element.appendChild(this.scrollable);\n            this.wrapper = this.element;\n        }\n        /** @hidden */\n        _initDefaults(userOptions) {\n            const options = this.options;\n            const editable = options.editable;\n            const shapeDefaults = options.shapeDefaults;\n            const connectionDefaults = options.connectionDefaults;\n            const userShapeDefaults = (userOptions || {}).shapeDefaults;\n            if (editable === false) {\n                shapeDefaults.editable = false;\n                connectionDefaults.editable = false;\n            }\n            else {\n                copyDefaultOptions(editable, shapeDefaults.editable, ['drag', 'remove', 'connect']);\n                copyDefaultOptions(editable, connectionDefaults.editable, ['drag', 'remove']);\n            }\n            if (userShapeDefaults && userShapeDefaults.connectors) {\n                options.shapeDefaults.connectors = userShapeDefaults.connectors;\n            }\n        }\n        /** @hidden */\n        _interactionDefaults() {\n            const options = this.options;\n            const selectable = options.selectable;\n            const pannable = options.pannable;\n            const mobile = this._mobileOS();\n            if (selectable && !defined(selectable.multiple)) {\n                options.selectable = deepExtend({\n                    multiple: mobile ? false : true\n                }, options.selectable);\n            }\n            if (pannable && !defined(pannable.key)) {\n                options.pannable = deepExtend({\n                    key: mobile ? 'none' : 'ctrl'\n                }, options.pannable);\n            }\n        }\n        /** @hidden */\n        _initCanvas() {\n            const canvasContainer = document.createElement('div');\n            canvasContainer.classList.add('k-layer');\n            this.scrollable.appendChild(canvasContainer);\n            const viewPort = this.viewport();\n            this.canvas = new (this.options.Canvas || Canvas$1)(canvasContainer, {\n                width: viewPort.width || DEFAULT_CANVAS_WIDTH,\n                height: viewPort.height || DEFAULT_CANVAS_HEIGHT\n            });\n        }\n        /** @hidden */\n        _createHandlers() {\n            const element = this.element;\n            this._wheelHandler = this._wheelHandler || this._wheel.bind(this);\n            this._keydownHandler = this._keydownHandler || this._keydown.bind(this);\n            if (this._mobileOS() && this._mobileOS().browser.mobilesafari) {\n                element.addEventListener('mousewheel', this._wheelHandler);\n            }\n            else {\n                element.addEventListener('wheel', this._wheelHandler);\n            }\n            element.addEventListener('keydown', this._keydownHandler);\n            this._userEvents = new UserEvents(this.scrollable, {\n                multiTouch: true,\n                fastTap: true,\n                tap: this._tap.bind(this),\n                start: this._dragStart.bind(this),\n                move: this._drag.bind(this),\n                end: this._dragEnd.bind(this),\n                gesturestart: this._gestureStart.bind(this),\n                gesturechange: this._gestureChange.bind(this),\n                gestureend: this._gestureEnd.bind(this),\n                doubleTap: this._doubleTap.bind(this),\n                supportDoubleTap: true\n            });\n            this.toolService = new ToolService(this);\n            this._mouseoverHandler = this._mouseoverHandler || this._mouseover.bind(this);\n            this._mouseoutHandler = this._mouseoutHandler || this._mouseout.bind(this);\n            this._mouseMoveHandler = this._mouseMoveHandler || this._mouseMove.bind(this);\n            this._mouseDownHandler = this._mouseDownHandler || this._mouseDown.bind(this);\n            this._mouseUpHandler = this._mouseUpHandler || this._mouseUp.bind(this);\n            this.scrollable.addEventListener('mouseover', this._mouseoverHandler);\n            this.scrollable.addEventListener('mouseout', this._mouseoutHandler);\n            this.scrollable.addEventListener('mousemove', this._mouseMoveHandler);\n            this.scrollable.addEventListener('mousedown', this._mouseDownHandler);\n            this.scrollable.addEventListener('mouseup', this._mouseUpHandler);\n            domEvents.forEach(event => {\n                this.scrollable.addEventListener(event, this._domEvent);\n            });\n            this._initResizeObserver();\n            this.bind(ZOOM_START, this._destroyToolBar.bind(this));\n            this.bind(PAN, this._destroyToolBar.bind(this));\n        }\n        /** @hidden */\n        _initResizeObserver() {\n            const observer = new ResizeObserver((entries) => {\n                entries.forEach(entry => {\n                    const { width, height } = entry.contentRect;\n                    if (entry.target !== this.element ||\n                        (this.size && this.size.width === width && this.size.height === height)) {\n                        return;\n                    }\n                    this.size = { width, height };\n                    this._resize();\n                    this.trigger('resize', this.size);\n                });\n            });\n            this._resizeObserver = observer;\n            observer.observe(this.element);\n        }\n        /** @hidden */\n        _destroyResizeObserver() {\n            if (this._resizeObserver) {\n                this._resizeObserver.disconnect();\n                this._resizeObserver = null;\n            }\n        }\n        /** @hidden */\n        _dragStart(e) {\n            this._pauseMouseHandlers = true;\n            const point = this._eventPositions(e, true);\n            if (this.toolService.start(point, this._meta(e), e.event)) {\n                this._destroyToolBar();\n                e.preventDefault();\n            }\n        }\n        /** @hidden */\n        _drag(e) {\n            const p = this._eventPositions(e);\n            if (this.toolService.move(p, this._meta(e), e.event)) {\n                e.preventDefault();\n            }\n        }\n        /** @hidden */\n        _dragEnd(e) {\n            this._pauseMouseHandlers = false;\n            const p = this._eventPositions(e);\n            if (this.toolService.end(p, this._meta(e), e.event)) {\n                this.options.createToolBar();\n                e.preventDefault();\n            }\n        }\n        /** @hidden */\n        _mouseMove(e) {\n            if (!this._pauseMouseHandlers) {\n                const p = this._eventPositions(e);\n                this.toolService._updateHoveredItem(p, this._meta(e), e);\n                this.toolService._updateCursor(p);\n            }\n        }\n        /** @hidden */\n        _mouseDown() {\n            this._pauseMouseHandlers = true;\n        }\n        /** @hidden */\n        _mouseUp() {\n            this._pauseMouseHandlers = false;\n        }\n        /** @hidden */\n        _tap(e) {\n            const toolService = this.toolService;\n            const selectable = this.options.selectable;\n            const point = this._eventPositions(e);\n            const focused = this.focus();\n            const meta = this._meta(e);\n            toolService._updateHoveredItem(point, meta, e.event);\n            if (toolService.hoveredItem) {\n                const item = toolService.hoveredItem;\n                this.trigger('click', {\n                    nativeEvent: e.event,\n                    item: item,\n                    point: point,\n                    meta: meta\n                });\n                if (selectable && item.options.selectable !== false) {\n                    const multiple = selectable.multiple !== false;\n                    const ctrlPressed = kendo_common_cmn_chunk_js.m || meta.ctrlKey || (meta.metaKey && macOS());\n                    if (item.isSelected) {\n                        if (ctrlPressed) {\n                            this._destroyToolBar();\n                            item.select(false);\n                        }\n                        else {\n                            this.options.createToolBar(focused);\n                        }\n                    }\n                    else {\n                        this._destroyToolBar();\n                        this.select(item, {\n                            addToSelection: multiple && ctrlPressed\n                        });\n                        this.options.createToolBar(focused);\n                    }\n                }\n            }\n            else if (selectable) {\n                this._destroyToolBar();\n                this.deselect();\n            }\n        }\n        /** @hidden */\n        _keydown(e) {\n            if (this.toolService.keyDown(e.keyCode, this._meta(e))) {\n                e.preventDefault();\n            }\n        }\n        /** @hidden */\n        _wheel(e) {\n            const delta = mwDelta(e), p = this._eventPositions(e), meta = deepExtend(this._meta(e), { delta: delta });\n            if (this.toolService.wheel(p, meta, e)) {\n                e.preventDefault();\n            }\n        }\n        /** @hidden */\n        _meta(e) {\n            e = e.event || e;\n            return { ctrlKey: e.ctrlKey, metaKey: e.metaKey, altKey: e.altKey, shiftKey: e.shiftKey, type: e.type };\n        }\n        /** @hidden */\n        _eventPositions(e, start) {\n            let point;\n            if (e.touch) {\n                const field = start ? 'startLocation' : 'location';\n                point = new Point(e.x[field], e.y[field]);\n            }\n            else {\n                point = new Point(e.pageX, e.pageY);\n            }\n            return this.documentToModel(point);\n        }\n        /** @hidden */\n        _gestureStart(e) {\n            this._destroyToolBar();\n            this.scroller.disable();\n            const initialCenter = this.documentToModel(new Point(e.center.x, e.center.y));\n            const eventArgs = {\n                point: initialCenter,\n                zoom: this.zoom()\n            };\n            if (this.trigger(ZOOM_START, eventArgs)) {\n                return;\n            }\n            this._gesture = e;\n            this._initialCenter = initialCenter;\n        }\n        /** @hidden */\n        _gestureChange(e) {\n            const previousGesture = this._gesture;\n            const initialCenter = this._initialCenter;\n            const center = this.documentToView(new Point(e.center.x, e.center.y));\n            const scaleDelta = e.distance / previousGesture.distance;\n            let zoom = this._zoom;\n            let updateZoom = false;\n            if (Math.abs(scaleDelta - 1) >= MOBILE_ZOOM_RATE) {\n                this._zoom = zoom = this._getValidZoom(zoom * scaleDelta);\n                this.options.zoom = zoom;\n                this._gesture = e;\n                updateZoom = true;\n            }\n            const zoomedPoint = initialCenter.times(zoom);\n            const pan = center.minus(zoomedPoint);\n            if (updateZoom || this._pan.distanceTo(pan) >= MOBILE_PAN_DISTANCE) {\n                this._panTransform(pan);\n                this._updateAdorners();\n            }\n            e.preventDefault();\n        }\n        /** @hidden */\n        _doubleTap(e) {\n            const pointPosition = this._eventPositions(e);\n            const options = this.options;\n            const zoomRate = options.zoomRate;\n            let zoom = this.zoom() + zoomRate;\n            const meta = this._meta(e);\n            const zoomOptions = { point: pointPosition, meta: meta, zoom: zoom };\n            if (this.trigger(ZOOM_START, zoomOptions)) {\n                return;\n            }\n            zoom = kendo_drawing_cmn_chunk_js.r(Math.max(options.zoomMin, Math.min(options.zoomMax, zoom)), 2);\n            zoomOptions.zoom = zoom;\n            this.zoom(zoom, zoomOptions);\n            this.trigger(ZOOM_END, zoomOptions);\n        }\n        /** @hidden */\n        _gestureEnd() {\n            if (this.options.pannable !== false) {\n                this.scroller.enable();\n            }\n            this.trigger(ZOOM_END, {\n                point: this._initialCenter,\n                zoom: this.zoom()\n            });\n        }\n        /** @hidden */\n        _resize() {\n            const viewport = this.viewport();\n            if (this.canvas) {\n                this.canvas.size(viewport);\n            }\n            if (this.scrollable && this.toolBar) {\n                this.scrollable.style.height = viewport.height + 'px';\n            }\n        }\n        /** @hidden */\n        _mouseover(e) {\n            const node = e.target._kendoNode;\n            if (node && node.srcElement._hover) {\n                node.srcElement._hover(true, node.srcElement);\n            }\n        }\n        /** @hidden */\n        _mouseout(e) {\n            const node = e.target._kendoNode;\n            if (node && node.srcElement._hover) {\n                node.srcElement._hover(false, node.srcElement);\n            }\n        }\n        /** @hidden */\n        _initTheme(themeOptions) {\n            this.options = deepExtend({}, themeOptions, this.options);\n            if (this.options.editable === true) {\n                this.options.editable = (themeOptions || {}).editable;\n            }\n        }\n        /** @hidden */\n        _createOptionElements() {\n            const options = this.options;\n            const shapesLength = options.shapes.length;\n            if (shapesLength) {\n                this._createShapes();\n            }\n            if (options.connections.length) {\n                this._createConnections();\n            }\n            if (shapesLength && options.layout) {\n                this.layout(options.layout);\n            }\n        }\n        /** @hidden */\n        _createShapes() {\n            const options = this.options, shapes = options.shapes;\n            let shape, i;\n            for (i = 0; i < shapes.length; i++) {\n                shape = shapes[i];\n                this.addShape(shape);\n            }\n        }\n        /** @hidden */\n        _createConnections() {\n            const options = this.options, defaults = options.connectionDefaults, connections = options.connections;\n            let conn, source, target, i;\n            for (i = 0; i < connections.length; i++) {\n                conn = connections[i];\n                source = this._findConnectionTarget(conn.from);\n                target = this._findConnectionTarget(conn.to);\n                if (this.options.connect) {\n                    this.options.connect(source, target, deepExtend({}, defaults, conn));\n                }\n                else {\n                    this.connect(source, target, deepExtend({}, defaults, conn));\n                }\n            }\n        }\n        /** @hidden */\n        _findConnectionTarget(options) {\n            options = options || {};\n            const shapeId = isString$1(options) ? options : options.shapeId || options.id;\n            let target;\n            if (shapeId) {\n                target = this.getShapeById(shapeId);\n                if (options.connector) {\n                    target = target.getConnector(options.connector);\n                }\n            }\n            else {\n                target = new Point(options.x || 0, options.y || 0);\n            }\n            return target;\n        }\n        /**\n         * Destroys the diagram and cleans up all resources.\n         * Removes event listeners, destroys components, and clears all elements.\n         */\n        destroy() {\n            super.destroy();\n            this._destroyResizeObserver();\n            if (this._userEvents) {\n                this._userEvents.destroy();\n            }\n            this.clear();\n            this.element.removeEventListener('mousewheel', this._wheelHandler);\n            this.element.removeEventListener('wheel', this._wheelHandler);\n            this.element.removeEventListener('keydown', this._keydownHandler);\n            this.scrollable.removeEventListener('mouseover', this._mouseoverHandler);\n            this.scrollable.removeEventListener('mouseout', this._mouseoutHandler);\n            this.scrollable.removeEventListener('mousemove', this._mouseMoveHandler);\n            this.scrollable.removeEventListener('mousedown', this._mouseDownHandler);\n            this.scrollable.removeEventListener('mouseup', this._mouseUpHandler);\n            domEvents.forEach(event => {\n                this.scrollable.removeEventListener(event, this._domEvent);\n            });\n            this.canvas.destroy(true);\n            this.canvas = undefined;\n            this.destroyScroller();\n            this._destroyGlobalToolBar();\n            this._destroyToolBar();\n            this._inactiveShapeItems.destroy();\n        }\n        /**\n         * Destroys the scroller component and removes its element.\n         */\n        destroyScroller() {\n            const scroller = this.scroller;\n            if (!scroller) {\n                return;\n            }\n            scroller.destroy();\n            scroller.element.remove();\n            this.scroller = null;\n        }\n        /**\n         * Serializes the diagram to a JSON object containing shapes and connections.\n         * @returns Object with shapes and connections arrays\n         */\n        save() {\n            const json = {\n                shapes: [],\n                connections: []\n            };\n            let i, connection, shape;\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                if (shape.options.serializable) {\n                    json.shapes.push(shape.options);\n                }\n            }\n            for (i = 0; i < this.connections.length; i++) {\n                connection = this.connections[i];\n                json.connections.push(deepExtend({}, connection.options, connection.toJSON()));\n            }\n            return json;\n        }\n        /**\n         * Sets focus to the diagram element.\n         * @returns True if focus was set, undefined otherwise\n         */\n        focus() {\n            if (this.element !== this.element.ownerDocument.activeElement) {\n                const element = this.element, containers = [], offsets = [], documentElement = element.ownerDocument.documentElement;\n                let scrollContainer = element, i;\n                do {\n                    scrollContainer = scrollContainer.parentNode;\n                    if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {\n                        containers.push(scrollContainer);\n                        offsets.push(scrollContainer.scrollTop);\n                    }\n                } while (scrollContainer !== documentElement);\n                element.focus({ preventScroll: true });\n                for (i = 0; i < containers.length; i++) {\n                    containers[i].scrollTop = offsets[i];\n                }\n                return true;\n            }\n        }\n        /**\n         * Loads diagram data and recreates shapes and connections.\n         * @param options The diagram options containing shapes and connections data\n         */\n        load(options) {\n            this.clear();\n            this.setOptions(options);\n            this._createShapes();\n            this._createConnections();\n        }\n        /**\n         * Sets options for the diagram by deep extending the current options.\n         * @param options The options to merge with current diagram options\n         */\n        setOptions(options) {\n            deepExtend(this.options, options);\n        }\n        /**\n         * Clears the diagram by removing all selections and elements, then reinitializes.\n         */\n        clear() {\n            this.select(false);\n            this.mainLayer.clear();\n            this._shapesQuadTree.clear();\n            this._initialize();\n        }\n        /**\n         * Determines whether the the two items are connected.\n         *\n         * @param source Shape, Connector, Point.\n         * @param target Shape, Connector, Point.\n         * @returns true if the two items are connected.\n         */\n        connected(source, target) {\n            for (let i = 0; i < this.connections.length; i++) {\n                const c = this.connections[i];\n                if (c.from === source && c.to === target) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        /**\n         * Adds connection to the diagram.\n         *\n         * @param connection Connection.\n         * @param undoable Boolean.\n         * @returns The newly created connection.\n         */\n        addConnection(connection, undoable) {\n            if (undoable !== false) {\n                this.undoRedoService.add(new AddConnectionUnit(connection, this), false);\n            }\n            connection.diagram = this;\n            connection._setOptionsFromModel();\n            connection.refresh();\n            this.mainLayer.append(connection.visual);\n            this.connections.push(connection);\n            this.trigger(CHANGE$1, {\n                added: [connection],\n                removed: []\n            });\n            return connection;\n        }\n        /**\n         * Adds shape to the diagram.\n         *\n         * @param item Shape, Point. If point is passed it will be created new Shape and positioned at that point.\n         * @param options. The options to be passed to the newly created Shape.\n         * @returns The newly created shape.\n         */\n        addShape(item, undoable) {\n            let shape, shapeDefaults = this.options.shapeDefaults;\n            if (item instanceof Shape) {\n                shape = item;\n                this._parseBounds(shape.bounds());\n            }\n            else if (!(item.prototype)) {\n                shapeDefaults = deepExtend({}, shapeDefaults, item || {});\n                shape = new Shape(shapeDefaults, this);\n                this._parseBounds(shape.bounds());\n            }\n            else {\n                return;\n            }\n            if (undoable !== false) {\n                this.undoRedoService.add(new AddShapeUnit(shape, this), false);\n            }\n            this.shapes.push(shape);\n            if (shape.diagram !== this) {\n                this._shapesQuadTree.insert(shape);\n                shape.diagram = this;\n            }\n            this.mainLayer.append(shape.visual);\n            this.trigger(CHANGE$1, {\n                added: [shape],\n                removed: []\n            });\n            return shape;\n        }\n        /**\n         * Removes items (or single item) from the diagram.\n         *\n         * @param items DiagramElement, Array of Items.\n         * @param undoable.\n         */\n        remove(items, undoable) {\n            items = Array.isArray(items) ? items.slice(0) : [items];\n            const elements = splitDiagramElements(items);\n            const shapes = elements.shapes;\n            const connections = elements.connections;\n            let i;\n            if (!defined(undoable)) {\n                undoable = true;\n            }\n            if (undoable) {\n                this.undoRedoService.begin();\n            }\n            this._suspendModelRefresh();\n            for (i = shapes.length - 1; i >= 0; i--) {\n                this._removeItem(shapes[i], undoable, connections);\n            }\n            for (i = connections.length - 1; i >= 0; i--) {\n                this._removeItem(connections[i], undoable);\n            }\n            this._resumeModelRefresh();\n            if (undoable) {\n                this.undoRedoService.commit(false);\n            }\n            this.trigger(CHANGE$1, {\n                added: [],\n                removed: items\n            });\n        }\n        /** @hidden */\n        _addConnection(connection, undoable) {\n            if (this.options._addConnection) {\n                return this.options._addConnection(connection, undoable);\n            }\n            else if (!this.trigger('add', { connection: connection })) {\n                this.addConnection(connection, undoable);\n                connection._updateConnectors();\n                return connection;\n            }\n        }\n        /** @hidden */\n        _addShape(shape, undoable) {\n            if (this.options._addShape) {\n                return this.options._addShape(shape, undoable);\n            }\n            else if (!this.trigger('add', { shape: shape })) {\n                return this.addShape(shape, undoable);\n            }\n        }\n        /** @hidden */\n        _parseBounds(bounds) {\n            bounds.x = typeof (bounds.x) == 'string' ? parseFloat(bounds.x) : bounds.x;\n            bounds.y = typeof (bounds.y) == 'string' ? parseFloat(bounds.y) : bounds.y;\n        }\n        /** @hidden */\n        _shouldRefresh() {\n            return !this._suspended;\n        }\n        /** @hidden */\n        _suspendModelRefresh() {\n            this._suspended = (this._suspended || 0) + 1;\n        }\n        /** @hidden */\n        _resumeModelRefresh() {\n            this._suspended = Math.max((this._suspended || 0) - 1, 0);\n        }\n        /** @hidden */\n        _triggerRemove(items) {\n            const toRemove = [];\n            let item, args, editable;\n            for (let idx = 0; idx < items.length; idx++) {\n                item = items[idx];\n                editable = item.options.editable;\n                if (item instanceof Shape) {\n                    args = { shape: item };\n                }\n                else {\n                    args = { connection: item };\n                }\n                if (editable && editable.remove !== false && !this.trigger('remove', args)) {\n                    toRemove.push(item);\n                }\n            }\n            return toRemove;\n        }\n        /** @hidden */\n        _addConnections(connections, undoable) {\n            const length = connections.length;\n            for (let i = 0; i < length; i++) {\n                const dataItem = connections[i];\n                this._addConnectionDataItem(dataItem, undoable);\n            }\n        }\n        /** @hidden */\n        _addConnectionDataItem(dataItem, undoable) {\n            if (!this._connectionsDataMap[dataItem.uid]) {\n                let from = this._validateConnector(dataItem.from);\n                if (!defined(from) || from === null) {\n                    from = new Point(dataItem.fromX, dataItem.fromY);\n                }\n                let to = this._validateConnector(dataItem.to);\n                if (!defined(to) || to === null) {\n                    to = new Point(dataItem.toX, dataItem.toY);\n                }\n                if (defined(from) && defined(to)) {\n                    const options = deepExtend({}, this.options.connectionDefaults);\n                    options.dataItem = dataItem;\n                    const connection = new Connection(from, to, options);\n                    this._connectionsDataMap[dataItem.uid] = connection;\n                    this.addConnection(connection, undoable);\n                }\n            }\n        }\n        /** @hidden */\n        _validateConnector(value) {\n            let connector;\n            if (defined(value) && value !== null) {\n                connector = this._dataMap[value];\n            }\n            return connector;\n        }\n        /** @hidden */\n        _addDataItems(items, parent) {\n            let item, idx, shape, parentShape;\n            for (idx = 0; idx < items.length; idx++) {\n                item = items[idx];\n                shape = this._addDataItemByUid(item);\n                parentShape = this._addDataItemByUid(parent);\n                if (parentShape && !this.connected(parentShape, shape)) { // check if connected to not duplicate connections.\n                    this.connect(parentShape, shape);\n                }\n            }\n        }\n        /**\n         * Creates a connection between two endpoints (shapes, connectors, or points).\n         * @param source The source endpoint\n         * @param target The target endpoint\n         * @param options Optional connection configuration\n         * @returns The newly created connection\n         */\n        connect(source, target, options) {\n            const resolvedOptions = deepExtend({}, this.options.connectionDefaults, options);\n            const connection = new Connection(source, target, resolvedOptions);\n            return this.addConnection(connection);\n        }\n        /**\n         * Executes the next undoable action on top of the undo stack if any.\n         */\n        undo() {\n            this.undoRedoService.undo();\n        }\n        /**\n         * Executes the previous undoable action on top of the redo stack if any.\n         */\n        redo() {\n            this.undoRedoService.redo();\n        }\n        /**\n         * Selects items on the basis of the given input or returns the current selection if none.\n         *\n         * @param itemsOrRect DiagramElement, Array of elements, \"All\", false or Rect. A value 'false' will deselect everything.\n         * @param options\n         * @returns {Array} The currently selected items.\n         */\n        select(item, options) {\n            if (isDefined(item)) {\n                options = deepExtend({ addToSelection: false }, options);\n                const addToSelection = options.addToSelection, selected = [];\n                let items = [], i, element;\n                if (!addToSelection) {\n                    this.deselect();\n                }\n                this._internalSelection = true;\n                if (item instanceof Array) {\n                    items = item;\n                }\n                else if (item instanceof DiagramElement) {\n                    items = [item];\n                }\n                for (i = 0; i < items.length; i++) {\n                    element = items[i];\n                    if (element.select(true)) {\n                        selected.push(element);\n                    }\n                }\n                this._selectionChanged(selected, []);\n                this._internalSelection = false;\n            }\n            else {\n                return this._selectedItems;\n            }\n        }\n        /**\n         * Selects all shapes and connections in the diagram.\n         */\n        selectAll() {\n            this.select(this.shapes.concat(this.connections));\n        }\n        /**\n         * Selects shapes and connections within a rectangular area.\n         * @param rect The rectangular area to select items within\n         */\n        selectArea(rect) {\n            let i, items, item;\n            this._internalSelection = true;\n            const selected = [];\n            if (rect instanceof Rect) {\n                items = this.shapes.concat(this.connections);\n                for (i = 0; i < items.length; i++) {\n                    item = items[i];\n                    if ((!rect || item._hitTest(rect)) && item.options.enable) {\n                        if (item.select(true)) {\n                            selected.push(item);\n                        }\n                    }\n                }\n            }\n            this._selectionChanged(selected, []);\n            this._internalSelection = false;\n        }\n        /**\n         * Deselects items from the current selection.\n         * @param item The item(s) to deselect. If not provided, deselects all items.\n         */\n        deselect(item) {\n            this._internalSelection = true;\n            const deselected = [];\n            let items = [], element, i;\n            if (item instanceof Array) {\n                items = item;\n            }\n            else if (item instanceof DiagramElement) {\n                items.push(item);\n            }\n            else if (!isDefined(item)) {\n                items = this._selectedItems.slice(0);\n            }\n            for (i = 0; i < items.length; i++) {\n                element = items[i];\n                if (element.select(false)) {\n                    deselected.push(element);\n                }\n            }\n            this._selectionChanged([], deselected);\n            this._internalSelection = false;\n        }\n        /**\n         * Brings to front the passed items.\n         *\n         * @param items DiagramElement, Array of Items.\n         * @param undoable. By default the action is undoable.\n         */\n        toFront(items, undoable) {\n            if (!items) {\n                items = this._selectedItems.slice();\n            }\n            const result = this._getDiagramItems(items);\n            let indices;\n            if (!defined(undoable) || undoable) {\n                indices = indicesOfItems(this.mainLayer, result.visuals);\n                const unit = new ToFrontUnit(this, items, indices);\n                this.undoRedoService.add(unit);\n            }\n            else {\n                this.mainLayer.toFront(result.visuals);\n                this._fixOrdering(result, true);\n            }\n        }\n        /**\n         * Sends to back the passed items.\n         *\n         * @param items DiagramElement, Array of Items.\n         * @param undoable. By default the action is undoable.\n         */\n        toBack(items, undoable) {\n            if (!items) {\n                items = this._selectedItems.slice();\n            }\n            const result = this._getDiagramItems(items);\n            let indices;\n            if (!defined(undoable) || undoable) {\n                indices = indicesOfItems(this.mainLayer, result.visuals);\n                const unit = new ToBackUnit(this, items, indices);\n                this.undoRedoService.add(unit);\n            }\n            else {\n                this.mainLayer.toBack(result.visuals);\n                this._fixOrdering(result, false);\n            }\n        }\n        /**\n         * Bring into view the passed item(s) or rectangle.\n         *\n         * @param items DiagramElement, Array of Items, Rect.\n         * @param options. align - controls the position of the calculated rectangle relative to the viewport.\n         * \"Center middle\" will position the items in the center. animate - controls if the pan should be animated.\n         */\n        bringIntoView(item, options) {\n            const viewport = this.viewport();\n            const aligner = new RectAlign(viewport);\n            let rect;\n            if (viewport.width === 0 || viewport.height === 0) {\n                return;\n            }\n            options = deepExtend({ animate: false, align: 'center middle' }, options);\n            if (options.align === 'none') {\n                options.align = 'center middle';\n            }\n            if (item instanceof DiagramElement) {\n                rect = item.bounds(TRANSFORMED);\n            }\n            else if (Array.isArray(item)) {\n                rect = this.boundingBox(item);\n            }\n            else if (item instanceof Rect) {\n                rect = item.clone();\n            }\n            const original = rect.clone();\n            rect.zoom(this._zoom);\n            if (rect.width > viewport.width || rect.height > viewport.height) {\n                this._zoom = this._getValidZoom(Math.min(viewport.width / original.width, viewport.height / original.height));\n                rect = original.clone().zoom(this._zoom);\n            }\n            this._zoomMainLayer();\n            const current = rect.clone();\n            aligner.align(rect, options.align);\n            const newPan = rect.topLeft().minus(current.topLeft());\n            this.pan(newPan.times(-1), options.animate);\n        }\n        /**\n         * Aligns shapes in the specified direction.\n         * @param direction The alignment direction ('left', 'right', 'top', 'bottom')\n         */\n        alignShapes(direction) {\n            if (isUndefined(direction)) {\n                direction = 'Left';\n            }\n            let val, item, i;\n            const items = this.select();\n            if (items.length === 0) {\n                return;\n            }\n            switch (direction.toLowerCase()) {\n                case 'left':\n                case 'top':\n                    val = MAX_VALUE;\n                    break;\n                case 'right':\n                case 'bottom':\n                    val = MIN_VALUE;\n                    break;\n                default:\n                    break;\n            }\n            for (i = 0; i < items.length; i++) {\n                item = items[i];\n                if (item instanceof Shape) {\n                    switch (direction.toLowerCase()) {\n                        case 'left':\n                            val = Math.min(val, item.options.x);\n                            break;\n                        case 'top':\n                            val = Math.min(val, item.options.y);\n                            break;\n                        case 'right':\n                            val = Math.max(val, item.options.x);\n                            break;\n                        case 'bottom':\n                            val = Math.max(val, item.options.y);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n            const undoStates = [];\n            const shapes = [];\n            for (i = 0; i < items.length; i++) {\n                item = items[i];\n                if (item instanceof Shape) {\n                    shapes.push(item);\n                    undoStates.push(item.bounds());\n                    switch (direction.toLowerCase()) {\n                        case 'left':\n                        case 'right':\n                            item.position(new Point(val, item.options.y));\n                            break;\n                        case 'top':\n                        case 'bottom':\n                            item.position(new Point(item.options.x, val));\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n            const unit = new TransformUnit(shapes, undoStates);\n            this.undoRedoService.add(unit, false);\n        }\n        /**\n         * Gets or sets the zoom level of the diagram.\n         * @param zoom The zoom level to set (1.0 = 100%). If not provided, returns the current zoom.\n         * @param options Options including the zoom point and metadata\n         * @returns The current zoom level when used as a getter\n         */\n        zoom(zoom, options) {\n            if (zoom) {\n                let staticPoint = options ? options.point : new Point(0, 0);\n                // var meta = options ? options.meta : 0;\n                zoom = this._zoom = this._getValidZoom(zoom);\n                if (!isUndefined(staticPoint)) { // Viewpoint vector is constant\n                    staticPoint = new Point(Math.round(staticPoint.x), Math.round(staticPoint.y));\n                    const zoomedPoint = staticPoint.times(zoom);\n                    const viewportVector = this.modelToView(staticPoint);\n                    const raw = viewportVector.minus(zoomedPoint); // pan + zoomed point = viewpoint vector\n                    this._storePan(new Point(Math.round(raw.x), Math.round(raw.y)));\n                }\n                if (options) {\n                    options.zoom = zoom;\n                }\n                this._panTransform();\n                if (this.canvas.surface.hideTooltip) {\n                    this.canvas.surface.hideTooltip();\n                }\n                this._updateAdorners();\n            }\n            return this._zoom;\n        }\n        /** @hidden */\n        _getPan(pan) {\n            const canvas = this.canvas;\n            if (!canvas.translate) {\n                pan = pan.plus(this._pan);\n            }\n            return pan;\n        }\n        /**\n         * Gets or sets the pan offset of the diagram.\n         * @param pan The pan offset as a Point. If not provided, returns the current pan.\n         * @param animate Whether to animate the pan operation\n         * @returns The current pan offset when used as a getter\n         */\n        pan(pan, animate) {\n            if (pan instanceof Point) {\n                const scroller = this.scroller;\n                pan = this._getPan(pan);\n                pan = pan.times(-1);\n                if (animate) {\n                    scroller.animatedScrollTo(pan.x, pan.y, () => {\n                        this._updateAdorners();\n                    });\n                }\n                else {\n                    scroller.scrollTo(pan.x, pan.y);\n                    this._updateAdorners();\n                }\n            }\n            else {\n                return this._pan.times(-1);\n            }\n        }\n        /**\n         * Gets the viewport rectangle of the diagram.\n         * @returns A Rect representing the current viewport\n         */\n        viewport() {\n            const element = this.element;\n            const width = elementWidth(element);\n            let height = elementHeight(element);\n            if (this.toolBar) {\n                height -= outerHeight(this.toolBar.element);\n            }\n            return new Rect(0, 0, width, height);\n        }\n        /**\n         * Copies the currently selected items to the clipboard.\n         */\n        copy() {\n            if (this.options.copy.enabled) {\n                this._clipboard.length = 0;\n                this._copyOffset = 1;\n                for (let i = 0; i < this._selectedItems.length; i++) {\n                    const item = this._selectedItems[i];\n                    this._clipboard.push(item);\n                }\n            }\n        }\n        /**\n         * Cuts the currently selected items to the clipboard and removes them from the diagram.\n         */\n        cut() {\n            if (this.options.copy.enabled) {\n                this._clipboard.length = 0;\n                this._copyOffset = 0;\n                for (let i = 0; i < this._selectedItems.length; i++) {\n                    const item = this._selectedItems[i];\n                    this._clipboard.push(item);\n                }\n                this.remove(this._clipboard, true);\n            }\n        }\n        /**\n         * Pastes items from the clipboard into the diagram.\n         */\n        paste() {\n            if (this._clipboard.length > 0) {\n                let item, copied, i;\n                const mapping = {};\n                const elements = splitDiagramElements(this._clipboard);\n                const connections = elements.connections;\n                const shapes = elements.shapes;\n                const offset = {\n                    x: this._copyOffset * this.options.copy.offsetX,\n                    y: this._copyOffset * this.options.copy.offsetY\n                };\n                this.deselect();\n                // first the shapes\n                for (i = 0; i < shapes.length; i++) {\n                    item = shapes[i];\n                    copied = item.clone();\n                    mapping[item.id] = copied;\n                    copied.position(new Point(item.options.x + offset.x, item.options.y + offset.y));\n                    copied.diagram = this;\n                    copied = this._addShape(copied);\n                    if (copied) {\n                        copied.select();\n                    }\n                }\n                // then the connections\n                for (i = 0; i < connections.length; i++) {\n                    item = connections[i];\n                    copied = this._addConnection(item.clone());\n                    if (copied) {\n                        this._updateCopiedConnection(copied, item, 'source', mapping, offset);\n                        this._updateCopiedConnection(copied, item, 'target', mapping, offset);\n                        copied.select(true);\n                        copied.updateModel();\n                    }\n                }\n                this._syncChanges();\n                this._copyOffset += 1;\n            }\n        }\n        /** @hidden */\n        _syncChanges() {\n            if (this.options._syncChanges) {\n                this.options._syncChanges();\n            }\n        }\n        /** @hidden */\n        _syncConnectionChanges() {\n            if (this.options._syncConnectionChanges) {\n                this.options._syncConnectionChanges();\n            }\n        }\n        /** @hidden */\n        _syncShapeChanges() {\n            if (this.options._syncShapeChanges) {\n                this.options._syncShapeChanges();\n            }\n        }\n        /** @hidden */\n        _updateCopiedConnection(connection, sourceConnection, connectorName, mapping, offset) {\n            let onActivate, inactiveItem, targetShape;\n            const target = sourceConnection[connectorName]();\n            if (target instanceof Connector && mapping[target.shape.id]) {\n                targetShape = mapping[target.shape.id];\n                if (this.getShapeById(targetShape.id)) {\n                    connection[connectorName](targetShape.getConnector(target.options.name));\n                }\n                else {\n                    inactiveItem = this._inactiveShapeItems.getByUid(targetShape.dataItem.uid);\n                    if (inactiveItem) {\n                        onActivate = (item) => {\n                            targetShape = this._dataMap[item.id];\n                            connection[connectorName](targetShape.getConnector(target.options.name));\n                            connection.updateModel();\n                        };\n                        this._deferredConnectionUpdates.push(inactiveItem.onActivate(onActivate));\n                    }\n                }\n            }\n            else {\n                connection[connectorName](new Point(sourceConnection[connectorName + 'Point']().x + offset.x, sourceConnection[connectorName + 'Point']().y + offset.y));\n            }\n        }\n        /**\n         * Gets the bounding rectangle of the given items.\n         *\n         * @param items DiagramElement, Array of elements.\n         * @param origin Boolean. Pass 'true' if you need to get the bounding box of the shapes without their rotation offset.\n         * @returns {Rect} The bounding rectangle of the items.\n         */\n        boundingBox(items, origin) {\n            let rect = Rect.empty(), temp;\n            const di = isDefined(items) ? this._getDiagramItems(items) : { shapes: this.shapes };\n            if (di.shapes.length > 0) {\n                let item = di.shapes[0];\n                rect = item.bounds(ROTATED);\n                for (let i = 1; i < di.shapes.length; i++) {\n                    item = di.shapes[i];\n                    temp = item.bounds(ROTATED);\n                    if (origin === true) {\n                        temp.x -= item._rotationOffset.x;\n                        temp.y -= item._rotationOffset.y;\n                    }\n                    rect = rect.union(temp);\n                }\n            }\n            return rect;\n        }\n        /** @hidden */\n        _containerOffset() {\n            const containerOffset = elementOffset(this.element);\n            if (this.toolBar) {\n                containerOffset.top += outerHeight(this.toolBar.element);\n            }\n            return containerOffset;\n        }\n        /**\n         * Converts a point from document coordinates to view coordinates.\n         * @param point The point in document coordinates\n         * @returns The point in view coordinates\n         */\n        documentToView(point) {\n            const containerOffset = this._containerOffset();\n            return new Point(point.x - containerOffset.left, point.y - containerOffset.top);\n        }\n        /**\n         * Converts a point from view coordinates to document coordinates.\n         * @param point The point in view coordinates\n         * @returns The point in document coordinates\n         */\n        viewToDocument(point) {\n            const containerOffset = this._containerOffset();\n            return new Point(point.x + containerOffset.left, point.y + containerOffset.top);\n        }\n        /**\n         * Converts a point from view coordinates to model coordinates.\n         * @param point The point in view coordinates\n         * @returns The point in model coordinates\n         */\n        viewToModel(point) {\n            return this._transformWithMatrix(point, this._matrixInvert);\n        }\n        /**\n         * Converts a point from model coordinates to view coordinates.\n         * @param point The point in model coordinates\n         * @returns The point in view coordinates\n         */\n        modelToView(point) {\n            return this._transformWithMatrix(point, this._matrix);\n        }\n        /**\n         * Converts a point from model coordinates to layer coordinates.\n         * @param point The point in model coordinates\n         * @returns The point in layer coordinates\n         */\n        modelToLayer(point) {\n            return this._transformWithMatrix(point, this._layerMatrix);\n        }\n        /**\n         * Converts a point from layer coordinates to model coordinates.\n         * @param point The point in layer coordinates\n         * @returns The point in model coordinates\n         */\n        layerToModel(point) {\n            return this._transformWithMatrix(point, this._layerMatrixInvert);\n        }\n        /**\n         * Converts a point from document coordinates to model coordinates.\n         * @param point The point in document coordinates\n         * @returns The point in model coordinates\n         */\n        documentToModel(point) {\n            const viewPoint = this.documentToView(point);\n            if (!this.canvas.translate) {\n                viewPoint.x = viewPoint.x + this.scroller.scrollLeft;\n                viewPoint.y = viewPoint.y + this.scroller.scrollTop;\n            }\n            return this.viewToModel(viewPoint);\n        }\n        /**\n         * Converts a point from model coordinates to document coordinates.\n         * @param point The point in model coordinates\n         * @returns The point in document coordinates\n         */\n        modelToDocument(point) {\n            return this.viewToDocument(this.modelToView(point));\n        }\n        /** @hidden */\n        _transformWithMatrix(point, matrix) {\n            let result = point;\n            if (point instanceof Point) {\n                if (matrix) {\n                    result = matrix.apply(point);\n                }\n            }\n            else {\n                const tl = this._transformWithMatrix(point.topLeft(), matrix), br = this._transformWithMatrix(point.bottomRight(), matrix);\n                result = Rect.fromPoints(tl, br);\n            }\n            return result;\n        }\n        /**\n         * Performs a diagram layout of the given type.\n         *\n         * @param layoutType The layout algorithm to be applied (TreeLayout, LayeredLayout, SpringLayout).\n         * @param options Layout-specific options.\n         */\n        layout(options) {\n            this._layouting = true;\n            // TODO: raise layout event?\n            let type;\n            if (isUndefined(options)) {\n                options = this.options.layout;\n            }\n            if (isUndefined(options) || isUndefined(options.type)) {\n                type = 'Tree';\n            }\n            else {\n                type = options.type;\n            }\n            let l;\n            switch (type.toLowerCase()) {\n                case 'tree':\n                    l = new TreeLayout(this);\n                    break;\n                case 'layered':\n                    l = new LayeredLayout(this);\n                    break;\n                case 'forcedirected':\n                case 'force':\n                case 'spring':\n                case 'springembedder':\n                    l = new SpringLayout(this);\n                    break;\n                default:\n                    throw new Error('Layout algorithm \\'' + type + '\\' is not supported.');\n            }\n            const initialState = new LayoutState(this);\n            const finalState = l.layout(options);\n            if (finalState) {\n                const unit = new LayoutUndoUnit(initialState, finalState, options ? options.animate : null);\n                this.undoRedoService.add(unit);\n            }\n            this._layouting = false;\n            this._redrawConnections();\n        }\n        /**\n         * Gets a shape by its unique identifier.\n         * @param {string} id The unique identifier of the shape\n         * @returns {Shape} The shape with the specified ID, or undefined if not found\n         */\n        getShapeById(id) {\n            let found;\n            found = first(this.shapes, function (s) {\n                return s.visual.id === id;\n            });\n            if (found) {\n                return found;\n            }\n            found = first(this.connections, function (c) {\n                return c.visual.id === id;\n            });\n            return found;\n        }\n        /**\n         * Gets a shape by its model ID.\n         * @param id The model ID of the shape\n         * @returns The shape with the specified model ID, or undefined if not found\n         */\n        getShapeByModelId(id) {\n            let shapeResult;\n            if (this._isEditable) {\n                shapeResult = this._dataMap[id];\n            }\n            else {\n                shapeResult = first(this.shapes, function (shape) {\n                    return (shape.dataItem || {}).id === id;\n                });\n            }\n            return shapeResult;\n        }\n        /**\n         * Gets a shape by its model UID.\n         * @param uid The model UID of the shape\n         * @returns The shape with the specified model UID, or undefined if not found\n         */\n        getShapeByModelUid(uid) {\n            let shapeResult;\n            if (this._isEditable) {\n                shapeResult = first(this.shapes, function (shape) {\n                    return (shape.dataItem || {}).uid === uid;\n                });\n            }\n            else {\n                shapeResult = this._dataMap[uid];\n            }\n            return shapeResult;\n        }\n        /** @hidden */\n        _extendLayoutOptions(options) {\n            if (options.layout) {\n                options.layout = deepExtend({}, LayoutDefaultOptions, options.layout);\n            }\n        }\n        /** @hidden */\n        _selectionChanged(selected, deselected) {\n            if (selected.length || deselected.length) {\n                this.trigger(SELECT$1, { selected: selected, deselected: deselected });\n            }\n        }\n        /** @hidden */\n        _getValidZoom(zoom) {\n            return Math.min(Math.max(zoom, this.options.zoomMin), this.options.zoomMax);\n        }\n        /** @hidden */\n        _panTransform(pos) {\n            const pan = pos || this._pan;\n            if (this.canvas.translate) {\n                this.scroller.scrollTo(pan.x, pan.y);\n                this._zoomMainLayer();\n            }\n            else {\n                this._storePan(pan);\n                this._transformMainLayer();\n            }\n        }\n        /** @hidden */\n        _finishPan() {\n            this.trigger(PAN, { total: this._pan, delta: Number.NaN });\n        }\n        /** @hidden */\n        _storePan(pan) {\n            this._pan = pan;\n            this._storeViewMatrix();\n        }\n        /** @hidden */\n        _zoomMainLayer() {\n            const zoom = this._zoom;\n            const transform = new CompositeTransform(0, 0, zoom, zoom);\n            transform.render(this.mainLayer);\n            this._storeLayerMatrix(transform);\n            this._storeViewMatrix();\n        }\n        /** @hidden */\n        _transformMainLayer() {\n            const pan = this._pan, zoom = this._zoom;\n            const transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n            transform.render(this.mainLayer);\n            this._storeLayerMatrix(transform);\n            this._storeViewMatrix();\n        }\n        /** @hidden */\n        _storeLayerMatrix(canvasTransform) {\n            this._layerMatrix = canvasTransform.toMatrix();\n            this._layerMatrixInvert = canvasTransform.invert().toMatrix();\n        }\n        /** @hidden */\n        _storeViewMatrix() {\n            const pan = this._pan, zoom = this._zoom;\n            const transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n            this._matrix = transform.toMatrix();\n            this._matrixInvert = transform.invert().toMatrix();\n        }\n        /** @hidden */\n        _toIndex(items, indices) {\n            const result = this._getDiagramItems(items);\n            this.mainLayer.toIndex(result.visuals, indices);\n            this._fixOrdering(result, false);\n        }\n        /** @hidden */\n        _fixOrdering(result, toFront) {\n            const shapePos = toFront ? this.shapes.length - 1 : 0, conPos = toFront ? this.connections.length - 1 : 0;\n            let i, item;\n            for (i = 0; i < result.shapes.length; i++) {\n                item = result.shapes[i];\n                remove(this.shapes, item);\n                insert(this.shapes, item, shapePos);\n            }\n            for (i = 0; i < result.cons.length; i++) {\n                item = result.cons[i];\n                remove(this.connections, item);\n                insert(this.connections, item, conPos);\n            }\n        }\n        /** @hidden */\n        _getDiagramItems(items) {\n            let i, args = items;\n            const result = {};\n            result.visuals = [];\n            result.shapes = [];\n            result.cons = [];\n            if (!items) {\n                args = this._selectedItems.slice();\n            }\n            else if (!Array.isArray(items)) {\n                args = [items];\n            }\n            for (i = 0; i < args.length; i++) {\n                const item = args[i];\n                if (item instanceof Shape) {\n                    result.shapes.push(item);\n                    result.visuals.push(item.visual);\n                }\n                else if (item instanceof Connection) {\n                    result.cons.push(item);\n                    result.visuals.push(item.visual);\n                }\n            }\n            return result;\n        }\n        /** @hidden */\n        _addDataItemByUid(dataItem) {\n            if (!defined(dataItem)) {\n                return;\n            }\n            let shape = this._dataMap[dataItem.uid];\n            if (shape) {\n                return shape;\n            }\n            const options = deepExtend({}, this.options.shapeDefaults);\n            options.dataItem = dataItem;\n            shape = new Shape(options, this);\n            this.addShape(shape);\n            this._dataMap[dataItem.uid] = shape;\n            return shape;\n        }\n        /** @hidden */\n        _addItem(item) {\n            if (item instanceof Shape) {\n                this.addShape(item);\n            }\n            else if (item instanceof Connection) {\n                this.addConnection(item);\n            }\n        }\n        /** @hidden */\n        _toolBarClick(e) {\n            this.trigger('toolBarClick', e);\n            this._destroyToolBar();\n        }\n        /** @hidden */\n        _normalizePointZoom(point) {\n            return point.times(1 / this.zoom());\n        }\n        /** @hidden */\n        _initialize() {\n            this.shapes.length = 0;\n            this.connections.length = 0;\n            this._selectedItems.length = 0;\n            Object.keys(this._dataMap).forEach((key) => {\n                delete this._dataMap[key];\n            });\n            Object.keys(this._connectionsDataMap).forEach((key) => {\n                delete this._connectionsDataMap[key];\n            });\n            this._deferredConnectionUpdates.length = 0;\n            this.undoRedoService = new UndoRedoService({\n                undone: this._syncChanges.bind(this),\n                redone: this._syncChanges.bind(this)\n            });\n            this.undoRedoService.bind('undo', (args) => {\n                this.trigger('undo', args);\n            });\n            this.undoRedoService.bind('redo', (args) => {\n                this.trigger('redo', args);\n            });\n            this.id = randomId();\n        }\n        /** @hidden */\n        _redrawConnections() {\n            const connections = this.connections;\n            for (let idx = 0; idx < connections.length; idx++) {\n                connections[idx].refresh();\n            }\n        }\n        /** @hidden */\n        _adorn(adorner, isActive) {\n            if (isActive !== undefined && adorner) {\n                if (isActive) {\n                    this._adorners.push(adorner);\n                    this.adornerLayer.append(adorner.visual);\n                }\n                else {\n                    remove(this._adorners, adorner);\n                    this.adornerLayer.remove(adorner.visual);\n                }\n            }\n        }\n        /** @hidden */\n        _showConnectors(shape, value) {\n            if (value) {\n                this._connectorsAdorner.show(shape);\n            }\n            else {\n                this._connectorsAdorner.destroy();\n            }\n        }\n        /** @hidden */\n        _updateAdorners() {\n            const adorners = this._adorners;\n            for (let i = 0; i < adorners.length; i++) {\n                const adorner = adorners[i];\n                if (adorner.refreshBounds) {\n                    adorner.refreshBounds();\n                }\n                adorner.refresh();\n            }\n        }\n        /** @hidden */\n        _refresh() {\n            for (let i = 0; i < this.connections.length; i++) {\n                this.connections[i].refresh();\n            }\n        }\n        /** @hidden */\n        _removeItem(item, undoable, removedConnections) {\n            item.select(false);\n            if (item instanceof Shape) {\n                this._removeShapeDataItem(item);\n                this._removeShape(item, undoable, removedConnections);\n            }\n            else if (item instanceof Connection) {\n                this._removeConnectionDataItem(item);\n                this._removeConnection(item, undoable);\n            }\n            this.mainLayer.remove(item.visual);\n        }\n        /** @hidden */\n        _removeConnectionDataItem(item) {\n            if (this._isEditable) {\n                this.options._removeConnectionDataItem(item.dataItem);\n                delete this._connectionsDataMap[item.dataItem.uid];\n            }\n        }\n        /** @hidden */\n        _removeShapeDataItem(item) {\n            if (this._isEditable) {\n                this.options._removeShapeDataItem(item.dataItem);\n                delete this._dataMap[item.dataItem.id];\n            }\n        }\n        /** @hidden */\n        _removeShape(shape, undoable, removedConnections) {\n            let i, connection, connector;\n            const sources = [], targets = [];\n            this.toolService._removeHover();\n            if (undoable) {\n                this.undoRedoService.addCompositeItem(new DeleteShapeUnit(shape));\n            }\n            remove(this.shapes, shape);\n            this._shapesQuadTree.remove(shape);\n            for (i = 0; i < shape.connectors.length; i++) {\n                connector = shape.connectors[i];\n                for (let j = 0; j < connector.connections.length; j++) {\n                    connection = connector.connections[j];\n                    if (!removedConnections || !contains(removedConnections, connection)) {\n                        if (connection.sourceConnector === connector) {\n                            sources.push(connection);\n                        }\n                        else if (connection.targetConnector === connector) {\n                            targets.push(connection);\n                        }\n                    }\n                }\n            }\n            for (i = 0; i < sources.length; i++) {\n                sources[i].source(null, undoable);\n                sources[i].updateModel();\n            }\n            for (i = 0; i < targets.length; i++) {\n                targets[i].target(null, undoable);\n                targets[i].updateModel();\n            }\n        }\n        /** @hidden */\n        _removeConnection(connection, undoable) {\n            if (connection.sourceConnector) {\n                remove(connection.sourceConnector.connections, connection);\n            }\n            if (connection.targetConnector) {\n                remove(connection.targetConnector.connections, connection);\n            }\n            if (undoable) {\n                this.undoRedoService.addCompositeItem(new DeleteConnectionUnit(connection));\n            }\n            remove(this.connections, connection);\n        }\n        /** @hidden */\n        _removeShapeConnections(shape) {\n            const connections = shape.connections();\n            let idx;\n            if (connections) {\n                for (idx = 0; idx < connections.length; idx++) {\n                    this._removeItem(connections[idx], false);\n                }\n            }\n        }\n        /** @hidden */\n        _destroyToolBar() {\n            this.options.destroyToolBar();\n        }\n        /** @hidden */\n        _destroyGlobalToolBar() {\n            if (this.toolBar) {\n                this.toolBar = null;\n            }\n        }\n        /** @hidden */\n        _mobileOS() {\n            return kendo_common_cmn_chunk_js.m;\n        }\n        /**\n         * Exports the diagram's DOM visual representation for rendering or export purposes.\n         * Creates a clipped group containing the canvas content with proper transformations.\n         * @returns A drawing Group element containing the exported DOM visual\n         */\n        exportDOMVisual() {\n            const viewBox = this.canvas._viewBox;\n            const scrollOffset = kendo_drawing_cmn_chunk_js.t()\n                .translate(-viewBox.x, -viewBox.y);\n            const viewRect = new kendo_drawing_cmn_chunk_js.R([0, 0], [viewBox.width, viewBox.height]);\n            const clipPath = kendo_drawing_cmn_chunk_js.a.fromRect(viewRect);\n            const wrap = new kendo_drawing_cmn_chunk_js.G({ transform: scrollOffset });\n            const clipWrap = new kendo_drawing_cmn_chunk_js.G({ clip: clipPath });\n            const root = this.canvas.drawingElement.children[0];\n            clipWrap.append(wrap);\n            // Don't reparent the root\n            wrap.children.push(root);\n            return clipWrap;\n        }\n        /**\n         * Exports the diagram's visual representation with proper scaling based on zoom level.\n         * Creates a scaled group containing the main layer content.\n         * @returns A drawing Group element containing the exported visual with inverse zoom scaling\n         */\n        exportVisual() {\n            const scaleX = 1 / this._zoom;\n            const scale = kendo_drawing_cmn_chunk_js.t().scale(scaleX, scaleX);\n            const wrap = new kendo_drawing_cmn_chunk_js.G({\n                transform: scale\n            });\n            const root = this.mainLayer.drawingElement;\n            wrap.children.push(root);\n            return wrap;\n        }\n        /**\n         * Updates the connection's underlying data model.\n         * Calls the configured updateConnectionModel function if available.\n         * @param connection The connection whose model should be updated\n         * @param syncChanges Whether to synchronize changes immediately\n         * @returns The result of the update operation, if any\n         */\n        updateConnectionModel(connection, syncChanges) {\n            if (this.options.updateConnectionModel) {\n                return this.options.updateConnectionModel(connection, syncChanges);\n            }\n        }\n        /**\n         * Updates the shape's underlying data model.\n         * Calls the configured updateShapeModel function if available.\n         * @param shape The shape whose model should be updated\n         * @param syncChanges Whether to synchronize changes immediately\n         * @returns The result of the update operation, if any\n         */\n        updateShapeModel(shape, syncChanges) {\n            if (this.options.updateShapeModel) {\n                return this.options.updateShapeModel(shape, syncChanges);\n            }\n        }\n    }\n\n    const elementStyles = (element) => element.ownerDocument.defaultView.getComputedStyle(element);\n    const cache = {};\n    const toColor = (colorMix, element) => {\n        if (cache[colorMix]) {\n            return cache[colorMix];\n        }\n        const curColor = element.style.color;\n        element.style.color = colorMix;\n        const color = elementStyles(element).color;\n        element.style.color = curColor;\n        cache[colorMix] = color;\n        return color;\n    };\n    const getProp = (element, prop) => {\n        let value = elementStyles(element).getPropertyValue(prop);\n        if (/^color-mix/i.test(value)) {\n            value = toColor(value, element);\n        }\n        return value;\n    };\n    const loadTheme = (element) => {\n        const primaryBg = getProp(element, '--kendo-chart-primary-bg');\n        const primaryContrast = getProp(element, '--kendo-chart-primary-contrast');\n        const normalTextColor = getProp(element, '--kendo-chart-text');\n        const normalBackground = getProp(element, '--kendo-color-surface');\n        return {\n            shapeDefaults: {\n                fill: {\n                    color: primaryBg\n                },\n                content: {\n                    color: primaryContrast\n                },\n                connectorDefaults: {\n                    fill: {\n                        color: normalTextColor\n                    },\n                    stroke: {\n                        color: primaryContrast\n                    },\n                    hover: {\n                        fill: {\n                            color: primaryContrast\n                        },\n                        stroke: {\n                            color: normalTextColor\n                        }\n                    }\n                }\n            },\n            editable: {\n                resize: {\n                    handles: {\n                        stroke: {\n                            color: normalTextColor\n                        },\n                        fill: {\n                            color: normalBackground\n                        },\n                        hover: {\n                            stroke: {\n                                color: normalTextColor\n                            },\n                            fill: {\n                                color: normalTextColor\n                            }\n                        }\n                    }\n                }\n            },\n            selectable: {\n                stroke: {\n                    color: normalTextColor\n                }\n            },\n            connectionDefaults: {\n                stroke: {\n                    color: normalTextColor\n                },\n                content: {\n                    color: normalTextColor\n                },\n                selection: {\n                    handles: {\n                        fill: {\n                            color: primaryContrast\n                        },\n                        stroke: {\n                            color: normalTextColor\n                        },\n                        width: 8,\n                        height: 8\n                    },\n                    stroke: {\n                        color: normalTextColor\n                    }\n                }\n            }\n        };\n    };\n\n    exports.$ = MarkerBase;\n    exports.A = Document;\n    exports.B = PredefinedProcess;\n    exports.C = Canvas$1;\n    exports.D = Dictionary;\n    exports.E = Extract;\n    exports.F = Decision;\n    exports.G = Graph;\n    exports.H = HashTable;\n    exports.I = Intersect;\n    exports.J = Process;\n    exports.K = Terminator;\n    exports.L = Link;\n    exports.M = MatrixVector;\n    exports.N = Node;\n    exports.O = OffPageConnector;\n    exports.P = PathDefiner;\n    exports.Q = Queue;\n    exports.R = Range;\n    exports.S = Set;\n    exports.T = Ticker;\n    exports.U = Utils$1;\n    exports.V = VisualBase;\n    exports.W = TextBlock;\n    exports.X = CompositeTransform;\n    exports.Y = Polyline;\n    exports.Z = CircleMarker;\n    exports._ = ArrowMarker;\n    exports.__meta__ = __meta__;\n    exports.a = Matrix;\n    exports.a0 = Line;\n    exports.a1 = Layout;\n    exports.a2 = Path;\n    exports.a3 = Rectangle;\n    exports.a4 = Group;\n    exports.a5 = Circle;\n    exports.a6 = Rotation;\n    exports.a7 = Translation;\n    exports.a8 = Scale;\n    exports.a9 = Element;\n    exports.aA = AddShapeUnit;\n    exports.aB = PanUndoUnit;\n    exports.aC = TransformUnit;\n    exports.aD = CompositeUnit;\n    exports.aE = LayoutState;\n    exports.aF = LayoutBase;\n    exports.aG = LayeredLayout;\n    exports.aH = DiagramToHyperTreeAdapter;\n    exports.aI = TreeLayout;\n    exports.aJ = SpringLayout;\n    exports.aK = TemplateService;\n    exports.aL = DefaultConnectors;\n    exports.aM = shapeDefaults;\n    exports.aN = defined;\n    exports.aO = Shape;\n    exports.aP = events;\n    exports.aQ = Connection;\n    exports.aR = first;\n    exports.aS = defaultOptions;\n    exports.aT = Diagram;\n    exports.aU = ShapesQuadTree;\n    exports.aV = QuadRoot;\n    exports.aW = QuadNode;\n    exports.aX = Connector;\n    exports.aa = Markers;\n    exports.ab = diffNumericOptions;\n    exports.ac = Cursors;\n    exports.ad = RotateUnit;\n    exports.ae = ConnectionEditTool;\n    exports.af = PointerTool;\n    exports.ag = ScrollerTool;\n    exports.ah = SelectionTool;\n    exports.ai = CascadingRouter;\n    exports.aj = PolylineRouter;\n    exports.ak = ConnectionRouterBase;\n    exports.al = ToBackUnit;\n    exports.am = ToFrontUnit;\n    exports.an = ConnectionEditUnit;\n    exports.ao = LayoutUndoUnit;\n    exports.ap = ConnectorsAdorner;\n    exports.aq = ToolService;\n    exports.ar = Selector;\n    exports.as = ResizingAdorner;\n    exports.at = UndoRedoService;\n    exports.au = ConnectorVisual;\n    exports.av = ConnectionTool;\n    exports.aw = ConnectionEditAdorner;\n    exports.ax = DeleteConnectionUnit;\n    exports.ay = DeleteShapeUnit;\n    exports.az = AddConnectionUnit;\n    exports.b = RectAlign;\n    exports.c = Size;\n    exports.d = Rect;\n    exports.e = Geometry;\n    exports.f = Point;\n    exports.g = Image;\n    exports.h = MultipleDocuments;\n    exports.i = Collate;\n    exports.j = Sort;\n    exports.k = Delay;\n    exports.l = DataStorage;\n    exports.m = Merge;\n    exports.n = normalVariable;\n    exports.o = LogicalOr;\n    exports.p = SummingJunction;\n    exports.q = DataInputOutput;\n    exports.r = randomId;\n    exports.s = OnPageConnector;\n    exports.t = Database;\n    exports.u = DirectAccessStorage;\n    exports.v = Display;\n    exports.w = InternalStorage;\n    exports.x = ManualOperation;\n    exports.y = Preparation;\n    exports.z = ManualInputOutput;\n\n}));\n"]}