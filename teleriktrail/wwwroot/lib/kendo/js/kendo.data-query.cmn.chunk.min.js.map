{"version":3,"sources":["raw-js/kendo.data-query.cmn.chunk.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","kendo","_globals","DataQueryCmnChunk","this","isPresent","value","isBlank","isArray","Array","isFunction","isString","isNotNullOrEmptyString","trim","length","isNullOrEmptyString","isDate","getTime","isCompositeFilterDescriptor","source","filters","Object","create","SuppressedError","ifElse","predicate","right","left","compose","args","_i","arguments","data","reduceRight","acc","curr","toUTC","date","Date","UTC","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","isDateValue","x","getterCache","FIELD_REGEX","obj","getter","field","safe","key","fields","replace","_","index","indexAccessor","push","result","idx","pairwise","empty","has","accessor","isNotEmpty","isNotEmptyArray","runOrEmpty","fn","formatDescriptors","formatter","state","map","join","sanitizeDateLiterals","apply","_a","s","RegExp","removeAfterDot","what","str","slice","indexOf","directionFormatter","_b","dir","concat","take$1","aggregates","skip$1","group","sort","formatSort","formatGroup","formatAggregates","aggregate","formatDateValue","JSON","stringify","transformSkip","skip","take","Math","floor","transformTake","transformGroup","transformSort","transformAggregates","assign","filter","filterFormatter","operator","ignoreCase","set","target","prop","fieldName","g1","toLowerCase","convert","mapper","values","keys","reduce","bind","translateAggregate","translateAggregates","valueOrDefault","defaultValue","translateGroup","hasSubgroups","items","Aggregates","Member","member","HasSubgroups","Items","Key","transform","logic","or","a","identity","and","operatorsMap","contains","b","doesnotcontain","doesnotendwith","doesnotstartwith","lastIndexOf","endswith","eq","gt","gte","isempty","isnotempty","isnotnull","isnull","lt","lte","neq","startswith","dateRegExp","transformFilter","itemProp","exec","stringValue","typedGetter","convertValue","op","transformCompositeFilter","combiner","compileFilter","descriptor","FilterOperator","__meta__","id","name","category","description","depends","hidden","chunk","c"],"mappings":"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","file":"kendo.data-query.cmn.chunk.min.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.kendo = global.kendo || {}, global.kendo._globals = global.kendo._globals || {}, global.kendo._globals.DataQueryCmnChunk = {})));\n})(this, (function (exports) {\n  const __meta__ = {\n      id: \"data-query.cmn.chunk\",\n      name: \"DataQueryCmnChunk\",\n      category: \"web\",\n      description: \"A reusable outputed chunk of code\",\n      depends: [],\n      hidden: true,\n      chunk: true,\n      \n  };\n\n  /**\n   * @hidden\n   */\n  var isPresent = function (value) { return value !== null && value !== undefined; };\n  /**\n   * @hidden\n   */\n  var isBlank = function (value) { return value === null || value === undefined; };\n  /**\n   * @hidden\n   */\n  var isArray = function (value) { return Array.isArray(value); };\n  /**\n   * @hidden\n   */\n  var isFunction = function (value) { return typeof value === 'function'; };\n  /**\n   * @hidden\n   */\n  var isString = function (value) { return typeof value === 'string'; };\n  /**\n   * @hidden\n   */\n  var isTruthy = function (value) { return !!value; };\n  /**\n   * @hidden\n   */\n  var isNullOrEmptyString = function (value) { return isBlank(value) || value.trim().length === 0; };\n  /**\n   * @hidden\n   */\n  var isNotNullOrEmptyString = function (value) { return !isNullOrEmptyString(value); };\n  /**\n   * @hidden\n   */\n  var isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };\n  /**\n   * @hidden\n   */\n  var isDate = function (value) { return value && value.getTime; };\n\n  // tslint:enable:max-line-length\n  /**\n   * @hidden\n   * Type guard for `CompositeFilterDescriptor`.\n   */\n  var isCompositeFilterDescriptor = function (source) {\n      return isPresent(source.filters);\n  };\n\n  /******************************************************************************\n  Copyright (c) Microsoft Corporation.\n\n  Permission to use, copy, modify, and/or distribute this software for any\n  purpose with or without fee is hereby granted.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n  PERFORMANCE OF THIS SOFTWARE.\n  ***************************************************************************** */\n  /* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n    return extendStatics(d, b);\n  };\n\n  function __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  }\n\n  var __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n  };\n\n  function __rest(s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n  }\n\n  function __decorate(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  }\n\n  function __param(paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n  }\n\n  function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n  };\n\n  function __runInitializers(thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n  };\n\n  function __propKey(x) {\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\n  };\n\n  function __setFunctionName(f, name, prefix) {\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n  };\n\n  function __metadata(metadataKey, metadataValue) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n  }\n\n  function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  }\n\n  function __generator(thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n  }\n\n  var __createBinding = Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n  }) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n  });\n\n  function __exportStar(m, o) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n  }\n\n  function __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  }\n\n  function __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n  }\n\n  /** @deprecated */\n  function __spread() {\n    for (var ar = [], i = 0; i < arguments.length; i++)\n        ar = ar.concat(__read(arguments[i]));\n    return ar;\n  }\n\n  /** @deprecated */\n  function __spreadArrays() {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n  }\n\n  function __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n  }\n\n  function __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n  }\n\n  function __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n  }\n\n  function __asyncDelegator(o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n  }\n\n  function __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n  }\n\n  function __makeTemplateObject(cooked, raw) {\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n    return cooked;\n  };\n\n  var __setModuleDefault = Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n  }) : function(o, v) {\n    o[\"default\"] = v;\n  };\n\n  var ownKeys = function(o) {\n    ownKeys = Object.getOwnPropertyNames || function (o) {\n      var ar = [];\n      for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n      return ar;\n    };\n    return ownKeys(o);\n  };\n\n  function __importStar(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n    __setModuleDefault(result, mod);\n    return result;\n  }\n\n  function __importDefault(mod) {\n    return (mod && mod.__esModule) ? mod : { default: mod };\n  }\n\n  function __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n  }\n\n  function __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n  }\n\n  function __classPrivateFieldIn(state, receiver) {\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\n  }\n\n  function __addDisposableResource(env, value, async) {\n    if (value !== null && value !== void 0) {\n      if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n      var dispose, inner;\n      if (async) {\n        if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n        dispose = value[Symbol.asyncDispose];\n      }\n      if (dispose === void 0) {\n        if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n        dispose = value[Symbol.dispose];\n        if (async) inner = dispose;\n      }\n      if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n      if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n      env.stack.push({ value: value, dispose: dispose, async: async });\n    }\n    else if (async) {\n      env.stack.push({ async: true });\n    }\n    return value;\n  }\n\n  var _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n  };\n\n  function __disposeResources(env) {\n    function fail(e) {\n      env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    var r, s = 0;\n    function next() {\n      while (r = env.stack.pop()) {\n        try {\n          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n          if (r.dispose) {\n            var result = r.dispose.call(r.value);\n            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n          }\n          else s |= 1;\n        }\n        catch (e) {\n          fail(e);\n        }\n      }\n      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  }\n\n  function __rewriteRelativeImportExtension(path, preserveJsx) {\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n        });\n    }\n    return path;\n  }\n\n  var tslib_es6 = {\n    __extends,\n    __assign,\n    __rest,\n    __decorate,\n    __param,\n    __esDecorate,\n    __runInitializers,\n    __propKey,\n    __setFunctionName,\n    __metadata,\n    __awaiter,\n    __generator,\n    __createBinding,\n    __exportStar,\n    __values,\n    __read,\n    __spread,\n    __spreadArrays,\n    __spreadArray,\n    __await,\n    __asyncGenerator,\n    __asyncDelegator,\n    __asyncValues,\n    __makeTemplateObject,\n    __importStar,\n    __importDefault,\n    __classPrivateFieldGet,\n    __classPrivateFieldSet,\n    __classPrivateFieldIn,\n    __addDisposableResource,\n    __disposeResources,\n    __rewriteRelativeImportExtension,\n  };\n\n  /**\n   * @hidden\n   */\n  var ifElse = function (predicate, right, left) { return function (value) { return predicate(value) ? right(value) : left(value); }; };\n  /**\n   * @hidden\n   * Performs the right-to-left function composition. Functions should have a unary.\n   */\n  var compose = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n      }\n      return function (data) { return args.reduceRight(function (acc, curr) { return curr(acc); }, data); };\n  };\n  /**\n   * @hidden\n   */\n  var constant = function (x) { return function () { return x; }; };\n  /**\n   * @hidden\n   */\n  var identity$2 = function (x) { return x; };\n\n  /**\n   * @hidden\n   * Creates a single arity function which wraps the value based on the provided predicate.\n   * @example\n   * ```\n   * wrapIf(() => ignoreCase) `tolower(${field})`\n   * //ignoreCase=true -> tolower(${field})`\n   * //ignoreCase=false -> ${field}`\n   * ```\n   */\n  var wrapIf = function (predicate) { return function (str) {\n      var args = [];\n      for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i - 1] = arguments[_i];\n      }\n      return predicate() ? \"\".concat(str[0]).concat(args[0]).concat(str[1]) : args[0];\n  }; };\n  /**\n   * @hidden\n   */\n  var toUTC = function (date) {\n      return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));\n  };\n  /**\n   * @hidden\n   */\n  var quote = function (_a) {\n      var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n      return ({\n          value: \"'\".concat(value.replace(/'/g, \"''\"), \"'\"),\n          field: field,\n          ignoreCase: ignoreCase,\n          operator: operator\n      });\n  };\n  /**\n   * @hidden\n   */\n  var encodeValue = function (_a) {\n      var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n      return ({\n          value: \"\".concat(encodeURIComponent(value)),\n          field: field,\n          ignoreCase: ignoreCase,\n          operator: operator\n      });\n  };\n  /**\n   * @hidden\n   */\n  var toLower = function (_a) {\n      var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n      return ({\n          field: wrapIf(function () { return ignoreCase; })(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject([\"tolower(\", \")\"], [\"tolower(\", \")\"])), field),\n          value: value,\n          ignoreCase: ignoreCase,\n          operator: operator\n      });\n  };\n  /**\n   * @hidden\n   */\n  var normalizeField = function (_a) {\n      var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n      return ({\n          value: value,\n          field: field.replace(/\\./g, \"/\"),\n          ignoreCase: ignoreCase,\n          operator: operator\n      });\n  };\n  /**\n   * @hidden\n   */\n  var isStringValue = function (x) { return isString(x.value); };\n  /**\n   * @hidden\n   */\n  var isDateValue = function (x) { return isDate(x.value); };\n  /**\n   * @hidden\n   */\n  var serializeFilters = function (map, join) { return function (filter) {\n      var brackets = wrapIf(function () { return filter.filters.length > 1; });\n      return brackets(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject([\"(\", \")\"], [\"(\", \")\"])), filter.filters\n          .map(map)\n          .join(join(filter)));\n  }; };\n  var templateObject_1$1, templateObject_2$1;\n\n  var operatorMap = function (key) { return ({\n      \"!=\": \"neq\",\n      \"<\": \"lt\",\n      \"<=\": \"lte\",\n      \"==\": \"eq\",\n      \">\": \"gt\",\n      \">=\": \"gte\",\n      equal: \"eq\",\n      equals: \"eq\",\n      equalto: \"eq\",\n      ge: \"gte\",\n      greater: \"gt\",\n      greaterthan: \"gt\",\n      greaterthanequal: \"gte\",\n      isempty: \"isempty\",\n      isequalto: \"eq\",\n      isgreaterthan: \"gt\",\n      isgreaterthanorequalto: \"gte\",\n      islessthan: \"lt\",\n      islessthanorequalto: \"lte\",\n      isnotempty: \"isnotempty\",\n      isnotequalto: \"neq\",\n      isnull: \"isnull\",\n      le: \"lte\",\n      less: \"lt\",\n      lessthan: \"lt\",\n      lessthanequal: \"lte\",\n      ne: \"neq\",\n      notequal: \"neq\",\n      notequals: \"neq\",\n      notequalto: \"neq\",\n      notsubstringof: \"doesnotcontain\"\n  }[key.toLowerCase()] || key); };\n  var normalizeOperator = function (descriptor) {\n      if (descriptor.filters) {\n          descriptor.filters = descriptor.filters.map(function (filter) {\n              var result = Object.assign({}, filter);\n              if (!isCompositeFilterDescriptor(filter) && isString(filter.operator)) {\n                  result.operator = operatorMap(filter.operator);\n              }\n              if (isCompositeFilterDescriptor(filter)) {\n                  normalizeOperator(result);\n              }\n              return result;\n          });\n      }\n  };\n  var normalizeDescriptor = function (descriptor) {\n      if (!isCompositeFilterDescriptor(descriptor)) {\n          return {\n              filters: isArray(descriptor) ? descriptor : [descriptor],\n              logic: \"and\"\n          };\n      }\n      return Object.assign({}, descriptor);\n  };\n  // tslint:disable:max-line-length\n  /**\n   * Converts a [`FilterDescriptor`]({% slug api_kendo-data-query_filterdescriptor %}) into a [`CompositeFilterDescriptor`]({% slug api_kendo-data-query_compositefilterdescriptor %}). If a `CompositeFilterDescriptor` is passed, no modifications will be made.\n   *\n   * @param {CompositeFilterDescriptor | FilterDescriptor} descriptor - The descriptor that will be normalized.\n   * @returns {CompositeFilterDescriptor} - The normalized descriptor.\n   */\n  // tslint:enable:max-line-length\n  var normalizeFilters = function (descriptor) {\n      if (isPresent(descriptor)) {\n          descriptor = normalizeDescriptor(descriptor);\n          normalizeOperator(descriptor);\n      }\n      return descriptor;\n  };\n\n  var formatDate$1 = function (_a) {\n      var utcDates = _a.utcDates;\n      return function (_a) {\n          var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n          return ({\n              value: (!utcDates ? toUTC(value) : value).toISOString(),\n              field: field,\n              ignoreCase: ignoreCase,\n              operator: operator\n          });\n      };\n  };\n  var fnFormatter = function (_a) {\n      var operator = _a.operator;\n      return function (_a) {\n          var field = _a.field, value = _a.value;\n          return \"\".concat(operator, \"(\").concat(field, \",\").concat(value, \")\");\n      };\n  };\n  var singleOperatorFormatter = function (_a) {\n      var operator = _a.operator;\n      return function (_a) {\n          var field = _a.field, value = _a.value;\n          return \"\".concat(field, \" \").concat(operator, \" \").concat(value);\n      };\n  };\n  var stringFormat = function (formatter) { return compose(formatter, encodeValue, quote, toLower, normalizeField); };\n  var stringFnOperator = function (settings) { return stringFormat(fnFormatter(settings)); };\n  var stringOperator = function (settings) { return stringFormat(singleOperatorFormatter(settings)); };\n  var numericOperator = function (settings) { return compose(singleOperatorFormatter(settings), normalizeField); };\n  var dateOperator = function (settings) { return compose(singleOperatorFormatter(settings), normalizeField, formatDate$1(settings)); };\n  var ifDate = function (settings) { return ifElse(isDateValue, dateOperator(settings), numericOperator(settings)); };\n  var typedOperator = function (settings) { return ifElse(isStringValue, stringOperator(settings), ifDate(settings)); };\n  var appendEqual = function (str) { return \"\".concat(str, \" eq -1\"); };\n  var nonValueExpression = function (formatter) { return compose(formatter, normalizeField); };\n  var filterOperators = function (operator, settings) { return ({\n      contains: stringFnOperator(__assign(__assign({}, settings), { operator: \"contains\" })),\n      doesnotcontain: compose(appendEqual, stringFnOperator(__assign(__assign({}, settings), { operator: \"indexof\" }))),\n      endswith: stringFnOperator(__assign(__assign({}, settings), { operator: \"endswith\" })),\n      eq: typedOperator(__assign(__assign({}, settings), { operator: \"eq\" })),\n      gt: typedOperator(__assign(__assign({}, settings), { operator: \"gt\" })),\n      gte: typedOperator(__assign(__assign({}, settings), { operator: \"ge\" })),\n      isempty: nonValueExpression(function (_a) {\n          var field = _a.field;\n          return \"\".concat(field, \" eq ''\");\n      }),\n      isnotempty: nonValueExpression(function (_a) {\n          var field = _a.field;\n          return \"\".concat(field, \" ne ''\");\n      }),\n      isnotnull: nonValueExpression(function (_a) {\n          var field = _a.field;\n          return \"\".concat(field, \" ne null\");\n      }),\n      isnull: nonValueExpression(function (_a) {\n          var field = _a.field;\n          return \"\".concat(field, \" eq null\");\n      }),\n      lt: typedOperator(__assign(__assign({}, settings), { operator: \"lt\" })),\n      lte: typedOperator(__assign(__assign({}, settings), { operator: \"le\" })),\n      neq: typedOperator(__assign(__assign({}, settings), { operator: \"ne\" })),\n      startswith: stringFnOperator(__assign(__assign({}, settings), { operator: \"startswith\" }))\n  }[operator]); };\n  var join$1 = function (x) { return \" \".concat(x.logic, \" \"); };\n  var serialize$1 = function (settings) { return function (x) { return filterOperators(x.operator, settings)(x); }; };\n  var serializeAll = function (settings) { return serializeFilters(function (filter) { return ifElse(isCompositeFilterDescriptor, serializeAll(settings), serialize$1(settings))(filter); }, join$1); };\n  /**\n   * @hidden\n   */\n  var serializeFilter$1 = function (filter, settings) {\n      if (settings === void 0) { settings = {}; }\n      if (filter.filters && filter.filters.length) {\n          return \"$filter=\" + serializeAll(settings)(normalizeFilters(filter));\n      }\n      return \"\";\n  };\n\n  var serializeSort$1 = function (orderby) {\n      var str = orderby\n          .filter(function (sort) { return isPresent(sort.dir); })\n          .map(function (sort) {\n          var order = sort.field.replace(/\\./g, \"/\");\n          return sort.dir === \"desc\" ? order + \" desc\" : order;\n      }).join(\",\");\n      return str ? \"$orderby=\".concat(str) : str;\n  };\n  var emptyString = constant('');\n  var concat$1 = function (a) { return function (b) { return a + b; }; };\n  var serializeKey = function (strings, val) { return ifElse(isPresent, concat$1(strings[0]), emptyString)(val); };\n  var rules$1 = function (settings, state) { return function (key) { return ({\n      \"filter\": serializeFilter$1(state.filter || {}, settings),\n      \"skip\": serializeKey(templateObject_1 || (templateObject_1 = __makeTemplateObject([\"$skip=\", \"\"], [\"$skip=\", \"\"])), state.skip),\n      \"sort\": serializeSort$1(state.sort || []),\n      \"take\": serializeKey(templateObject_2 || (templateObject_2 = __makeTemplateObject([\"$top=\", \"\"], [\"$top=\", \"\"])), state.take)\n  }[key]); }; };\n  // tslint:enable:max-line-length\n  /**\n   * Converts a [State]({% slug api_kendo-data-query_state %}) into an OData v4 compatible string.\n   *\n   * @param {State} state - The state that will be serialized.\n   * @param {ODataSettings} settings - The settings that are used during the serialization.\n   * @returns {string} - The serialized state.\n   */\n  var toODataString = function (state, settings) {\n      if (settings === void 0) { settings = {}; }\n      return (Object.keys(state)\n          .map(rules$1(settings, state))\n          .filter(isNotNullOrEmptyString)\n          .join('&'));\n  };\n  var templateObject_1, templateObject_2;\n\n  var getterCache = {};\n  var FIELD_REGEX = /\\[(?:(\\d+)|['\"](.*?)['\"])\\]|((?:(?!\\[.*?\\]|\\.).)+)/g;\n  // tslint:disable-next-line:no-string-literal\n  getterCache['undefined'] = function (obj) { return obj; };\n  /**\n   * @hidden\n   */\n  var getter = function (field, safe) {\n      var key = field + safe;\n      if (getterCache[key]) {\n          return getterCache[key];\n      }\n      var fields = [];\n      field.replace(FIELD_REGEX, function (_, index, indexAccessor, field) {\n          fields.push(isPresent(index) ? index : (indexAccessor || field));\n          return undefined;\n      });\n      getterCache[key] = function (obj) {\n          var result = obj;\n          for (var idx = 0; idx < fields.length; idx++) {\n              result = result[fields[idx]];\n              if (!isPresent(result) && safe) {\n                  return result;\n              }\n          }\n          return result;\n      };\n      return getterCache[key];\n  };\n\n  var toQueryString = function (values) { return values.reduce(function (acc, _a) {\n      var key = _a[0], value = _a[1];\n      return __spreadArray(__spreadArray([], acc, true), [\"\".concat(key, \"=\").concat(value)], false);\n  }, []); };\n  var toObject = function (values) { return values.reduce(function (acc, _a) {\n      var _b;\n      var key = _a[0], value = _a[1];\n      return (__assign(__assign({}, acc), (_b = {}, _b[key] = value, _b)));\n  }, {}); };\n  var pairwise = function (key) { return function (value) { return [key, value]; }; };\n  var empty = function () { return null; };\n  var isNotEmptyArray = function (value) { return isPresent(value) && isArray(value) && value.length > 0; };\n  var has = function (accessor) { return function (value) { return isPresent(accessor(value)); }; };\n  var isNotEmpty = function (accessor) { return function (value) { return isNotEmptyArray(accessor(value)); }; };\n  var runOrEmpty = function (predicate, fn) { return ifElse(predicate, fn, empty); };\n  var calcPage = function (_a) {\n      var skip = _a.skip, take = _a.take;\n      return Math.floor((skip || 0) / take) + 1;\n  };\n  var formatDescriptors = function (accessor, formatter) { return function (state) { return (accessor(state).map(formatter).join(\"~\")); }; };\n  var removeAfter = function (what) { return function (str) { return str.slice(0, str.indexOf(what)); }; };\n  var replace = function (patterns) {\n      return compose.apply(void 0, patterns.map(function (_a) {\n          var left = _a[0], right = _a[1];\n          return function (s) { return s.replace(new RegExp(left, \"g\"), right); };\n      }));\n  };\n  var sanitizeDateLiterals = replace([[\"\\\"\", \"\"], [\":\", \"-\"]]);\n  var removeAfterDot = removeAfter(\".\");\n  var directionFormatter = function (_a) {\n      var field = _a.field, _b = _a.dir, dir = _b === void 0 ? \"asc\" : _b;\n      return \"\".concat(field, \"-\").concat(dir);\n  };\n  var aggregateFormatter = function (_a) {\n      var field = _a.field, aggregate = _a.aggregate;\n      return \"\".concat(field, \"-\").concat(aggregate);\n  };\n  var take$1 = getter(\"take\");\n  var aggregates = getter(\"aggregates\");\n  var skip$1 = getter(\"skip\");\n  var group = getter(\"group\");\n  var sort = getter(\"sort\", true);\n  var formatSort = formatDescriptors(sort, directionFormatter);\n  var formatGroup = formatDescriptors(group, directionFormatter);\n  var formatAggregates = formatDescriptors(aggregates, aggregateFormatter);\n  var prefixDateValue = function (value) { return \"datetime'\".concat(value, \"'\"); };\n  var formatDateValue = compose(prefixDateValue, removeAfterDot, sanitizeDateLiterals, JSON.stringify, toUTC);\n  var formatDate = function (_a) {\n      var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n      return ({\n          value: formatDateValue(value),\n          field: field,\n          ignoreCase: ignoreCase,\n          operator: operator\n      });\n  };\n  var normalizeSort = function (state) { return Object.assign({}, state, {\n      sort: (sort(state) || []).filter(function (_a) {\n          var dir = _a.dir;\n          return isNotNullOrEmptyString(dir);\n      })\n  }); };\n  var transformSkip = compose(pairwise('page'), calcPage);\n  var transformTake = compose(pairwise('pageSize'), take$1);\n  var transformGroup = compose(pairwise('group'), formatGroup);\n  var transformSort = compose(pairwise('sort'), formatSort);\n  var transformAggregates = compose(pairwise('aggregate'), formatAggregates);\n  var serializePage = runOrEmpty(has(skip$1), transformSkip);\n  var serializePageSize = runOrEmpty(has(take$1), transformTake);\n  var serializeGroup = runOrEmpty(isNotEmpty(group), transformGroup);\n  var serializeAggregates = runOrEmpty(has(aggregates), transformAggregates);\n  var serializeSort = compose(runOrEmpty(isNotEmpty(sort), transformSort), normalizeSort);\n  var hasField = function (_a) {\n      var field = _a.field;\n      return isNotNullOrEmptyString(field);\n  };\n  var filterFormatter = function (_a) {\n      var field = _a.field, operator = _a.operator, value = _a.value;\n      return \"\".concat(field, \"~\").concat(operator, \"~\").concat(value);\n  };\n  var dateFormatter = ifElse(isDateValue, compose(filterFormatter, formatDate), filterFormatter);\n  var typedFormatter = function (encode) { return runOrEmpty(hasField, ifElse(isStringValue, compose(filterFormatter, quote, encode ? encodeValue : identity$2), dateFormatter)); };\n  var join = function (_a) {\n      var logic = _a.logic;\n      return \"~\".concat(logic, \"~\");\n  };\n  var serialize = function (encode) { return serializeFilters(function (filter) { return ifElse(isCompositeFilterDescriptor, serialize(encode), typedFormatter(encode))(filter); }, join); };\n  var serializeFilter = function (_a, encode) {\n      var filter = _a.filter;\n      if (filter && filter.filters) {\n          var filters = serialize(encode)(filter);\n          if (filters.length) {\n              return ['filter', filters];\n          }\n      }\n      return null;\n  };\n  var rules = function (state, encode) {\n      if (encode === void 0) { encode = true; }\n      return function (key) { return ({\n          \"aggregates\": serializeAggregates(state),\n          \"filter\": serializeFilter(state, encode),\n          \"group\": serializeGroup(state),\n          \"skip\": serializePage(state),\n          \"sort\": serializeSort(state),\n          \"take\": serializePageSize(state)\n      }[key]); };\n  };\n  /**\n   * Converts a [DataSourceRequestState]({% slug api_kendo-data-query_datasourcerequeststate %}) into a string\n   * that is comparable with the `DataSourceRequest` format in UI for ASP.NET MVC.\n   *\n   * @param {DataSourceRequestState} state - The state that will be serialized.\n   * @returns {string} - The serialized state.\n   *\n   * @example\n   * {% platform_content angular %}\n   * ```ts\n   *  import {\n   *      toDataSourceRequestString,\n   *      translateDataSourceResultGroups,\n   *      translateAggregateResults\n   * } from '@progress/kendo-data-query';\n   *\n   * export class Service {\n   *  private BASE_URL: string = '...';\n   *\n   *  constructor(private http: Http) { }\n   *\n   *  // Omitted for brevity...\n   *\n   *  private fetch(state: DataSourceRequestState): Observable<DataResult> {\n   *   const queryStr = `${toDataSourceRequestString(state)}`; //serialize the state\n   *   const hasGroups = state.group && state.group.length;\n   *\n   *   return this.http\n   *       .get(`${this.BASE_URL}?${queryStr}`) //send the state to the server\n   *       .map(response => response.json())\n   *       .map(({Data, Total, AggregateResults}) => // process the response\n   *           (<GridDataResult>{\n   *               //if there are groups convert them to compatible format\n   *               data: hasGroups ? translateDataSourceResultGroups(Data) : Data,\n   *               total: Total,\n   *               // convert the aggregates if such exists\n   *               aggregateResult: translateAggregateResults(AggregateResults)\n   *           })\n   *       );\n   *  }\n   * }\n   * ```\n   * {% endplatform_content %}\n   *\n   * {% platform_content react %}\n   * ```jsx\n   * import React from 'react';\n   * import { toDataSourceRequestString, translateDataSourceResultGroups } from '@progress/kendo-data-query';\n   *\n   * export function withState(WrappedGrid) {\n   *     return class StatefullGrid extends React.Component {\n   *         constructor(props) {\n   *             super(props);\n   *             this.state = { dataState: { skip: 0, take: 20 } };\n   *         }\n   *\n   *         render() {\n   *             return (\n   *                 <WrappedGrid\n   *                     filterable={true}\n   *                     sortable={true}\n   *                     pageable={{ pageSizes: true }}\n   *                     {...this.props}\n   *                     total={this.state.total}\n   *                     data={this.state.data}\n   *                     skip={this.state.dataState.skip}\n   *                     pageSize={this.state.dataState.take}\n   *                     filter={this.state.dataState.filter}\n   *                     sort={this.state.dataState.sort}\n   *                     dataStateChange={this.dataStateChange}\n   *                 />\n   *             );\n   *         }\n   *\n   *         componentDidMount() {\n   *             this.fetchData(this.state.dataState);\n   *         }\n   *\n   *         dataStateChange = (changeEvent) => {\n   *             this.setState({ dataState: changeEvent.data });\n   *             this.fetchData(changeEvent.data);\n   *         }\n   *\n   *         fetchData(dataState) {\n   *             const queryStr = `${toDataSourceRequestString(dataState)}`; // Serialize the state\n   *             const hasGroups = dataState.group && dataState.group.length;\n   *\n   *             const base_url = 'api/Products';\n   *             const init = { method: 'GET', accept: 'application/json', headers: {} };\n   *\n   *             fetch(`${base_url}?${queryStr}`, init)\n   *                 .then(response => response.json())\n   *                 .then(({ data, total }) => {\n   *                     this.setState({\n   *                         data: hasGroups ? translateDataSourceResultGroups(data) : data,\n   *                         total,\n   *                         dataState\n   *                     });\n   *                 });\n   *         }\n   *     }\n   * }\n   * ```\n   * {% endplatform_content %}\n   */\n  var toDataSourceRequestString = function (state) { return (toQueryString(Object.keys(state)\n      .map(rules(state))\n      .filter(isPresent)).join('&')); };\n  /**\n   * Converts a [DataSourceRequestState]({% slug api_kendo-data-query_datasourcerequeststate %}) into an object\n   * that is compatible with the `DataSourceRequest` format in UI for ASP.NET MVC.\n   *\n   * @param {DataSourceRequestState} state - The state that will be serialized.\n   * @returns {any} - The serialized state.\n   */\n  var toDataSourceRequest = function (state) { return (toObject(Object.keys(state)\n      .map(rules(state, false))\n      .filter(isPresent))); };\n\n  // tslint:enable:max-line-length\n  var set = function (field, target, value) {\n      target[field] = value;\n      return target;\n  };\n  var toCamelCase = function (str) { return str.replace(/(^[A-Z])/g, function (_, g1) { return g1.toLowerCase(); }); };\n  var prop = function (fieldName) { return function (obj) {\n      var value = obj[fieldName];\n      if (isPresent(value)) {\n          return value;\n      }\n      return obj[toCamelCase(fieldName)];\n  }; };\n  var member = prop(\"Member\");\n  var aggregateMethodName = prop(\"AggregateMethodName\");\n  var value = prop(\"Value\");\n  var convert = function (mapper) { return function (values) { return Object.keys(values).reduce(mapper.bind(null, values), {}); }; };\n  var translateAggregate = convert(function (source, acc, field) { return set(field.toLowerCase(), acc, source[field]); });\n  var translateAggregates = convert(function (source, acc, field) { return set(field, acc, translateAggregate(source[field])); });\n  var valueOrDefault = function (value, defaultValue) { return isPresent(value) ? value : defaultValue; };\n  var normalizeGroup = function (group) { return ({\n      aggregates: group.Aggregates || group.aggregates,\n      field: group.Member || group.member || group.field,\n      hasSubgroups: group.HasSubgroups || group.hasSubgroups || false,\n      items: group.Items || group.items,\n      value: valueOrDefault(group.Key, valueOrDefault(group.key, group.value))\n  }); };\n  var translateGroup = compose(function (_a) {\n      var field = _a.field, hasSubgroups = _a.hasSubgroups, value = _a.value, aggregates = _a.aggregates, items = _a.items;\n      return ({\n          aggregates: translateAggregates(aggregates),\n          field: field,\n          items: hasSubgroups ? items.map(translateGroup) : items,\n          value: value\n      });\n  }, normalizeGroup);\n  // tslint:disable:max-line-length\n  /**\n   * Converts the grouped result, which is returned into the `Data` field of the UI for ASP.NET MVC `ToDataSourceResult` method, to a comparable format.\n   * @param data - The value of the `Data` field of the response.\n   * @returns {GroupResult[]} - The converted result.\n   */\n  var translateDataSourceResultGroups = function (data) { return data.map(translateGroup); };\n  /**\n   * Converts the `AggregateResults` field content, which is returned by the UI for ASP.NET MVC `ToDataSourceResult` method, to a comparable format.\n   * @param data - The value of the `AggregateResults` field of the response.\n   * @returns {AggregateResult} - The converted result.\n   */\n  // tslint:enable:max-line-length\n  var translateAggregateResults = function (data) { return ((data || []).reduce(function (acc, x) { return set(member(x), acc, set(aggregateMethodName(x).toLowerCase(), acc[member(x)] || {}, value(x))); }, {})); };\n\n  var compare = function (a, b) {\n      if (isBlank(a)) {\n          return a === b ? 0 : -1;\n      }\n      if (isBlank(b)) {\n          return 1;\n      }\n      if (a.localeCompare) {\n          return a.localeCompare(b);\n      }\n      return a > b ? 1 : (a < b ? -1 : 0);\n  };\n  var compareDesc = function (a, b) { return compare(b, a); };\n  var descriptorAsFunc = function (descriptor) {\n      if (typeof descriptor.compare === 'function') {\n          return descriptor.compare;\n      }\n      var prop = getter(descriptor.field, true);\n      return function (a, b) { return (descriptor.dir === 'asc' ? compare : compareDesc)(prop(a), prop(b)); };\n  };\n  var initial = function (_a, _b) { return 0; };\n  // tslint:disable:max-line-length\n  /**\n   * Converts the `SortDescriptors` into a [Comparer]({% slug api_kendo-data-query_comparer %}) function that can be used through `Array.sort`. If multiple descriptors are provided, sorting is applied in a right-to-left order.\n   * @param {SortDescriptor[]} descriptors - The descriptors which will be converted.\n   * @returns {Comparer} - The produced function.\n   *\n   * @example\n   * ```ts\n   * import { composeSortDescriptors } from '@progress/kendo-data-query';\n   *\n   * const data = [{ name: \"Pork\" }, { name: \"Pepper\" }, { name: \"Beef\" } ];\n   * const comparer = composeSortDescriptors([{ field: \"name\", dir: \"asc\" }]);\n   * const result = data.sort(comparer);\n   * // output: [{ name: \"Beef\" }, { name: \"Pepper\" }, { name: \"Pork\" }];\n   * ```\n   */\n  // tslint:enable:max-line-length\n  var composeSortDescriptors = function (descriptors) { return (descriptors\n      .filter(function (x) { return isPresent(x.dir) || isPresent(x.compare); })\n      .map(function (descriptor) { return descriptorAsFunc(descriptor); })\n      .reduce(function (acc, curr) { return function (a, b) { return acc(a, b) || curr(a, b); }; }, initial)); };\n\n  var valueToString = function (value) {\n      value = isPresent(value) && value.getTime ? value.getTime() : value;\n      return value + \"\";\n  };\n  /**\n   * @hidden\n   */\n  var groupCombinator = function (field) {\n      var prop = getter(field, true);\n      var position = 0;\n      return function (agg, value) {\n          agg[field] = agg[field] || {};\n          var groupValue = prop(value);\n          var key = valueToString(groupValue);\n          var values = agg[field][key] || { __position: position++, aggregates: {}, items: [], value: groupValue };\n          values.items.push(value);\n          agg[field][key] = values;\n          return agg;\n      };\n  };\n  /**\n   * @hidden\n   */\n  var expandAggregates = function (result) {\n      if (result === void 0) { result = {}; }\n      Object.keys(result).forEach(function (field) {\n          var aggregates = result[field];\n          Object.keys(aggregates).forEach(function (aggregate) {\n              aggregates[aggregate] = aggregates[aggregate].result();\n          });\n      });\n      return result;\n  };\n  var aggregatesFuncs = function (name) { return ({\n      average: function () {\n          var value = 0;\n          var count = 0;\n          return {\n              calc: function (curr) {\n                  if (isNumeric(curr)) {\n                      value += curr;\n                      count++;\n                  }\n                  else {\n                      value = curr;\n                  }\n              },\n              result: function () { return isNumeric(value) ? value / count : value; }\n          };\n      },\n      count: function () {\n          var state = 0;\n          return {\n              calc: function () { return state++; },\n              result: function () { return state; }\n          };\n      },\n      max: function () {\n          var state = Number.NEGATIVE_INFINITY;\n          return {\n              calc: function (value) {\n                  state = isNumeric(state) || isDate(state) ? state : value;\n                  if (state < value && (isNumeric(value) || isDate(value))) {\n                      state = value;\n                  }\n              },\n              result: function () { return state; }\n          };\n      },\n      min: function () {\n          var state = Number.POSITIVE_INFINITY;\n          return {\n              calc: function (value) {\n                  state = isNumeric(state) || isDate(state) ? state : value;\n                  if (state > value && (isNumeric(value) || isDate(value))) {\n                      state = value;\n                  }\n              },\n              result: function () { return state; }\n          };\n      },\n      sum: function () {\n          var state = 0;\n          return {\n              calc: function (value) {\n                  value = isPresent(value) ? value : 0;\n                  state += value;\n              },\n              result: function () { return state; }\n          };\n      }\n  }[name]()); };\n  /**\n   * @hidden\n   */\n  var aggregatesCombinator = function (descriptors) {\n      var functions = descriptors.map(function (descriptor) {\n          var fieldAccessor = getter(descriptor.field, true);\n          var aggregateName = (descriptor.aggregate || \"\").toLowerCase();\n          var aggregateAccessor = getter(aggregateName, true);\n          return function (state, value) {\n              var fieldAggregates = state[descriptor.field] || {};\n              var aggregateFunction = aggregateAccessor(fieldAggregates)\n                  || aggregatesFuncs(aggregateName);\n              aggregateFunction.calc(fieldAccessor(value));\n              fieldAggregates[descriptor.aggregate] = aggregateFunction;\n              state[descriptor.field] = fieldAggregates;\n              return state;\n          };\n      });\n      return function (state, value) { return functions.reduce(function (agg, calc) { return calc(agg, value); }, state); };\n  };\n  /**\n   * @hidden\n   * Adds the value to the `arr` and produces a new array.\n   *\n   * > The original array will be modified.\n   */\n  var concat = function (arr, value) {\n      arr.push(value);\n      return arr;\n  };\n  /**\n   * @hidden\n   * Returns a reducer that will apply the specified transformation to the value.\n   */\n  var map = function (transform) { return (function (reduce) { return (function (acc, curr, index) { return reduce(acc, transform(curr, index)); }); }); };\n  /**\n   * @hidden\n   * Returns a reducer that will filter out items which do not match the `Predicate`.\n   */\n  var filter = function (predicate) { return (function (reduce) { return (function (acc, curr) { return predicate(curr) ? reduce(acc, curr) : acc; }); }); };\n  /**\n   * @hidden\n   */\n  var isTransformerResult = function (source) {\n      return isPresent(source.__value);\n  };\n  var reduced = function (x) {\n      if (isTransformerResult(x)) {\n          return x;\n      }\n      return {\n          __value: x,\n          reduced: true\n      };\n  };\n  /**\n   * @hidden\n   * Returns a reducer that will take the specified number of items.\n   */\n  var take = function (count) { return (function (reduce) { return (function (acc, curr) { return count-- > 0 ? reduce(acc, curr) : reduced(acc); }); }); };\n  /**\n   * @hidden\n   * Returns a reducer that will take the specified number of items.\n   */\n  var takeWhile = function (predicate) { return (function (reduce) { return (function (acc, curr) { return predicate(curr) ? reduce(acc, curr) : reduced(acc); }); }); };\n  /**\n   * @hidden\n   * Returns a reducer that will skip the specified number of items.\n   */\n  var skip = function (count) { return (function (reduce) { return (function (acc, curr) { return count-- <= 0 ? reduce(acc, curr) : acc; }); }); };\n  /**\n   * @hidden\n   * Transforms the data by applying the supplied transformer.\n   */\n  var exec = function (transform, initialValue, data) {\n      var result = initialValue;\n      for (var idx = 0, length_1 = data.length; idx < length_1; idx++) {\n          result = transform(result, data[idx], idx);\n          if (isTransformerResult(result)) {\n              result = result.__value;\n              break;\n          }\n      }\n      return result;\n  };\n\n  var identity$1 = map(function (x) { return x; });\n  // tslint:disable:max-line-length\n  /**\n   * Applies the specified [`AggregateDescriptors`]({% slug api_kendo-data-query_aggregatedescriptor %}) to the data. Returns an [`AggregateResult`]({% slug api_kendo-data-query_aggregateresult %}) instance.\n   *\n   * @example\n   * ```ts\n   * const data = [\n   *    { unitPrice: 23, unitsInStock: 21 },\n   *    { unitPrice: 10, unitsInStock: 12 },\n   *    { unitPrice: 20, unitsInStock: 33 }\n   * ];\n   *\n   * const result = aggregateBy(data, [\n   *   { aggregate: \"sum\", field: \"unitPrice\" },\n   *   { aggregate: \"sum\", field: \"unitsInStock\" }\n   * ]);\n   *\n   * //output:\n   * // {\n   * //     \"unitPrice\": { \"sum\": 53 },\n   * //     \"unitsInStock\": { \"sum\": 66 }\n   * // }\n   * ```\n   * @param {T[]} data - The data on which the calculation will be executed.\n   * @param {AggregateDescriptor[]} descriptors - The aggregate operations that will be executed.\n   * @param {any} transformers - For internal use.\n   * @returns {AggregateResult} - The aggregated result.\n   * For more information, refer to the [aggregateresult](slug:api_kendo-data-query_aggregateresult) configuration.\n   */\n  // tslint:enable:max-line-length\n  var aggregateBy = function (data, descriptors, transformers) {\n      if (descriptors === void 0) { descriptors = []; }\n      if (transformers === void 0) { transformers = identity$1; }\n      var initialValue = {};\n      if (!descriptors.length) {\n          return initialValue;\n      }\n      var result = exec(transformers(aggregatesCombinator(descriptors)), initialValue, data);\n      return expandAggregates(result);\n  };\n\n  var logic = {\n      \"or\": {\n          concat: function (acc, fn) { return function (a) { return acc(a) || fn(a); }; },\n          identity: function () { return false; }\n      },\n      \"and\": {\n          concat: function (acc, fn) { return function (a) { return acc(a) && fn(a); }; },\n          identity: function () { return true; }\n      }\n  };\n  var operatorsMap = {\n      contains: function (a, b) { return (a || \"\").indexOf(b) >= 0; },\n      doesnotcontain: function (a, b) { return (a || \"\").indexOf(b) === -1; },\n      doesnotendwith: function (a, b) { return (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) < 0; },\n      doesnotstartwith: function (a, b) { return (a || \"\").lastIndexOf(b, 0) === -1; },\n      endswith: function (a, b) { return (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) >= 0; },\n      eq: function (a, b) { return a === b; },\n      gt: function (a, b) { return a > b; },\n      gte: function (a, b) { return a >= b; },\n      isempty: function (a) { return a === ''; },\n      isnotempty: function (a) { return a !== ''; },\n      isnotnull: function (a) { return isPresent(a); },\n      isnull: function (a) { return isBlank(a); },\n      lt: function (a, b) { return a < b; },\n      lte: function (a, b) { return a <= b; },\n      neq: function (a, b) { return a != b; },\n      startswith: function (a, b) { return (a || \"\").lastIndexOf(b, 0) === 0; }\n  };\n  var dateRegExp = /^\\/Date\\((.*?)\\)\\/$/;\n  var convertValue = function (value, ignoreCase) {\n      if (value != null && isString(value)) {\n          var date = dateRegExp.exec(value);\n          if (date) {\n              return new Date(+date[1]).getTime();\n          }\n          else if (ignoreCase) {\n              return value.toLowerCase();\n          }\n      }\n      else if (value != null && isDate(value)) {\n          return value.getTime();\n      }\n      return value;\n  };\n  var typedGetter = function (prop, value, ignoreCase) {\n      if (!isPresent(value)) {\n          return prop;\n      }\n      var acc = prop;\n      if (isString(value)) {\n          var date = dateRegExp.exec(value);\n          if (date) {\n              value = new Date(+date[1]);\n          }\n          else {\n              acc = function (a) {\n                  var x = prop(a);\n                  if (x === null) {\n                      return x;\n                  }\n                  var stringValue = typeof x === 'string' ? x : x + \"\";\n                  return ignoreCase ? stringValue.toLowerCase() : stringValue;\n              };\n          }\n      }\n      if (isDate(value)) {\n          return function (a) {\n              var x = acc(a);\n              return isDate(x) ? x.getTime() : x;\n          };\n      }\n      return acc;\n  };\n  var transformFilter = function (_a) {\n      var field = _a.field, ignoreCase = _a.ignoreCase, value = _a.value, operator = _a.operator;\n      field = !isPresent(field) ? function (a) { return a; } : field;\n      ignoreCase = isPresent(ignoreCase) ? ignoreCase : true;\n      var itemProp = typedGetter(isFunction(field) ? field : getter(field, true), value, ignoreCase);\n      value = convertValue(value, ignoreCase);\n      var op = isFunction(operator) ? operator : operatorsMap[operator];\n      return function (a) { return op(itemProp(a), value, ignoreCase); };\n  };\n  /**\n   * @hidden\n   */\n  var transformCompositeFilter = function (filter) {\n      var combiner = logic[filter.logic];\n      return filter.filters\n          .filter(isPresent)\n          .map(function (x) { return isCompositeFilterDescriptor(x) ? transformCompositeFilter(x) : transformFilter(x); })\n          .reduce(combiner.concat, combiner.identity);\n  };\n\n  // tslint:disable:max-line-length\n  /**\n   * Creates a [Predicate]({% slug api_kendo-data-query_predicate %}) function for the specified [CompositeFilterDescriptor]({% slug api_kendo-data-query_compositefilterdescriptor %}).\n   *\n   * @param {CompositeFilterDescriptor} descriptor - The descriptor for which the predicate is created.\n   * @returns {Predicate} - The created function instance.\n   *\n   * @example\n   * ```ts\n   * import { compileFilter } from '@progress/kendo-data-query';\n   *\n   * const data = [{ name: \"Pork\" }, { name: \"Pepper\" }, { name: \"Beef\" } ];\n   * const predicate = compileFilter({ logic: \"and\", filters: [{ field: \"name\", operator: \"startswith\", value: \"P\" }] });\n   * const result = data.filter(predicate);\n   *\n   * ```\n   */\n  // tslint:enable:max-line-length\n  var compileFilter = function (descriptor) {\n      if (!descriptor || descriptor.filters.length === 0) {\n          return function () { return true; };\n      }\n      return transformCompositeFilter(descriptor);\n  };\n  // tslint:disable:max-line-length\n  /**\n   * Filters the provided array according to the specified [CompositeFilterDescriptor]({% slug api_kendo-data-query_compositefilterdescriptor %}).\n   *\n   * @param {T[]} data - The data that will be filtered.\n   * @param {(CompositeFilterDescriptor | FilterDescriptor)} descriptor - The filter criteria that will be applied.\n   * @returns {T[]} - The filtered data.\n   *\n   * @example\n   * ```ts\n   * import { filterBy } from '@progress/kendo-data-query';\n   *\n   * const data = [\n   *  { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n   *  { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n   *  { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n   * ];\n   *\n   * const result = filterBy(data, {\n   *     logic: 'and',\n   *     filters: [\n   *           { field: \"name\", operator: \"startswith\", value: \"p\", ignoreCase: true },\n   *           { field: \"subcategory\", operator: \"eq\", value: \"Meat\" },\n   *     ]\n   * });\n   *\n   * // output:\n   * // [{ \"name\": \"Pork\", \"category\": \"Food\", \"subcategory\": \"Meat\" }]\n   * ```\n   */\n  // tslint:enable:max-line-length\n  var filterBy = function (data, descriptor) {\n      if (!isPresent(descriptor) || (isCompositeFilterDescriptor(descriptor) && descriptor.filters.length === 0)) {\n          return data;\n      }\n      return data.filter(compileFilter(normalizeFilters(descriptor)));\n  };\n\n  /**\n   * @hidden\n   */\n  var normalizeGroups = function (descriptors) {\n      descriptors = isArray(descriptors) ? descriptors : [descriptors];\n      return descriptors.map(function (x) { return Object.assign({ dir: \"asc\" }, x); });\n  };\n  var identity = map(function (x) { return x; });\n  /**\n   * Groups the provided data according to the specified descriptors.\n   *\n   * @param {Array} data - The data that will be grouped.\n   * @param {GroupDescriptor[]} descriptors - The descriptors.\n   * @param {any} transformers - For internal use.\n   * @param {Array} originalData - For internal use.\n   * @returns {(Array<GroupResult<T>> | T[])} - The grouped data.\n   *\n   * @example\n   * ```ts\n   *\n   * import { groupBy } from '@progress/kendo-data-query';\n   *\n   * const data = [\n   *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n   *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n   *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n   * ];\n   *\n   * const result = groupBy(data, [{ field: \"subcategory\" }]);\n   * ```\n   */\n  var groupBy = function (data, descriptors, transformers, originalData) {\n      if (descriptors === void 0) { descriptors = []; }\n      if (transformers === void 0) { transformers = identity; }\n      if (originalData === void 0) { originalData = data; }\n      descriptors = normalizeGroups(descriptors);\n      if (!descriptors.length) {\n          return data;\n      }\n      var descriptor = descriptors[0];\n      var initialValue = {};\n      var view = exec(transformers(groupCombinator(descriptor.field)), initialValue, data);\n      var result = [];\n      Object.keys(view).forEach(function (field) {\n          Object.keys(view[field]).forEach(function (value) {\n              var group = view[field][value];\n              var aggregateResult = {};\n              var filteredData = originalData;\n              if (isPresent(descriptor.aggregates)) {\n                  filteredData = filterBy(originalData, {\n                      field: descriptor.field,\n                      ignoreCase: false,\n                      operator: 'eq',\n                      value: group.value\n                  });\n                  aggregateResult = aggregateBy(filteredData, descriptor.aggregates);\n              }\n              result[group.__position] = {\n                  aggregates: aggregateResult,\n                  field: field,\n                  items: descriptors.length > 1 ?\n                      groupBy(group.items, descriptors.slice(1), identity, filteredData)\n                      : group.items,\n                  value: group.value\n              };\n          });\n      });\n      return result;\n  };\n\n  /**\n   * Orders the specified array according to the provided sort descriptors.\n   *\n   * @param {T[]} data - The data to be sorted.\n   * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.\n   * @returns {T[]} - The sorted data.\n   *\n   * @example\n   * ```ts\n   * import { orderBy } from '@progress/kendo-data-query';\n   *\n   * const data = [\n   *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n   *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n   *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n   * ];\n   *\n   * const sortDesc: SortDescriptor[] = [{ field: \"name\", dir: \"asc\" }];\n   *\n   * const result = orderBy(data, sortDesc);\n   * ```\n   */\n  var orderBy = function (data, descriptors) {\n      if (descriptors.some(function (x) { return isPresent(x.dir) || isPresent(x.compare); })) {\n          data = data.slice(0);\n          var comparer = composeSortDescriptors(descriptors);\n          data.sort(comparer);\n      }\n      return data;\n  };\n  var defaultComparer = function (a, b) { return a === b; };\n  var normalizeComparer = function (comparer) {\n      if (isString(comparer)) {\n          var accessor_1 = getter(comparer);\n          comparer = function (a, b) { return accessor_1(a) === accessor_1(b); };\n      }\n      return comparer;\n  };\n  var _distinct = function (data, comparer) {\n      return data.filter(function (x, idx, xs) { return xs.findIndex(comparer.bind(null, x)) === idx; });\n  };\n  /**\n   * Reduces the provided array so it contains only unique values.\n   *\n   * @param {T[]} data - The array that will be reduced.\n   * @param {(Comparer | string)} comparer - An optional custom comparer function or the field name that will be used for comparison.\n   * @returns {T[]} - The reduced data.\n   *\n   * @example\n   * ```ts\n   * import { distinct } from '@progress/kendo-data-query';\n   *\n   * const data = [\n   *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n   *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n   *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n   * ];\n   *\n   * const result = distinct(data, \"subcategory\");\n   *\n   * // output:\n   * // result => [\n   * //     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n   * //     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" }\n   * // ];\n   * ```\n   */\n  var distinct = function (data, comparer) {\n      if (comparer === void 0) { comparer = defaultComparer; }\n      return _distinct(data, normalizeComparer(comparer));\n  };\n  /**\n   * @hidden\n   */\n  var count = function (data, predicate) {\n      var counter = 0;\n      for (var idx = 0, length_1 = data.length; idx < length_1; idx++) {\n          if (predicate(data[idx])) {\n              counter++;\n          }\n      }\n      return counter;\n  };\n  /**\n   * @hidden\n   */\n  var limit = function (data, predicate) {\n      if (predicate) {\n          return data.filter(predicate);\n      }\n      return data;\n  };\n  /**\n   * Applies the specified operation descriptors to the data.\n   *\n   * @param {T[]} data - The data to be processed.\n   * @param {State} state - The operation descriptors that will be applied to the data.\n   * @returns {DataResult} - The processed data.\n   *\n   * @example\n   * ```ts\n   *\n   * const result = process(data, {\n   *     skip: 10,\n   *     take: 20,\n   *     group: [{\n   *       field: 'category.categoryName',\n   *             aggregates: [\n   *                   { aggregate: \"sum\", field: \"unitPrice\" },\n   *                   { aggregate: \"sum\", field: \"unitsInStock\" }\n   *             ]\n   *       }],\n   *     sort: [{ field: 'productName', dir: 'desc' }],\n   *     filter: {\n   *         logic: \"or\",\n   *         filters: [\n   *           { field: \"discontinued\", operator: \"eq\", value: true },\n   *           { field: \"unitPrice\", operator: \"lt\", value: 22 }\n   *         ]\n   *     }\n   * });\n   *\n   * ```\n   */\n  var process = function (data, state) {\n      var skipCount = state.skip, takeCount = state.take, filterDescriptor = state.filter, sort = state.sort, group = state.group;\n      var sortDescriptors = __spreadArray(__spreadArray([], normalizeGroups(group || []), true), sort || [], true);\n      if (sortDescriptors.length) {\n          data = orderBy(data, sortDescriptors);\n      }\n      var hasFilters = isPresent(filterDescriptor) && filter.length;\n      var hasGroups = isPresent(group) && group.length;\n      if (!hasFilters && !hasGroups) {\n          return {\n              data: takeCount ? data.slice(skipCount, skipCount + takeCount) : data,\n              total: data.length\n          };\n      }\n      var total;\n      var transformers = [];\n      var predicate;\n      if (hasFilters) {\n          predicate = compileFilter(normalizeFilters(filterDescriptor));\n          total = count(data, predicate);\n          transformers.push(filter(predicate));\n      }\n      else {\n          total = data.length;\n      }\n      if (isPresent(skipCount) && isPresent(takeCount)) {\n          transformers.push(skip(skipCount));\n          transformers.push(take(takeCount));\n      }\n      if (transformers.length) {\n          var transform = compose.apply(void 0, transformers);\n          var result = hasGroups ?\n              groupBy(data, group, transform, limit(data, predicate)) :\n              exec(transform(concat), [], data);\n          return { data: result, total: total };\n      }\n      return {\n          data: hasGroups ? groupBy(data, group) : data,\n          total: total\n      };\n  };\n\n  /**\n   * Represents the list of supported [`FilterDescriptor`]({% slug api_kendo-data-query_filterdescriptor %}) operators.\n   * Allows restricting `FilterDescriptor.operator` definition to available values only.\n   */\n  var FilterOperator;\n  (function (FilterOperator) {\n      /**\n       * The `contains` operator.\n       */\n      FilterOperator[\"Contains\"] = \"contains\";\n      /**\n       * The `doesnotcontain` operator.\n       */\n      FilterOperator[\"DoesNotContain\"] = \"doesnotcontain\";\n      /**\n       * The `doesnotendwith` operator.\n       */\n      FilterOperator[\"DoesNotEndWith\"] = \"doesnotendwith\";\n      /**\n       * The `doesnotstartwith` operator.\n       */\n      FilterOperator[\"DoesNotStartWith\"] = \"doesnotstartwith\";\n      /**\n       * The `endswith` operator.\n       */\n      FilterOperator[\"EndsWith\"] = \"endswith\";\n      /**\n       * The `eq` operator.\n       */\n      FilterOperator[\"EqualTo\"] = \"eq\";\n      /**\n       * The `gt` operator.\n       */\n      FilterOperator[\"GreaterThan\"] = \"gt\";\n      /**\n       * The `gte` operator.\n       */\n      FilterOperator[\"GreaterThanOrEqual\"] = \"gte\";\n      /**\n       * The `isempty` operator.\n       */\n      FilterOperator[\"IsEmpty\"] = \"isempty\";\n      /**\n       * The `isnotempty` operator.\n       */\n      FilterOperator[\"IsNotEmpty\"] = \"isnotempty\";\n      /**\n       * The `isnotnull` operator.\n       */\n      FilterOperator[\"IsNotNull\"] = \"isnotnull\";\n      /**\n       * The `isnull` operator.\n       */\n      FilterOperator[\"IsNull\"] = \"isnull\";\n      /**\n       * The `lt` operator.\n       */\n      FilterOperator[\"LessThan\"] = \"lt\";\n      /**\n       * The `lte` operator.\n       */\n      FilterOperator[\"LessThanOrEqual\"] = \"lte\";\n      /**\n       * The `neq` operator.\n       */\n      FilterOperator[\"NotEqualTo\"] = \"neq\";\n      /**\n       * The `startswith` operator.\n       */\n      FilterOperator[\"StartsWith\"] = \"startswith\";\n  })(FilterOperator || (FilterOperator = {}));\n\n  exports.__meta__ = __meta__;\n  exports.c = compileFilter;\n\n}));\n"]}